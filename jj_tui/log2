Commit ID: 0dff1f977d48f4537fa8c357b8fe08c1910e4ac4
Change ID: kszkuqqsvpknsnosxyxmnunnqvrzmpvq
Author: Eli Dowling <eli.jambu@gmail.com> (2024-05-08 01:20:28)
Committer: Eli Dowling <eli.jambu@gmail.com> (2024-05-09 00:02:20)

    coloured output is working

Added regular file ../.ocamlformat:
        1: version=0.24.1
        2: profile=conventional
Removed regular file ../bin/dune:
   1     : (executable
   2     :  (public_name jj_tui)
   3     :  (name main)
   4     :  (libraries jj_tui feather lwd nottui base core stdio core_unix.command_unix )
   5     :  )
Removed regular file ../bin/main.ml:
   1     : open Nottui;;
   2     : open Feather;;
   3     : open Lwd_infix;;
   4     : module W = Nottui_widgets;;
   5     : 
   6     : 
   7     : (* Ui_loop.run (Lwd.pure (W.printf "Hello world"));; *)
   8     : 
   9     : let cmdArgs cmd args=
  10     :   let (stdout,stderr)=Feather.process cmd args|>Feather.collect stdout_and_stderr in
  11     :   stdout^stderr
  12     : ;;
  13     : let cmd cmd =
  14     :   let (stdout,stderr)=Feather.process cmd []|>Feather.collect stdout_and_stderr in
  15     :   stdout^stderr
  16     : 
  17     : ;;
  18     : 
  19     : 
  20     : let vcount = Lwd.var "";;
  21     : 
  22     : let button = 
  23     :   W.button (Printf.sprintf "run jj" )
  24     :            (fun () ->  vcount $= (cmd"jj"))
  25     :   |>Lwd.pure
  26     :          ;;
  27     : let vQuit=Lwd.var false;;
  28     : 
  29     : let quitButton  = 
  30     :   W.button (Printf.sprintf "quit " )
  31     :            (fun () ->  vQuit $= true)
  32     :   |>Lwd.pure
  33     :          ;;
  34     : 
  35     : 
  36     : let (<-$) f v=Lwd.map ~f (Lwd.get v);; 
  37     : let vShowStatus= Lwd.var "";;
  38     : let inputs ui=
  39     :   Ui.event_filter (fun event->
  40     :     match event with
  41     :     |`Key (`ASCII 'l',_)-> 
  42     :         let res=cmd "jj"in
  43     :         vcount$=res;
  44     : 
  45     :         `Handled
  46     :     |`Key (`ASCII 's',_)-> 
  47     :         let res=cmdArgs "jj" ["show"]in
  48     :         vShowStatus$=res;
  49     : 
  50     :         `Handled
  51     :     |`Key (`ASCII 'p',_)-> 
  52     :         let _=cmdArgs "jj"["prev"]in
  53     : 
  54     :         `Handled
  55     :     |`Key (`ASCII 'n',_)-> 
  56     :         let _=cmdArgs "jj"["next"]in
  57     : 
  58     :         `Handled
  59     :     |_->`Unhandled
  60     :       ) ui
  61     :   ;;
  62     : let mainUi= 
  63     :   Lwd.map ~f:inputs @@
  64     :   W.h_pane
  65     :   (Nottui_widgets.vbox [
  66     :     button;
  67     :     W.string <-$ vcount;
  68     :     quitButton])
  69     :   (W.string <-$ vShowStatus)
  70     : ;;
  71     :       
  72     : 
  73     : Ui_loop.run ~quit:vQuit (mainUi);;
  74     : 
  75     : (*
  76     : type tree = Tree of string * (unit -> tree list)
  77     : 
  78     : let rec tree_ui (Tree (label, child)) =
  79     :   let opened = Lwd.var false in
  80     :   let render is_opened =
  81     :     let btn_text = if is_opened then "[-] " else "[+] " in
  82     :     let btn_action () = Lwd.set opened (not is_opened) in
  83     :     let btn = W.button (btn_text ^ label) btn_action in
  84     :     let layout node forest =
  85     :       Ui.join_y node (Ui.join_x (Ui.space 2 0) forest) 
  86     :     in
  87     :     if is_opened 
  88     :     then Lwd.map ~f:(layout btn) (forest_ui (child ()))
  89     :     else Lwd.pure btn
  90     :   in
  91     :   Lwd.join (Lwd.map ~f:render (Lwd.get opened))
  92     :   
  93     : and forest_ui nodes = 
  94     :   Lwd_utils.pack Ui.pack_y 
  95     :     (List.map tree_ui nodes)
  96     : ;;
  97     : 
  98     : let rec fake_fs () = [
  99     :   Tree ("bin", fake_fs);
 100     :   Tree ("home", fake_fs);
 101     :   Tree ("usr", fake_fs);
 102     : ] in
 103     : 
 104     : Ui_loop.run (forest_ui (fake_fs ()));;
 105     : *)
Removed regular file ../dune-project:
   1     : (lang dune 3.9)
   2     : 
   3     : (name jj_tui)
   4     : 
   5     : (generate_opam_files true)
   6     : 
   7     : (source
   8     :  (github username/reponame))
   9     : 
  10     : (authors "Author Name")
  11     : 
  12     : (maintainers "Maintainer Name")
  13     : 
  14     : (license LICENSE)
  15     : 
  16     : (documentation https://url/to/documentation)
  17     : 
  18     : (package
  19     :  (name jj_tui)
  20     :  (synopsis "A short synopsis")
  21     :  (description "A longer description")
  22     :  (depends ocaml dune)
  23     :  (tags
  24     :   (topics "to describe" your project)))
  25     : 
  26     : ; See the complete stanza docs at https://dune.readthedocs.io/en/stable/dune-files.html#dune-project
Removed regular file ../flake.lock:
   1     : {
   2     :   "nodes": {
   3     :     "nixpkgs": {
   4     :       "locked": {
   5     :         "lastModified": 1713344939,
   6     :         "narHash": "sha256-jpHkAt0sG2/J7ueKnG7VvLLkBYUMQbXQ2L8OBpVG53s=",
   7     :         "path": "/nix/store/ngm8a5avsnfk266jha4j5xy93xfhjasf-source",
   8     :         "rev": "e402c3eb6d88384ca6c52ef1c53e61bdc9b84ddd",
   9     :         "type": "path"
  10     :       },
  11     :       "original": {
  12     :         "id": "nixpkgs",
  13     :         "type": "indirect"
  14     :       }
  15     :     },
  16     :     "root": {
  17     :       "inputs": {
  18     :         "nixpkgs": "nixpkgs"
  19     :       }
  20     :     }
  21     :   },
  22     :   "root": "root",
  23     :   "version": 7
  24     : }
Removed regular file ../flake.nix:
   1     : {
   2     :   description = "Example JavaScript development environment for Zero to Nix";
   3     : 
   4     :   # Flake inputs
   5     :   inputs = {
   6     : 
   7     :     # nixpkgs.url = "github:NixOS/nixpkgs/nixos-unstable";
   8     :     nixpkgs.url = "nixpkgs"; # also valid: "nixpkgs"
   9     : 
  10     :     # roc={
  11     :     #   url="github:roc-lang/roc";
  12     :     # inputs.nixpkgs.follows="nixpkgs";
  13     : 
  14     :     # };
  15     : 
  16     :   };
  17     :   # Flake outputs
  18     :   outputs = { self, nixpkgs, ... }@inputs:
  19     :     let
  20     :       # Systems supported
  21     :       allSystems = [
  22     :         "x86_64-linux" # 64-bit Intel/AMD Linux
  23     :       ];
  24     : 
  25     :       # Helper to provide system-specific attributes
  26     :       forAllSystems = f:
  27     :         nixpkgs.lib.genAttrs allSystems (system:
  28     :           f {
  29     :             pkgs = import nixpkgs { inherit system; };
  30     : 
  31     :           });
  32     :     in {
  33     :       # Development environment output
  34     :       devShells = forAllSystems ({ pkgs }: {
  35     :         default =
  36     : 
  37     :           pkgs.mkShell {
  38     :             packages = with pkgs; [ pkgs.pkg-config gmp stdenv.cc.cc.lib ];
  39     :             shellHook = let
  40     :               libPath =
  41     :                 pkgs.lib.makeLibraryPath [ pkgs.stdenv.cc.cc.lib pkgs.gmp ];
  42     :             in ''
  43     :               # yolo
  44     :               export CFLAGS="$CFLAGS -I${pkgs.stdenv.cc.cc.lib}/include -I${pkgs.gmp}/include"
  45     :               export LIBS="$LIBS -L${pkgs.stdenv.cc.cc.lib}/lib -L${pkgs.gmp}/lib"
  46     :             '';
  47     :           };
  48     : 
  49     :       });
  50     : 
  51     :     };
  52     : }
Added regular file .ocamlformat:
        1: 
        2: profile=conventional
Added regular file .ocmalformat:
        1: version=0.24.1
        2: profile=conventional
Added regular file bin/dune:
        1: (executable
        2:  (public_name jj_tui)
        3:  (name main)
        4:  (libraries jj_tui feather lwd nottui base core stdio core_unix.command_unix )
        5:  )
Added regular file bin/main.ml:
        1: open Nottui
        2: open Feather
        3: open Lwd_infix
        4: open Notty
        5: module W = Nottui_widgets
        6: 
        7: let colored_string = Jj_tui.AnsiReverse.colored_string
        8: 
        9: (* Ui_loop.run (Lwd.pure (W.printf "Hello world"));; *)
       10: let cmdArgs cmd args =
       11:   let stdout, stderr =
       12:     Feather.process cmd args |> Feather.collect stdout_and_stderr
       13:   in
       14:   stdout ^ stderr
       15: 
       16: let jj args = cmdArgs "jj" (List.concat [ args; [ "--color"; "always" ] ])
       17: let vcount = Lwd.var I.empty
       18: 
       19: let _button =
       20:   W.button (Printf.sprintf "run jj") (fun () ->
       21:       vcount $= (cmdArgs "jj" [ "log"; "--color"; "always" ] |> colored_string))
       22:   |> Lwd.pure
       23: 
       24: let vQuit = Lwd.var false
       25: 
       26: let _quitButton =
       27:   W.button (Printf.sprintf "quit ") (fun () -> vQuit $= true) |> Lwd.pure
       28: 
       29: let ( <-$ ) f v = Lwd.map ~f (Lwd.get v)
       30: 
       31: (* let ( let<- ) v f = Lwd.map ~f (Lwd.get v) *)
       32: let vShowStatus = Lwd.var I.empty
       33: let vother = Lwd.var ""
       34: 
       35: let onChange () =
       36:   let res = jj [ "show" ] |> colored_string in
       37:   vShowStatus $= res;
       38:   let res = jj [] in
       39:   vcount $= colored_string res
       40: 
       41: let changeInputs key =
       42:   let noOut args =
       43:     let _ = jj args in
       44:     `Handled
       45:   in
       46:   match key with
       47:   | 'P' -> noOut [ "prev" ]
       48:   | 'p' -> noOut [ "prev"; "--edit" ]
       49:   | 'N' -> noOut [ "next" ]
       50:   | 'n' -> noOut [ "next"; "--edit" ]
       51:   | 'S' -> noOut [ "unsquash"; "-i"; "--tool"; "sublime_merge" ]
       52:   | _ -> `Unhandled
       53: 
       54: let inputs ui =
       55:   Ui.event_filter
       56:     (fun event ->
       57:       match event with
       58:       | `Key (`ASCII 's', _) ->
       59:           let res = jj [ "show" ] in
       60:           vShowStatus $= (res |> colored_string);
       61: 
       62:           `Handled
       63:       | `Key (`ASCII 'l', _) ->
       64:           let res = jj [] in
       65:           vcount $= colored_string res;
       66:           vother $= res;
       67: 
       68:           `Handled
       69:       | `Key (`ASCII 'q', _) ->
       70:           vQuit $= true;
       71: 
       72:           `Handled
       73:       | `Key (`ASCII key, _) -> (
       74:           match changeInputs key with
       75:           | `Handled ->
       76:               onChange ();
       77:               `Handled
       78:           | `Unhandled -> `Unhandled)
       79:       | _ -> `Unhandled)
       80:     ui
       81: 
       82: let mainUi =
       83:   let$ pane =
       84:     W.h_pane
       85:       (Nottui_widgets.vbox
       86:          [ (* button;  *) Ui.atom <-$ vcount (* quitButton  *) ])
       87:       (Ui.atom <-$ vShowStatus)
       88:   in
       89:   inputs pane
       90: ;;
       91: 
       92: (*TODO:For hosting a subprocess i should look into using EIO and Ui_loop.step like some of the other libraries built with nottui*)
       93: Ui_loop.run ~quit:vQuit mainUi
       94: (* let my_image=(Notty.I.string Notty.A.empty "\027[32mThis is in green %s\027[0m" ) in *)
       95: (* let my_image =
       96:      Jj_tui.AnsiReverse.Cap.parse_ansi_escape_codes
       97:        "\027[32mThis is in green %s\027[0m "
       98:      |> List.map (fun (x, str) -> Notty.I.string x str)
       99:    ;;
      100: 
      101:    Notty_unix.output_image (my_image |> List.hd) *)
      102: 
      103: (*
      104: type tree = Tree of string * (unit -> tree list)
      105: 
      106: let rec tree_ui (Tree (label, child)) =
      107:   let opened = Lwd.var false in
      108:   let render is_opened =
      109:     let btn_text = if is_opened then "[-] " else "[+] " in
      110:     let btn_action () = Lwd.set opened (not is_opened) in
      111:     let btn = W.button (btn_text ^ label) btn_action in
      112:     let layout node forest =
      113:       Ui.join_y node (Ui.join_x (Ui.space 2 0) forest) 
      114:     in
      115:     if is_opened 
      116:     then Lwd.map ~f:(layout btn) (forest_ui (child ()))
      117:     else Lwd.pure btn
      118:   in
      119:   Lwd.join (Lwd.map ~f:render (Lwd.get opened))
      120:   
      121: and forest_ui nodes = 
      122:   Lwd_utils.pack Ui.pack_y 
      123:     (List.map tree_ui nodes)
      124: ;;
      125: 
      126: let rec fake_fs () = [
      127:   Tree ("bin", fake_fs);
      128:   Tree ("home", fake_fs);
      129:   Tree ("usr", fake_fs);
      130: ] in
      131: 
      132: Ui_loop.run (forest_ui (fake_fs ()));;
      133: *)
Added regular file dune-project:
        1: (lang dune 3.9)
        2: 
        3: (name jj_tui)
        4: 
        5: (generate_opam_files true)
        6: 
        7: (source
        8:  (github username/reponame))
        9: 
       10: (authors "Author Name")
       11: 
       12: (maintainers "Maintainer Name")
       13: 
       14: (license LICENSE)
       15: 
       16: (documentation https://url/to/documentation)
       17: 
       18: (package
       19:  (name jj_tui)
       20:  (synopsis "A short synopsis")
       21:  (description "A longer description")
       22:  (depends ocaml dune)
       23:  (tags
       24:   (topics "to describe" your project)))
       25: 
       26: ; See the complete stanza docs at https://dune.readthedocs.io/en/stable/dune-files.html#dune-project
Added regular file flake.lock:
        1: {
        2:   "nodes": {
        3:     "nixpkgs": {
        4:       "locked": {
        5:         "lastModified": 1713344939,
        6:         "narHash": "sha256-jpHkAt0sG2/J7ueKnG7VvLLkBYUMQbXQ2L8OBpVG53s=",
        7:         "path": "/nix/store/ngm8a5avsnfk266jha4j5xy93xfhjasf-source",
        8:         "rev": "e402c3eb6d88384ca6c52ef1c53e61bdc9b84ddd",
        9:         "type": "path"
       10:       },
       11:       "original": {
       12:         "id": "nixpkgs",
       13:         "type": "indirect"
       14:       }
       15:     },
       16:     "root": {
       17:       "inputs": {
       18:         "nixpkgs": "nixpkgs"
       19:       }
       20:     }
       21:   },
       22:   "root": "root",
       23:   "version": 7
       24: }
Added regular file flake.nix:
        1: {
        2:   description = "Example JavaScript development environment for Zero to Nix";
        3: 
        4:   # Flake inputs
        5:   inputs = {
        6: 
        7:     # nixpkgs.url = "github:NixOS/nixpkgs/nixos-unstable";
        8:     nixpkgs.url = "nixpkgs"; # also valid: "nixpkgs"
        9: 
       10:     # roc={
       11:     #   url="github:roc-lang/roc";
       12:     # inputs.nixpkgs.follows="nixpkgs";
       13: 
       14:     # };
       15: 
       16:   };
       17:   # Flake outputs
       18:   outputs = { self, nixpkgs, ... }@inputs:
       19:     let
       20:       # Systems supported
       21:       allSystems = [
       22:         "x86_64-linux" # 64-bit Intel/AMD Linux
       23:       ];
       24: 
       25:       # Helper to provide system-specific attributes
       26:       forAllSystems = f:
       27:         nixpkgs.lib.genAttrs allSystems (system:
       28:           f {
       29:             pkgs = import nixpkgs { inherit system; };
       30: 
       31:           });
       32:     in {
       33:       # Development environment output
       34:       devShells = forAllSystems ({ pkgs }: {
       35:         default =
       36: 
       37:           pkgs.mkShell {
       38:             packages = with pkgs; [ pkgs.pkg-config gmp stdenv.cc.cc.lib ];
       39:             shellHook = let
       40:               libPath =
       41:                 pkgs.lib.makeLibraryPath [ pkgs.stdenv.cc.cc.lib pkgs.gmp ];
       42:             in ''
       43:               # yolo
       44:               export CFLAGS="$CFLAGS -I${pkgs.stdenv.cc.cc.lib}/include -I${pkgs.gmp}/include"
       45:               export LIBS="$LIBS -L${pkgs.stdenv.cc.cc.lib}/lib -L${pkgs.gmp}/lib"
       46:             '';
       47:           };
       48: 
       49:       });
       50: 
       51:     };
       52: }
Added regular file jj_tui.opam:
        1: # This file is generated by dune, edit dune-project instead
        2: opam-version: "2.0"
        3: synopsis: "A short synopsis"
        4: description: "A longer description"
        5: maintainer: ["Maintainer Name"]
        6: authors: ["Author Name"]
        7: license: "LICENSE"
        8: tags: ["topics" "to describe" "your" "project"]
        9: homepage: "https://github.com/username/reponame"
       10: doc: "https://url/to/documentation"
       11: bug-reports: "https://github.com/username/reponame/issues"
       12: depends: [
       13:   "ocaml"
       14:   "dune" {>= "3.9"}
       15:   "odoc" {with-doc}
       16: ]
       17: build: [
       18:   ["dune" "subst"] {dev}
       19:   [
       20:     "dune"
       21:     "build"
       22:     "-p"
       23:     name
       24:     "-j"
       25:     jobs
       26:     "@install"
       27:     "@runtest" {with-test}
       28:     "@doc" {with-doc}
       29:   ]
       30: ]
       31: dev-repo: "git+https://github.com/username/reponame.git"
Added regular file lib/ansiReverse.ml:
        1: open Notty
        2: 
        3: type op = Buffer.t -> unit
        4: 
        5: (* let ( & ) op1 op2 buf =
        6:      op1 buf;
        7:      op2 buf
        8: 
        9: 
       10:    let ( <| ), ( <. ), ( <! ) = Buffer.(add_string, add_char, add_decimal) *)
       11: let invalid_arg fmt = Format.kasprintf invalid_arg fmt
       12: 
       13: let rgb ~r ~g ~b =
       14:   if r < 0 || g < 0 || b < 0 || r > 5 || g > 5 || b > 5 then
       15:     invalid_arg "Notty.A.rgb %d %d %d: channel out of range" r g b
       16:   else 0x01000000 lor ((r * 36) + (g * 6) + b + 16)
       17: 
       18: let gray level =
       19:   if level < 0 || level > 23 then
       20:     invalid_arg "Notty.A.gray %d: level out of range" level
       21:   else 0x01000000 lor (level + 232)
       22: 
       23: let rgb_888 ~r ~g ~b =
       24:   if r < 0 || g < 0 || b < 0 || r > 255 || g > 255 || b > 255 then
       25:     invalid_arg "Notty.A.rgb_888 %d %d %d: channel out of range" r g b
       26:   else 0x02000000 lor ((r lsl 16) lor (g lsl 8) lor b)
       27: 
       28: let sts = [ ";1"; ";3"; ";4"; ";5"; ";7" ]
       29: 
       30: let attr_of_ints fg bg st =
       31:   A.fg @@ A.unsafe_color_of_int fg
       32:   |> A.( ++ ) (A.bg @@ A.unsafe_color_of_int bg)
       33:   |> A.( ++ ) (A.st @@ A.unsafe_style_of_int st)
       34: 
       35: let fg_int i = A.fg @@ A.unsafe_color_of_int i
       36: let bg_int i = A.bg @@ A.unsafe_color_of_int i
       37: 
       38: let print_image img =
       39:   print_endline "image:";
       40:   img |> Notty.Render.pp_image @@ Format.str_formatter;
       41:   print_endline (Format.flush_str_formatter () |> String.escaped)
       42: 
       43: let parse_ansi_escape_codes (input : string) : (A.t * string) list =
       44:   let len = String.length input in
       45:   let rec parse_codes acc i =
       46:     if i >= len then List.rev acc
       47:     else
       48:       let attr, j =
       49:         if i + 1 < len && input.[i] = '\027' && input.[i + 1] = '[' then (
       50:           let params = ref [] in
       51:           let j = ref (i + 2) in
       52:           while !j < len && input.[!j] <> 'm' do
       53:             let start = !j in
       54:             while !j < len && input.[!j] <> ';' && input.[!j] <> 'm' do
       55:               incr j
       56:             done;
       57:             let param = String.sub input start (!j - start) in
       58:             params := int_of_string param :: !params;
       59:             if !j < len && input.[!j] = ';' then incr j
       60:           done;
       61:           if !j < len && input.[!j] = 'm' then
       62:             let params = List.rev !params in
       63:             let attr =
       64:               match params with
       65:               | [] -> A.empty
       66:               | 0 :: _ -> A.empty
       67:               | 1 :: _ -> A.st A.bold
       68:               | 2 :: _ -> A.st A.italic
       69:               | 4 :: _ -> A.st A.underline
       70:               | 5 :: _ -> A.st A.blink
       71:               | 7 :: _ -> A.st A.reverse
       72:               | 30 :: _ -> A.fg A.black
       73:               | 31 :: _ -> A.fg A.red
       74:               | 32 :: _ -> A.fg A.green
       75:               | 33 :: _ -> A.fg A.yellow
       76:               | 34 :: _ -> A.fg A.blue
       77:               | 35 :: _ -> A.fg A.magenta
       78:               | 36 :: _ -> A.fg A.cyan
       79:               | 37 :: _ -> A.fg A.white
       80:               | 38 :: 5 :: color :: _ ->
       81:                   A.fg (A.unsafe_color_of_int (0x01000000 lor color))
       82:               | 40 :: _ -> A.bg A.black
       83:               | 41 :: _ -> A.bg A.red
       84:               | 42 :: _ -> A.bg A.green
       85:               | 43 :: _ -> A.bg A.yellow
       86:               | 44 :: _ -> A.bg A.blue
       87:               | 45 :: _ -> A.bg A.magenta
       88:               | 46 :: _ -> A.bg A.cyan
       89:               | 47 :: _ -> A.bg A.white
       90:               | 48 :: 5 :: color :: _ ->
       91:                   A.bg (A.unsafe_color_of_int (0x02000000 lor color))
       92:               | _ -> A.empty
       93:             in
       94:             (attr, !j + 1)
       95:           else (A.empty, i))
       96:         else (A.empty, i)
       97:       in
       98:       let k = ref j in
       99:       while !k < len && input.[!k] <> '\027' do
      100:         incr k
      101:       done;
      102:       let substring = String.sub input j (!k - j) in
      103:       parse_codes ((attr, substring) :: acc) !k
      104:   in
      105:   parse_codes [] 0
      106: 
      107: (** Like fold left except we run the first element through init to get the state*)
      108: let fold_left_pre (f : 'acc -> 'a -> 'acc) (init : 'a -> 'acc) (input : 'a list)
      109:     =
      110:   match input with
      111:   | [] -> invalid_arg "empty list"
      112:   | x :: xs ->
      113:       let state = init x in
      114:       xs |> List.fold_left f state
      115: 
      116: let string_to_image str =
      117:   let coded_strs = parse_ansi_escape_codes str in
      118:   let locate_newlines codes =
      119:     codes
      120:     |> List.concat_map (fun (attr, str) ->
      121:            str |> String.split_on_char '\n'
      122:            |> List.map (fun x -> `Image (I.string attr x))
      123:            |> Base.List.intersperse ~sep:`Newline)
      124:   in
      125:   let newline_seperated = locate_newlines coded_strs in
      126:   (* Printf.printf "len:%d" (List.length newline_seperated); *)
      127:   let lines =
      128:     let open I in
      129:     (* newline_seperated
      130:        |> List.iter (fun x -> match x with `Imarge i -> print_image i | _ -> ()); *)
      131:     newline_seperated
      132:     |> Base.List.fold ~init:([], I.empty) ~f:(fun (images, image) x ->
      133:            match x with
      134:            | `Newline -> (image :: images, I.empty)
      135:            | `Image nextImage -> (images, image <|> nextImage))
      136:     |> fst
      137:     (* |> List.map (fun x ->
      138:            x |> print_image;
      139:            x) *)
      140:     |> Base.List.reduce_exn ~f:(fun bottom top -> top <-> bottom)
      141:   in
      142:   let image =
      143:     lines
      144:     (* |> fold_left_pre
      145:          (fun image (attr, str) ->
      146:            let parts = str |> String.split_on_char '\n' in
      147:            let nextImage =
      148:              parts
      149:              |> fold_left_pre
      150:                   (fun image str -> I.( <-> ) image (I.string attr str))
      151:                   (I.string attr)
      152:            in
      153:            I.( <|> ) image nextImage)
      154:          (fun (attr, str) -> I.string attr str) *)
      155:   in
      156:   image
      157: 
      158: let escaped_string ?(attr = A.empty) str =
      159:   let control_character_index str i =
      160:     let len = String.length str in
      161:     let i = ref i in
      162:     while
      163:       let i = !i in
      164:       i < len && str.[i] >= ' '
      165:     do
      166:       incr i
      167:     done;
      168:     if !i = len then raise Not_found;
      169:     !i
      170:   in
      171:   let rec split str i =
      172:     match control_character_index str i with
      173:     | j ->
      174:         let img = I.string attr (String.sub str i (j - i)) in
      175:         img :: split str (j + 1)
      176:     | exception Not_found ->
      177:         [
      178:           I.string attr
      179:             (if i = 0 then str else String.sub str i (String.length str - i));
      180:         ]
      181:   in
      182:   I.vcat (split str 0)
      183: 
      184: (* let colored_string s =
      185:    s |> parse_ansi_escape_codes
      186:    |> List.map (fun (x, str) -> escaped_string ~attr:x str)
      187:    |> I.vcat *)
      188: let colored_string s = s |> string_to_image
      189: 
      190: let%expect_test "string_to_image" =
      191:   string_to_image
      192:     "\027[32mThis is in green %s\027[0m \027[30mThisisnotGreen\027[0m"
      193:   |> print_image;
      194:   [%expect.unreachable]
      195: [@@expect.uncaught_exn
      196:   {|
      197:   (* CR expect_test_collector: This test expectation appears to contain a backtrace.
      198:      This is strongly discouraged as backtraces are fragile.
      199:      Please change this test to not include a backtrace. *)
      200: 
      201:   (Invalid_argument List.reduce_exn)
      202:   Raised at Stdlib.invalid_arg in file "stdlib.ml", line 30, characters 20-45
      203:   Called from Jj_tui__AnsiReverse.(fun) in file "lib/ansiReverse.ml", line 197, characters 2-88
      204:   Called from Expect_test_collector.Make.Instance_io.exec in file "collector/expect_test_collector.ml", line 234, characters 12-19
      205: 
      206:   Trailing output
      207:   ---------------
      208:   params 32
      209:   params 0
      210:   params 30
      211:   params 0
      212:   len:4 |}]
      213: 
      214: let%expect_test "hello" =
      215:   let outBuf = Buffer.create 100 in
      216:   let _fmt = Format.formatter_of_buffer outBuf in
      217:   let res =
      218:     parse_ansi_escape_codes
      219:       "\027[32mThis is in green %s\027[0m \027[30mThisisnotGreen\027[0m"
      220:   in
      221:   res
      222:   |> List.iter (fun (x, str) ->
      223:          Notty.I.string x str |> Notty.Render.pp_image @@ Format.str_formatter);
      224:   print_endline (Format.flush_str_formatter () |> String.escaped);
      225:   print_endline (Buffer.contents outBuf);
      226:   [%expect
      227:     {|
      228:       params 32
      229:       params 0
      230:       params 30
      231:       params 0
      232:       \027[0m\027[K\027[0;32mThis is in green %s\027[0m\027[0m\027[K\027[0m \027[0m\027[0m\027[K\027[0;30mThisisnotGreen\027[0m\027[0m\027[K\027[0m|}]
      233: 
      234: let jjtest =
      235:   {|
      236:   @  [1m[38;5;13mm[38;5;8mtxzlotn[39m [38;5;3meli.jambu@gmail.com[39m [38;5;14m2024-05-08 12:19:37[39m [38;5;12mb[38;5;8mb87f772[39m[0m
      237:   │  [1m[38;5;3m(no description set)[39m[0m
      238: |}
      239: 
      240: let%expect_test "jj_test" =
      241:   jjtest |> string_to_image |> Notty.Render.pp_image @@ Format.str_formatter;
      242:   let res = Format.flush_str_formatter () in
      243:   print_endline "====== input=====";
      244:   print_endline (jjtest |> String.escaped);
      245:   print_endline "====== output escaped=====";
      246:   print_endline (res |> String.escaped);
      247:   print_endline "=====output====";
      248:   print_endline res;
      249:   [%expect
      250:     {|
      251:       params 1
      252:       params 38;5;13
      253:       nfg [0m<[0;95mATTR[0m[K[0m>[0m
      254:       params 38;5;8
      255:       nfg [0m<[0;90mATTR[0m[K[0m>[0m
      256:       params 39
      257:       params 38;5;3
      258:       nfg [0m<[0;33mATTR[0m[K[0m>[0m
      259:       params 39
      260:       params 38;5;14
      261:       nfg [0m<[0;96mATTR[0m[K[0m>[0m
      262:       params 39
      263:       params 38;5;12
      264:       nfg [0m<[0;94mATTR[0m[K[0m>[0m
      265:       params 38;5;8
      266:       nfg [0m<[0;90mATTR[0m[K[0m>[0m
      267:       params 39
      268:       params 0
      269:       params 1
      270:       params 38;5;3
      271:       nfg [0m<[0;33mATTR[0m[K[0m>[0m
      272:       params 39
      273:       params 0
      274:       len:23image:
      275:       \027[0m  \226\148\130  \027[0m\027[K\027[0;33m(no description set)\027[0m
      276:       image:
      277:       \027[0m  @  \027[0;95mm\027[0;90mtxzlotn\027[0m \027[0;33meli.jambu@gmail.com\027[0m \027[0;96m2024-05-08 12:19:37\027[0m \027[0;94mb\027[0m\027[K\027[0;90mb87f772\027[0m
      278:       image:
      279:       \027[0m\027[K\027[0m
      280:       ====== input=====
      281:       \n  @  \027[1m\027[38;5;13mm\027[38;5;8mtxzlotn\027[39m \027[38;5;3meli.jambu@gmail.com\027[39m \027[38;5;14m2024-05-08 12:19:37\027[39m \027[38;5;12mb\027[38;5;8mb87f772\027[39m\027[0m\n  \226\148\130  \027[1m\027[38;5;3m(no description set)\027[39m\027[0m\n
      282:       ====== output escaped=====
      283:       \027[0m\027[K\027[0m\n\027[0m  @  \027[0;95mm\027[0;90mtxzlotn\027[0m \027[0;33meli.jambu@gmail.com\027[0m \027[0;96m2024-05-08 12:19:37\027[0m \027[0;94mb\027[0m\027[K\027[0;90mb87f772\027[0m\n\027[0m  \226\148\130  \027[0;33m(no description set)\027[0m\027[K\027[0m                                     \027[0m
      284:       =====output====
      285:       [0m[K[0m
      286:       [0m  @  [0;95mm[0;90mtxzlotn[0m [0;33meli.jambu@gmail.com[0m [0;96m2024-05-08 12:19:37[0m [0;94mb[0m[K[0;90mb87f772[0m
      287:       [0m  │  [0;33m(no description set)[0m[K[0m                                     [0m|}]
      288: 
      289: (* let ansi =
      290:    {
      291:      skip =
      292:        (fun (b : Buffer.t) ->
      293:          let n = int_of_string (Buffer.contents b) in
      294:          Buffer.clear b;
      295:          n);
      296:      newline = (fun _ -> ());
      297:      altscr =
      298:        (fun b ->
      299:          Buffer.clear b;
      300:          String.equal (Buffer.contents b) "\x1b[?1049h");
      301:      cursat =
      302:        (fun b ->
      303:          let h = int_of_string (Buffer.contents b) in
      304:          Buffer.clear b;
      305:          Buffer.clear b;
      306:          (* skip ';' *)
      307:          let w = int_of_string (Buffer.contents b) in
      308:          Buffer.clear b;
      309:          (w - 1, h - 1));
      310:      cubcuf =
      311:        (fun b ->
      312:          let x = int_of_string (Buffer.contents b) in
      313:          Buffer.clear b;
      314:          if Buffer.nth b 0 = 'D' then -x else x);
      315:      cuucud =
      316:        (fun b ->
      317:          let y = int_of_string (Buffer.contents b) in
      318:          Buffer.clear b;
      319:          if Buffer.nth b 0 = 'A' then -y else y);
      320:      cr = (fun _ -> ());
      321:      clreol = (fun _ -> ());
      322:      cursvis =
      323:        (fun b ->
      324:          Buffer.clear b;
      325:          String.equal (Buffer.contents b) "\x1b[34h\x1b[?25h");
      326:      mouse =
      327:        (fun b ->
      328:          Buffer.clear b;
      329:          String.equal (Buffer.contents b) "\x1b[?1000;1002;1005;1015;1006h");
      330:      bpaste =
      331:        (fun b ->
      332:          Buffer.clear b;
      333:          String.equal (Buffer.contents b) "\x1b[?2004h");
      334:      sgr;
      335:    } *)
      336: (*
      337:      let no0 _ = ()
      338:      and no1 _ _ = ()
      339:      and no2 _ _ _ = ()
      340: 
      341:      let dumb =
      342:        {
      343:          skip = (fun b -> String.length (Buffer.contents b));
      344:          newline = (fun _ -> ());
      345:          altscr = no1;
      346:          cursat = (fun _ -> (0, 0));
      347:          cubcuf = (fun _ -> 0);
      348:          cuucud = (fun _ -> 0);
      349:          cr = no0;
      350:          clreol = no0;
      351:          cursvis = (fun _ -> false);
      352:          sgr = (fun _ -> A.empty);
      353:          mouse = (fun _ -> false);
      354:          bpaste = (fun _ -> false);
      355:        } *)
      356: (*
      357:      let erase cap buf = Buffer.clear buf (* KEEP ETA-LONG. *)
      358: 
      359:      let cursat0 cap b =
      360:        let w, h = cap.cursat b in
      361:        (max 0 (w - 1), max 0 (h - 1)) *)
Added regular file lib/dune:
        1: (library
        2:  (name jj_tui)
        3:  (inline_tests)
        4:  (libraries core stdio core_unix.command_unix notty nottui angstrom)
        5:  (preprocess
        6:   (pps ppx_expect)))
Added regular file lib/process.ml:
        1: 
        2: let mk_home_cmd cmd =
        3:   let home_dir = Unix.getenv "HOME" in
        4:   Printf.sprintf "HOME=%s %s" home_dir cmd
        5: 
        6: let proc_silent cmd =
        7:   let _exit_code = Unix.system (mk_home_cmd cmd) in
        8:   ()
        9: 
       10: let proc cmd =
       11:   Printf.eprintf "🐚  %s\n%!" cmd;
       12:   proc_silent cmd
       13: 
       14: let collect_chan (channel : in_channel) : string =
       15:   let rec loop acc =
       16:     match input_line channel with
       17:     | exception End_of_file -> acc
       18:     | line -> loop (acc ^ line ^ "\n")
       19:   in
       20:   loop ""
       21: 
       22: let proc_stdout cmd =
       23:   let ((proc_stdout, _proc_stdin, _proc_stderr) as process) =
       24:     Unix.open_process_full (mk_home_cmd cmd) [||]
       25:   in
       26:   let stdout_result = collect_chan proc_stdout in
       27:   let _ = Unix.close_process_full process in
       28:   String.trim stdout_result
       29: 
       30: let proc_stdOutAndErr cmd =
       31:   let ((proc_stdout, _proc_stdin, proc_stderr) as process) =
       32:     Unix.open_process_full (mk_home_cmd cmd) [||]
       33:   in
       34:   let stdout_result = collect_chan proc_stdout in
       35:   let stderr_result = collect_chan proc_stderr in
       36:   let _ = Unix.close_process_full process in
       37:   String.trim (stdout_result^stderr_result)
Added regular file log:
        1: ◉  [1m[38;5;5mv[0m[38;5;8myzuqwnl[39m [38;5;3meli.jambu@gmail.com[39m [38;5;6m2024-05-08 23:57:08[39m [1m[38;5;4m7[0m[38;5;8maf062fc[39m
        2: │  [38;5;3m(no description set)[39m
        3: ◉  [1m[38;5;5mxn[0m[38;5;8mvoukwm[39m [38;5;3meli.jambu@gmail.com[39m [38;5;6m2024-05-08 23:57:08[39m [1m[38;5;4m9[0m[38;5;8m50e51d4[39m
        4: │  using angstrom parser
        5: ◉  [1m[38;5;5mu[0m[38;5;8mwwzzulo[39m [38;5;3meli.jambu@gmail.com[39m [38;5;6m2024-05-08 23:57:08[39m [1m[38;5;4m4a[0m[38;5;8md3ac96[39m
        6: │  progress on ui, added boxes
        7: @  [1m[38;5;13mkszk[38;5;8muqqs[39m [38;5;3meli.jambu@gmail.com[39m [38;5;14m2024-05-08 23:57:08[39m [38;5;12mf[38;5;8mc74c4ed[39m[0m
        8: │  [1mcoloured output is working[0m
        9: ◉  [1m[38;5;5my[0m[38;5;8msrpqsvq[39m [38;5;3meli.jambu@gmail.com[39m [38;5;6m2024-05-08 01:18:11[39m [38;5;2mHEAD@git[39m [1m[38;5;4me[0m[38;5;8mc72cc90[39m
       10: │  [38;5;3m(no description set)[39m
       11: ◉  [1m[38;5;5mn[0m[38;5;8mulnswsm[39m [38;5;3meli.jambu@gmail.com[39m [38;5;6m2024-05-08 01:17:05[39m [1m[38;5;4mb[0m[38;5;8mfaef69b[39m
       12: │  [38;5;3m(no description set)[39m
       13: ◉  [1m[38;5;5mxw[0m[38;5;8msmkxpt[39m [38;5;3meli.jambu@gmail.com[39m [38;5;6m2024-05-08 01:08:13[39m [1m[38;5;4m2[0m[38;5;8m12a26e4[39m
       14: │  [38;5;3m(no description set)[39m
       15: ◉  [1m[38;5;5mkszy[0m[38;5;8mtrtu[39m [38;5;3meli.jambu@gmail.com[39m [38;5;6m2024-05-08 01:08:13[39m [1m[38;5;4m8[0m[38;5;8m754ef74[39m
       16: │  [38;5;3m(no description set)[39m
       17: ◉  [1m[38;5;5mp[0m[38;5;8msnrvlsv[39m [38;5;3meli.jambu@gmail.com[39m [38;5;6m2024-05-08 01:02:28[39m [1m[38;5;4md[0m[38;5;8m09f7fd4[39m
       18: │  [38;5;3m(no description set)[39m
       19: │ ◉  [1m[38;5;5mt[0m[38;5;8mooppyyl[39m [38;5;3meli.jambu@gmail.com[39m [38;5;6m2024-05-08 01:19:58[39m [1m[38;5;4m49[0m[38;5;8m125832[39m
       20: ├─╯  [38;5;3m(no description set)[39m
       21: ◉  [1m[38;5;5mz[0m[38;5;8mzzzzzzz[39m [38;5;2mroot()[39m [1m[38;5;4m0[0m[38;5;8m0000000[39m
Added regular file log2:
    (empty)
Added regular file test/dune:
        1: (test
        2:  (name jj_tui)
        3:  (libraries jj_tui)
        4:  (preprocess
        5:   (pps ppx_jane ppx_expect)))
Added regular file test/jj_tui.ml:
    (empty)
Added regular file testing/hi:
        1: hiiiiiii
        2: hiiiiiiiiiiii
        3: hiiiiiiiiiiii
Added regular file testing/other/file:
        1: hello Im other
Removed regular file ../jj_tui.install:
   1     : lib: [
   2     :   "_build/install/default/lib/jj_tui/META"
   3     :   "_build/install/default/lib/jj_tui/dune-package"
   4     :   "_build/install/default/lib/jj_tui/opam"
   5     : ]
   6     : bin: [
   7     :   "_build/install/default/bin/jj_tui"
   8     : ]
Removed regular file ../jj_tui.opam:
   1     : # This file is generated by dune, edit dune-project instead
   2     : opam-version: "2.0"
   3     : synopsis: "A short synopsis"
   4     : description: "A longer description"
   5     : maintainer: ["Maintainer Name"]
   6     : authors: ["Author Name"]
   7     : license: "LICENSE"
   8     : tags: ["topics" "to describe" "your" "project"]
   9     : homepage: "https://github.com/username/reponame"
  10     : doc: "https://url/to/documentation"
  11     : bug-reports: "https://github.com/username/reponame/issues"
  12     : depends: [
  13     :   "ocaml"
  14     :   "dune" {>= "3.9"}
  15     :   "odoc" {with-doc}
  16     : ]
  17     : build: [
  18     :   ["dune" "subst"] {dev}
  19     :   [
  20     :     "dune"
  21     :     "build"
  22     :     "-p"
  23     :     name
  24     :     "-j"
  25     :     jobs
  26     :     "@install"
  27     :     "@runtest" {with-test}
  28     :     "@doc" {with-doc}
  29     :   ]
  30     : ]
  31     : dev-repo: "git+https://github.com/username/reponame.git"
Removed regular file ../lib/dune:
   1     : (library
   2     :  (name jj_tui)
   3     :  (libraries core stdio core_unix.command_unix )
   4     :  )
   5     : 
Removed regular file ../lib/process.ml:
   1     : 
   2     : let mk_home_cmd cmd =
   3     :   let home_dir = Unix.getenv "HOME" in
   4     :   Printf.sprintf "HOME=%s %s" home_dir cmd
   5     : 
   6     : let proc_silent cmd =
   7     :   let _exit_code = Unix.system (mk_home_cmd cmd) in
   8     :   ()
   9     : 
  10     : let proc cmd =
  11     :   Printf.eprintf "🐚  %s\n%!" cmd;
  12     :   proc_silent cmd
  13     : 
  14     : let collect_chan (channel : in_channel) : string =
  15     :   let rec loop acc =
  16     :     match input_line channel with
  17     :     | exception End_of_file -> acc
  18     :     | line -> loop (acc ^ line ^ "\n")
  19     :   in
  20     :   loop ""
  21     : 
  22     : let proc_stdout cmd =
  23     :   let ((proc_stdout, _proc_stdin, _proc_stderr) as process) =
  24     :     Unix.open_process_full (mk_home_cmd cmd) [||]
  25     :   in
  26     :   let stdout_result = collect_chan proc_stdout in
  27     :   let _ = Unix.close_process_full process in
  28     :   String.trim stdout_result
  29     : 
  30     : let proc_stdOutAndErr cmd =
  31     :   let ((proc_stdout, _proc_stdin, proc_stderr) as process) =
  32     :     Unix.open_process_full (mk_home_cmd cmd) [||]
  33     :   in
  34     :   let stdout_result = collect_chan proc_stdout in
  35     :   let stderr_result = collect_chan proc_stderr in
  36     :   let _ = Unix.close_process_full process in
  37     :   String.trim (stdout_result^stderr_result)
Removed regular file ../minttea/leaves.install:
   1     : lib: [
   2     :   "_build/install/default/lib/leaves/META"
   3     :   "_build/install/default/lib/leaves/cursor.ml"
   4     :   "_build/install/default/lib/leaves/cursor.mli"
   5     :   "_build/install/default/lib/leaves/dune-package"
   6     :   "_build/install/default/lib/leaves/filtered_list.ml"
   7     :   "_build/install/default/lib/leaves/filtered_list.mli"
   8     :   "_build/install/default/lib/leaves/forms.ml"
   9     :   "_build/install/default/lib/leaves/fps.ml"
  10     :   "_build/install/default/lib/leaves/fps.mli"
  11     :   "_build/install/default/lib/leaves/leaves.a"
  12     :   "_build/install/default/lib/leaves/leaves.cma"
  13     :   "_build/install/default/lib/leaves/leaves.cmi"
  14     :   "_build/install/default/lib/leaves/leaves.cmt"
  15     :   "_build/install/default/lib/leaves/leaves.cmx"
  16     :   "_build/install/default/lib/leaves/leaves.cmxa"
  17     :   "_build/install/default/lib/leaves/leaves.ml"
  18     :   "_build/install/default/lib/leaves/leaves__Cursor.cmi"
  19     :   "_build/install/default/lib/leaves/leaves__Cursor.cmt"
  20     :   "_build/install/default/lib/leaves/leaves__Cursor.cmti"
  21     :   "_build/install/default/lib/leaves/leaves__Cursor.cmx"
  22     :   "_build/install/default/lib/leaves/leaves__Filtered_list.cmi"
  23     :   "_build/install/default/lib/leaves/leaves__Filtered_list.cmt"
  24     :   "_build/install/default/lib/leaves/leaves__Filtered_list.cmti"
  25     :   "_build/install/default/lib/leaves/leaves__Filtered_list.cmx"
  26     :   "_build/install/default/lib/leaves/leaves__Forms.cmi"
  27     :   "_build/install/default/lib/leaves/leaves__Forms.cmt"
  28     :   "_build/install/default/lib/leaves/leaves__Forms.cmx"
  29     :   "_build/install/default/lib/leaves/leaves__Fps.cmi"
  30     :   "_build/install/default/lib/leaves/leaves__Fps.cmt"
  31     :   "_build/install/default/lib/leaves/leaves__Fps.cmti"
  32     :   "_build/install/default/lib/leaves/leaves__Fps.cmx"
  33     :   "_build/install/default/lib/leaves/leaves__Paginator.cmi"
  34     :   "_build/install/default/lib/leaves/leaves__Paginator.cmt"
  35     :   "_build/install/default/lib/leaves/leaves__Paginator.cmti"
  36     :   "_build/install/default/lib/leaves/leaves__Paginator.cmx"
  37     :   "_build/install/default/lib/leaves/leaves__Progress.cmi"
  38     :   "_build/install/default/lib/leaves/leaves__Progress.cmt"
  39     :   "_build/install/default/lib/leaves/leaves__Progress.cmti"
  40     :   "_build/install/default/lib/leaves/leaves__Progress.cmx"
  41     :   "_build/install/default/lib/leaves/leaves__Spinner.cmi"
  42     :   "_build/install/default/lib/leaves/leaves__Spinner.cmt"
  43     :   "_build/install/default/lib/leaves/leaves__Spinner.cmti"
  44     :   "_build/install/default/lib/leaves/leaves__Spinner.cmx"
  45     :   "_build/install/default/lib/leaves/leaves__Sprite.cmi"
  46     :   "_build/install/default/lib/leaves/leaves__Sprite.cmt"
  47     :   "_build/install/default/lib/leaves/leaves__Sprite.cmti"
  48     :   "_build/install/default/lib/leaves/leaves__Sprite.cmx"
  49     :   "_build/install/default/lib/leaves/leaves__Table.cmi"
  50     :   "_build/install/default/lib/leaves/leaves__Table.cmt"
  51     :   "_build/install/default/lib/leaves/leaves__Table.cmx"
  52     :   "_build/install/default/lib/leaves/leaves__Text_input.cmi"
  53     :   "_build/install/default/lib/leaves/leaves__Text_input.cmt"
  54     :   "_build/install/default/lib/leaves/leaves__Text_input.cmti"
  55     :   "_build/install/default/lib/leaves/leaves__Text_input.cmx"
  56     :   "_build/install/default/lib/leaves/opam"
  57     :   "_build/install/default/lib/leaves/paginator.ml"
  58     :   "_build/install/default/lib/leaves/paginator.mli"
  59     :   "_build/install/default/lib/leaves/progress.ml"
  60     :   "_build/install/default/lib/leaves/progress.mli"
  61     :   "_build/install/default/lib/leaves/spinner.ml"
  62     :   "_build/install/default/lib/leaves/spinner.mli"
  63     :   "_build/install/default/lib/leaves/sprite.ml"
  64     :   "_build/install/default/lib/leaves/sprite.mli"
  65     :   "_build/install/default/lib/leaves/table.ml"
  66     :   "_build/install/default/lib/leaves/text_input.ml"
  67     :   "_build/install/default/lib/leaves/text_input.mli"
  68     : ]
  69     : libexec: [
  70     :   "_build/install/default/lib/leaves/leaves.cmxs"
  71     : ]
  72     : doc: [
  73     :   "_build/install/default/doc/leaves/CHANGES.md"
  74     :   "_build/install/default/doc/leaves/LICENSE.md"
  75     :   "_build/install/default/doc/leaves/README.md"
  76     : ]
Removed regular file ../minttea/minttea.install:
   1     : lib: [
   2     :   "_build/install/default/lib/minttea/META"
   3     :   "_build/install/default/lib/minttea/app.ml"
   4     :   "_build/install/default/lib/minttea/command.ml"
   5     :   "_build/install/default/lib/minttea/dune-package"
   6     :   "_build/install/default/lib/minttea/event.ml"
   7     :   "_build/install/default/lib/minttea/io_loop.ml"
   8     :   "_build/install/default/lib/minttea/minttea.a"
   9     :   "_build/install/default/lib/minttea/minttea.cma"
  10     :   "_build/install/default/lib/minttea/minttea.cmi"
  11     :   "_build/install/default/lib/minttea/minttea.cmt"
  12     :   "_build/install/default/lib/minttea/minttea.cmti"
  13     :   "_build/install/default/lib/minttea/minttea.cmx"
  14     :   "_build/install/default/lib/minttea/minttea.cmxa"
  15     :   "_build/install/default/lib/minttea/minttea.ml"
  16     :   "_build/install/default/lib/minttea/minttea.mli"
  17     :   "_build/install/default/lib/minttea/minttea__.cmi"
  18     :   "_build/install/default/lib/minttea/minttea__.cmt"
  19     :   "_build/install/default/lib/minttea/minttea__.cmx"
  20     :   "_build/install/default/lib/minttea/minttea__.ml"
  21     :   "_build/install/default/lib/minttea/minttea__App.cmi"
  22     :   "_build/install/default/lib/minttea/minttea__App.cmt"
  23     :   "_build/install/default/lib/minttea/minttea__App.cmx"
  24     :   "_build/install/default/lib/minttea/minttea__Command.cmi"
  25     :   "_build/install/default/lib/minttea/minttea__Command.cmt"
  26     :   "_build/install/default/lib/minttea/minttea__Command.cmx"
  27     :   "_build/install/default/lib/minttea/minttea__Event.cmi"
  28     :   "_build/install/default/lib/minttea/minttea__Event.cmt"
  29     :   "_build/install/default/lib/minttea/minttea__Event.cmx"
  30     :   "_build/install/default/lib/minttea/minttea__Io_loop.cmi"
  31     :   "_build/install/default/lib/minttea/minttea__Io_loop.cmt"
  32     :   "_build/install/default/lib/minttea/minttea__Io_loop.cmx"
  33     :   "_build/install/default/lib/minttea/minttea__Program.cmi"
  34     :   "_build/install/default/lib/minttea/minttea__Program.cmt"
  35     :   "_build/install/default/lib/minttea/minttea__Program.cmx"
  36     :   "_build/install/default/lib/minttea/minttea__Renderer.cmi"
  37     :   "_build/install/default/lib/minttea/minttea__Renderer.cmt"
  38     :   "_build/install/default/lib/minttea/minttea__Renderer.cmti"
  39     :   "_build/install/default/lib/minttea/minttea__Renderer.cmx"
  40     :   "_build/install/default/lib/minttea/opam"
  41     :   "_build/install/default/lib/minttea/program.ml"
  42     :   "_build/install/default/lib/minttea/renderer.ml"
  43     :   "_build/install/default/lib/minttea/renderer.mli"
  44     : ]
  45     : libexec: [
  46     :   "_build/install/default/lib/minttea/minttea.cmxs"
  47     : ]
  48     : doc: [
  49     :   "_build/install/default/doc/minttea/CHANGES.md"
  50     :   "_build/install/default/doc/minttea/LICENSE.md"
  51     :   "_build/install/default/doc/minttea/README.md"
  52     : ]
Removed regular file ../minttea/spices.install:
   1     : lib: [
   2     :   "_build/install/default/lib/spices/META"
   3     :   "_build/install/default/lib/spices/border.ml"
   4     :   "_build/install/default/lib/spices/dune-package"
   5     :   "_build/install/default/lib/spices/formatter.ml"
   6     :   "_build/install/default/lib/spices/gradient.ml"
   7     :   "_build/install/default/lib/spices/opam"
   8     :   "_build/install/default/lib/spices/spices.a"
   9     :   "_build/install/default/lib/spices/spices.cma"
  10     :   "_build/install/default/lib/spices/spices.cmi"
  11     :   "_build/install/default/lib/spices/spices.cmt"
  12     :   "_build/install/default/lib/spices/spices.cmti"
  13     :   "_build/install/default/lib/spices/spices.cmx"
  14     :   "_build/install/default/lib/spices/spices.cmxa"
  15     :   "_build/install/default/lib/spices/spices.ml"
  16     :   "_build/install/default/lib/spices/spices.mli"
  17     :   "_build/install/default/lib/spices/spices__.cmi"
  18     :   "_build/install/default/lib/spices/spices__.cmt"
  19     :   "_build/install/default/lib/spices/spices__.cmx"
  20     :   "_build/install/default/lib/spices/spices__.ml"
  21     :   "_build/install/default/lib/spices/spices__Border.cmi"
  22     :   "_build/install/default/lib/spices/spices__Border.cmt"
  23     :   "_build/install/default/lib/spices/spices__Border.cmx"
  24     :   "_build/install/default/lib/spices/spices__Formatter.cmi"
  25     :   "_build/install/default/lib/spices/spices__Formatter.cmt"
  26     :   "_build/install/default/lib/spices/spices__Formatter.cmx"
  27     :   "_build/install/default/lib/spices/spices__Gradient.cmi"
  28     :   "_build/install/default/lib/spices/spices__Gradient.cmt"
  29     :   "_build/install/default/lib/spices/spices__Gradient.cmx"
  30     : ]
  31     : libexec: [
  32     :   "_build/install/default/lib/spices/spices.cmxs"
  33     : ]
  34     : doc: [
  35     :   "_build/install/default/doc/spices/CHANGES.md"
  36     :   "_build/install/default/doc/spices/LICENSE.md"
  37     :   "_build/install/default/doc/spices/README.md"
  38     : ]
Added regular file ../notty/.gitignore:
        1: _build
        2: *.install
        3: *.native
        4: *.byte
        5: .merlin
        6: 
        7: tmp
        8: *~
        9: \.\#*
       10: \#*#
       11: 
       12: *.json
       13: gmon.out
       14: rondom
Added regular file ../notty/.ocamlinit:
        1: #require "uucp,uuseg,uutf"
        2: 
        3: #directory "_build/default/src"
        4: #directory "_build/default/src/.notty.objs/byte"
        5: #directory "_build/default/src-unix"
        6: #directory "_build/default/src-unix/.notty_unix.objs/byte"
        7: #directory "_build/default/src-lwt"
        8: #directory "_build/default/src-lwt/.notty_lwt.objs/byte"
        9: 
       10: #load "notty.cma"
       11: #load "notty_unix.cma"
       12: #load "notty_lwt.cma"
       13: 
       14: #use "src/notty_top_init.ml"
Added regular file ../notty/CHANGES.md:
        1: ## v0.2.3 (2022-09-02)
        2: 
        3: * Moved to Dune.
        4: * Renders faster, uses less memory.
        5: * Nested uses of `I.pp_attr` within `I.strf` now stack, instead of replacing.
        6: * Removed dependency on Uucp. Uses internal data instead (Unicode 13).
        7: * Support OCaml 4.08 - 4.14. Thanks to @kit-ty-kate for the 4.14 fixes.
        8: 
        9: ## v0.2.2 (2019-02-19)
       10: 
       11: * Fix a long-standing terminal cleanup bug. Reported by @ttamttam, fix by @cfcs.
       12: 
       13: ## v0.2.1 (2017-11-06)
       14: 
       15: * OCaml 4.06 compatible.
       16: * Cache the internal representation of Unicode strings.
       17: * Remove `I.ichar`. **breaking**
       18: 
       19: ## v0.2.0 (2017-10-31)
       20: 
       21: * All-around speed and memory improvements.
       22: * Draw over lines cell-by-cell instead of using erase-and-skip.
       23:   Slower, but flicker-free drawing.
       24: * `Term.create`: optionally inhibit synthetic TTY signals.
       25: * Cursor origin moved from `(1, 1)` to `(0, 0)`. **breaking**
       26: * `#key` renamed to `#special`. **breaking**
       27: * Added `Term.fds` to get connected file descriptors.
       28: * Added `A.equal` and `I.equal`.
       29: * Switched over to `Uchar.t`. **breaking**
       30: * Separated ASCII from the rest of Unicode input. **breaking**
       31: * Added image pretty-printer `I.pp`.
       32: * Added `notty.top` for use in the toplevel.
       33: * Removed `I.tile`. **breaking**
       34: * Added `I.tabulate`, generalizing `I.tile`.
       35: * Added support for 24-bit color.
       36: * Added `Notty_*.show_cursor` and `Notty_*.move_cursor` for manual cursor
       37:   positioning in inline mode.
       38: * Removed `output_image_endline`. Can be replaced by `eol`. **breaking**
       39: * `Notty_*.output_image` lost the `~clear` parameter. Can be replaced in various
       40:   ways by cursor positioning.
       41: * `Notty_unix.output_image ~chan` renamed to `~fd`. **breaking**
       42: * Added support for bracketed paste.
       43: * More example programs.
       44: 
       45: ## v0.1.1 (2016-02-09)
       46: * `Term.input` -> `Term.event`
       47: * Option to redraw the line
       48: 
       49: ## v0.1.0 (2016-02-09)
       50: * Initial release
Added regular file ../notty/LICENSE.md:
        1: Copyright (c) 2016-2017 David Kaloper Meršinjak
        2: 
        3: Permission to use, copy, modify, and/or distribute this software for any
        4: purpose with or without fee is hereby granted, provided that the above
        5: copyright notice and this permission notice appear in all copies.
        6: 
        7: THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
        8: WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
        9: MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
       10: ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
       11: WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
       12: ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
       13: OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
Added regular file ../notty/README.md:
        1: # Notty — Declaring terminals
        2: 
        3: <a href="https://asciinema.org/a/ZIXzn2ZmIxK39qoT3eJla5OyO" alt="dumper"><img src="https://asciinema.org/a/ZIXzn2ZmIxK39qoT3eJla5OyO.png" width="400"/></a>
        4: <a href="https://asciinema.org/a/TsIhDJv5S00AB2biVmhHRzZ8I" alt="input"><img src="https://asciinema.org/a/TsIhDJv5S00AB2biVmhHRzZ8I.png" width="400"/></a>
        5: <a href="https://asciinema.org/a/z1Pc0Mppg2JFzteZzdeigLwYc" alt="microdots"><img src="https://asciinema.org/a/z1Pc0Mppg2JFzteZzdeigLwYc.png" width="400"/></a>
        6: <a href="https://asciinema.org/a/NgpF9Im8qfUICC39GDDAe9Ede" alt="rain"><img src="https://asciinema.org/a/R94gnHTQhCFJAsWpRfVlZWcUB.png" width="400"/></a>
        7: 
        8: Notty is a declarative terminal library for OCaml structured around a notion
        9: of composable images. It tries to abstract away the basic terminal programming
       10: model, providing something simpler and more expressive.
       11: 
       12: The core layout engine and IO codecs are pure platform-independent OCaml.
       13: Distribution includes modules with input and output facilities for Unix, and Lwt
       14: on Unix.
       15: 
       16: As an attempt to redefine terminal programming, Notty has to be
       17: _opinionated_. It assumes Unicode throughout, does not have universal support
       18: for various terminals out there, and has a peculiar programming and rendering
       19: model.
       20: 
       21: Notty's core API was heavily influenced by Haskell's [Vty][vty].
       22: 
       23: ## Where to start
       24: 
       25: Check out the [documentation], [examples], or peek directly into the [interface]
       26: file.
       27: 
       28: Building with `dune build @ex` will produce several little example programs that
       29: also double as tests.
       30: 
       31: ```OCaml
       32: (* Game of Life with ZX Spectrum kitsch. *)
       33: 
       34: let dot : image = I.uchar A.(fg lightred) (Uchar.of_int 0x25cf) 1 1
       35: 
       36: let background step (n, m) =
       37:   let k = 24. *. sin (float (step + m + n) /. 10.) |> truncate in
       38:   if k > 0 then I.char A.(fg (gray k)) '.' 1 1 else I.void 1 1
       39: 
       40: let render (w, h) step life : image =
       41:   I.tabulate w (h - 1) @@ fun x y ->
       42:     let pt = (x, y) in
       43:     if CSet.mem pt life then dot else background step pt
       44: ```
       45: 
       46: [documentation]: https://pqwy.github.io/notty/doc
       47: [examples]: http://pqwy.github.io/notty/doc/Notty.html#examples
       48: [interface]: https://github.com/pqwy/notty/blob/master/src/notty.mli
       49: [vty]: https://hackage.haskell.org/package/vty
       50: 
       51: ## What?
       52: 
       53: - _Notty?_
       54:   
       55:   Terminals are tedious to program for. Notty tries to abstract the tedium away,
       56:   leaving you with a more pleasant programming surface that's quite unlike a TTY.
       57:   Hence, _No-TTY_.
       58: 
       59: - A new kind of Rust terminal?
       60: 
       61:   This Notty has no connection to any other body of code named Notty.
       62: 
       63: - Why make yet another terminal output library?
       64:   
       65:   Because:
       66:   * It allows one to *describe* what should be seen, as opposed to *commanding*
       67:     a terminal.
       68:   * It's pretty compact. Both bells and whistles can be implemented separately.
       69:   * Core is easy to glue onto various IO backends.
       70:   * Pure platform-independent OCaml.
Added regular file ../notty/benchmarks/dune:
        1: (executable
        2:   (name speed)
        3:   (libraries notty notty.unix common unmark unmark.cli))
Added regular file ../notty/benchmarks/speed.ml:
        1: (* Copyright (c) 2016-2019 David Kaloper Meršinjak. All rights reserved.
        2:    See LICENSE.md. *)
        3: 
        4: open Notty
        5: open Common
        6: open Common.Images
        7: 
        8: 
        9: let decode ?(n=1) str =
       10:   let f cs _ = function `Uchar c -> c::cs | _ -> cs in
       11:   let us = str |> Uutf.String.fold_utf_8 f [] |> List.rev in
       12:   for _ = 1 to n do Unescape.decode us |> ignore done
       13: 
       14: let input ?(n=1) str =
       15:   let buf = Bytes.unsafe_of_string str in
       16:   let rec go f n = match Unescape.next f with
       17:     | #Unescape.event -> go f n
       18:     | `Await when n > 0 ->
       19:         Unescape.input f buf 0 (Bytes.length buf); go f (pred n)
       20:     | `Await -> ()
       21:     | `End   -> assert false in
       22:   go (Unescape.create ()) n
       23: 
       24: let escapes =
       25:   "\027[5~\027[6~\027[1~\027[4~\027OP\027OQ\027OR\027OS\027[15~\027[17~" ^
       26:   "\027[18~\027[19~\027[20~\027[21~\027[23~\027[24~"
       27: 
       28: let escapes_m =
       29:   "\027[<0;59;7M\027[<32;58;7M\027[<32;57;7M\027[<32;56;7M\027[<32;54;7M" ^
       30:   "\027[<32;53;8M\027[<32;52;8M\027[<32;51;8M\027[<32;50;8M\027[<32;49;8M" ^
       31:   "\027[<32;47;9M\027[<32;46;9M\027[<32;44;9M\027[<32;42;10M\027[<32;41;10M" ^
       32:   "\027[<32;41;11M\027[<32;40;11M\027[<32;41;12M\027[<32;42;12M" ^
       33:   "\027[<32;42;13M\027[<32;43;13M\027[<32;44;13M\027[<0;44;13m"
       34: 
       35: let chars = String.(make (length escapes) 'x')
       36: 
       37: let buf = Buffer.create 1024
       38: let buf_render off dim image =
       39:   Buffer.clear buf; Render.to_buffer buf Cap.ansi off dim image
       40: 
       41: 
       42: open Unmark
       43: 
       44: let strf = Format.asprintf
       45: let group_of name xs f = group name (List.map f xs)
       46: let bench_fmt fmt = Format.kasprintf bench fmt
       47: let group_fmt fmt = Format.kasprintf group fmt
       48: 
       49: let render =
       50: 
       51:   let clip i = I.(width i |> min 200, height i |> min 200) in
       52:   let ops i = Operation.of_image (0, 0) (clip i) i
       53:   and render i = buf_render (0, 0) (clip i) i in
       54: 
       55:   group "render" [
       56:     group "rasterize" [
       57:       bench "i2" (fun () -> ops i2)
       58:     ; bench "i3" (fun () -> ops i3)
       59:     ; bench "i4" (fun () -> ops i4)
       60:     ; bench "i5" (fun () -> ops i5)
       61:     ];
       62:     group "render" [
       63:       bench "i2" (fun () -> render i2)
       64:     ; bench "i3" (fun () -> render i3)
       65:     ; bench "i4" (fun () -> render i4)
       66:     ; bench "i5" (fun () -> render i5)
       67:     ];
       68:     group_f "draw" (fun t -> [
       69:       bench "i3" (fun () -> Term.image t i3)
       70:     ; bench "i5" (fun () -> Term.image t i5)
       71:     ]) ~init:Term.create ~fini:Term.release
       72: ]
       73: 
       74: let input = group "input" [
       75:   group "decode" [
       76:     bench "escapes"     (fun () -> decode ~n:100 escapes);
       77:     bench "CSI escapes" (fun () -> decode ~n:100 escapes_m);
       78:     bench "chars"       (fun () -> decode ~n:100 chars);
       79:   ];
       80:   group "input" [
       81:     bench "escapes"     (fun () -> input ~n:100 escapes);
       82:     bench "CSI escapes" (fun () -> input ~n:100 escapes_m);
       83:     bench "chars"       (fun () -> input ~n:100 chars);
       84:   ]
       85: ]
       86: 
       87: let construct =
       88: 
       89:   let strings = [
       90:       "s1", "a"
       91:     ; "s2", "abcdefghij"
       92:     ; "s3", String.repeat 10 "abcdefghij"
       93:     ; "s4", String.repeat 100 "abcdefghij"
       94:     ; "u1", "☭"
       95:     ; "u2", String.repeat 10 "☭"
       96:     ; "u3", String.repeat 100 "☭"
       97:     ; "u4", String.repeat 1000 "☭" ] in
       98: 
       99:   group "construct" [
      100: 
      101:     group "make" (strings |> List.map @@ fun (n, s) ->
      102:       bench n (fun () -> I.string A.empty s))
      103: 
      104:   ; group "repeat" ([0x40; 0x262d] |> List.map @@ fun x ->
      105:       let u = Uchar.of_int x in
      106:       group_fmt "U+%04x" x ([1; 10; 100] |> List.map @@ fun n ->
      107:         bench_fmt "%dx" n (fun () -> I.uchar A.empty u n 1)))
      108: 
      109:   ; bench "pxmatrix" (fun () -> pxmatrix 200 200 @@ fun _ _ -> A.black)
      110:   ]
      111: 
      112: 
      113: let _ = Unmark_cli.main "Notty" [ render; input; construct ]
Added regular file ../notty/dune-project:
        1: (lang dune 1.7)
        2: (name notty)
        3: (version %%VERSION_NUM%%)
Added regular file ../notty/examples/almondbread.ml:
        1: open Notty
        2: open Common
        3: 
        4: let iter = 200
        5: 
        6: let member x y =
        7:   let rec go cx cy x y n =
        8:     let xx = x *. x and yy = y *. y in
        9:     if n = 0 || xx +. yy > 4. then n else
       10:       go cx cy (xx -. yy +. cx) (2. *. x *. y +. cy) (n - 1) in
       11:   float (iter - go x y 0. 0. iter) /. float iter
       12: 
       13: let pi2   = 2. *. 3.14159
       14: let pi2_3 = pi2 /. 3.
       15: 
       16: let mandelbrot x y =
       17:   (* let esc = 1. -. member x y in *)
       18:   (* 23. *. esc *. esc |> truncate |> A.gray *)
       19:   match member x y with
       20:   | 1.  -> A.gray 0
       21:   | esc ->
       22:       let t = esc *. pi2 in
       23:       let f d = (sin (t +. d) *. 128. +. 128.) |> truncate in
       24:       A.rgb_888 ~b:(f (-.pi2_3)) ~g:(f 0.) ~r:(f pi2_3)
       25: 
       26: let xlate dx dy f x y = f (x -. dx) (y -. dy)
       27: let scale k f = let k1 = 1./.k in fun x y -> f (x *. k1) (y *. k1)
       28: let rot a f =
       29:   let sina = sin a and cosa = cos a in fun x y ->
       30:     f (x *. cosa -. y *. sina) (x *. sina +. cosa *. y)
       31: 
       32: let render_unit f (w, h) =
       33:   let sw = 1. /. float w
       34:   and sh = 1. /. float (2 * h) in
       35:   pxmatrix w h (fun x y -> f (float x *. sw) (float y *. sh))
       36: 
       37: let () =
       38:   let pix =
       39:     render_unit @@
       40:     rot (-1.570795) @@ xlate (1.6) (-0.5) @@
       41:     mandelbrot in
       42:   Notty_unix.(output_image_size @@ fun (w, h) -> pix (w, h - 1) |> eol)
Added regular file ../notty/examples/colors.ml:
        1: (* Copyright (c) 2016-2017 David Kaloper Meršinjak. All rights reserved.
        2:    See LICENSE.md. *)
        3: 
        4: (**
        5:  * Demonstrates text attributes.
        6:  *)
        7: open Notty
        8: open Common
        9: 
       10: let colors = A.[
       11:   "black"        , black
       12: ; "red"          , red
       13: ; "green"        , green
       14: ; "yellow"       , yellow
       15: ; "blue"         , blue
       16: ; "magenta"      , magenta
       17: ; "cyan"         , cyan
       18: ; "white"        , white
       19: ; "lightblack"   , lightblack
       20: ; "lightred"     , lightred
       21: ; "lightgreen"   , lightgreen
       22: ; "lightyellow"  , lightyellow
       23: ; "lightblue"    , lightblue
       24: ; "lightmagenta" , lightmagenta
       25: ; "lightcyan"    , lightcyan
       26: ; "lightwhite"   , lightwhite
       27: ]
       28: 
       29: let styles = A.[
       30:   "empty"      , empty
       31: ; "bold"       , st bold
       32: ; "italic"     , st italic
       33: ; "underline"  , st underline
       34: ; "blink"      , st blink
       35: ; "reverse"    , st reverse
       36: ; "bold/italic", st bold ++ st italic
       37: ; "rev/underln", st underline ++ st reverse
       38: ; "bold/rev"   , st reverse ++ st bold
       39: ]
       40: 
       41: let image w =
       42:   let open List in
       43:   let core16 =
       44:     let c1  = map (fun (n, c) -> I.string A.(fg c) n) colors
       45:     and c2  = map (fun (n, c) -> I.string A.(fg black ++ bg c) n) colors
       46:     in I.(vcat c1 <|> void 1 0 <|> vcat c2)
       47:   and attr =
       48:     I.( styles |> map (fun (n, s) -> hpad 0 1 (string s n)) |> hcat) in
       49:   let combine imgs =
       50:     List.map I.(fun (n, i) -> string A.empty n <-> i <-> void 0 1) imgs
       51:     |> I.vcat |> I.pad ~l:1 ~t:1 in
       52:   combine [
       53:     "System colors:",     core16;
       54:     "Color cube, 6x6x6:", Images.c_cube_ix;
       55:     "Grayscale ramp:",    Images.c_gray_ramp;
       56:     "24bit:",             Images.c_rainbow (w - 2) 1;
       57:     "Text styles:",       attr
       58:   ]
       59: 
       60: let () = Notty_unix.output_image_size @@ fun (w, _) -> image w
Added regular file ../notty/examples/common.ml:
        1: (* Copyright (c) 2016-2017 David Kaloper Meršinjak. All rights reserved.
        2:    See LICENSE.md. *)
        3: 
        4: open Notty
        5: open Notty.Infix
        6: 
        7: let pow n e = int_of_float (float n ** float e)
        8: 
        9: module List = struct
       10: 
       11:   include List
       12: 
       13:   let rec replicate n a = if n < 1 then [] else a :: replicate (n - 1) a
       14: 
       15:   let rec range a b = if a > b then [] else a :: range (a + 1) b
       16: 
       17:   let rec intersperse a = function
       18:     | [] | [_] as t -> t
       19:     | x::xs         -> x :: a :: intersperse a xs
       20: 
       21:   let rec take n = function
       22:     | x::xs when n > 0 -> x :: take (pred n) xs
       23:     | _ -> []
       24: 
       25:   let rec splitat n = function
       26:     | x::xs when n > 0 ->
       27:         let (a, b) = splitat (pred n) xs in (x::a, b)
       28:     | xs -> ([], xs)
       29: 
       30:   let rec chunks n xs =
       31:     match splitat n xs with
       32:     | (a, []) -> [a]
       33:     | (a, b)  -> a :: chunks n b
       34: 
       35:   let rec zip xs ys = match (xs, ys) with
       36:     | ([], _) | (_, []) -> []
       37:     | (x::xs, y::ys) -> (x, y) :: zip xs ys
       38: 
       39: end
       40: 
       41: module String = struct
       42: 
       43:   include String
       44: 
       45:   let repeat n str =
       46:     let b = Buffer.create 16 in
       47:     for _ = 1 to n do Buffer.add_string b str done;
       48:     Buffer.contents b
       49: end
       50: 
       51: let tile w h i = I.tabulate w h (fun _ _ -> i)
       52: 
       53: (** A few images used in several places. *)
       54: module Images = struct
       55: 
       56:   let i1 =
       57:     I.(string A.(fg lightblack) "omgbbq" <->
       58:        string A.(fg white ++ bg red) "@")
       59:     <|> I.(pad ~t:2 @@ string A.(fg green) "xo")
       60: 
       61:   let i2 = I.(hpad 1 1 (hcrop 1 1 @@ tile 3 3 i1) <|> i1)
       62: 
       63:   let i3 = tile 5 5 i2
       64: 
       65:   let i4 =
       66:     let i = I.(i3 <|> crop ~t:1 i3 <|> i3) in
       67:     I.(crop ~l:1 i <-> crop ~r:1 i <-> crop ~b:2 i)
       68: 
       69:   let i5 =
       70:     tile 5 1 List.(
       71:       range 0 15 |> map (fun i -> I.pad ~t:i ~l:(i*2) i2) |> I.zcat
       72:     )
       73: 
       74:   let c_gray_ramp =
       75:     I.tabulate 24 1 (fun g _ -> I.string A.(bg (gray g)) " ")
       76: 
       77:   let c_cube_ix =
       78:     I.tabulate 6 1 @@ fun r _ ->
       79:       I.hpad 0 1 @@ I.tabulate 6 6 @@ fun b g ->
       80:         I.string A.(bg (rgb ~r ~g ~b)) " "
       81: 
       82:   let c_cube_rgb =
       83:     let f x = [| 0x00; 0x5f; 0x87; 0xaf; 0xd7; 0xff |].(x) in
       84:     I.tabulate 6 1 @@ fun r _ ->
       85:       I.hpad 0 1 @@ I.tabulate 6 6 @@ fun b g ->
       86:         I.string A.(bg (rgb_888 ~r:(f r) ~g:(f g) ~b:(f b))) " "
       87: 
       88:   let c_rainbow w h =
       89:     let pi2     = 2. *. 3.14159 in
       90:     let pi2_3   = pi2 /. 3.
       91:     and f t off = sin (t +. off) *. 128. +. 128. |> truncate in
       92:     let color t = A.rgb_888 ~r:(f t (-.pi2_3)) ~g:(f t 0.) ~b:(f t pi2_3) in
       93:     I.tabulate (w - 1) 1 @@ fun x _ ->
       94:       let t = (pi2 *. float x /. float w) +. 3.7 in
       95:       I.char A.(bg (color t)) ' ' 1 h
       96: 
       97:   (* U+25CF BLACK CIRCLE *)
       98:   let dot color = I.string (A.fg color) "●"
       99:   (* U+25AA BLACK SMALL SQUARE *)
      100:   let square color = I.string (A.fg color) "▪"
      101: 
      102:   let rec cantor = function
      103:     | 0 -> square A.lightblue
      104:     | n ->
      105:         let sub = cantor (pred n) in
      106:         I.hcat (List.replicate (pow 3 n) (square A.lightblue)) <->
      107:         (sub <|> I.void (pow 3 (n - 1)) 0 <|> sub)
      108: 
      109:   let checker n m i =
      110:     let w = I.width i in
      111:     I.(tile (n/2) (m/2) (hpad 0 w i <-> hpad w 0 i))
      112: 
      113:   let checker1 = checker 20 20 I.(char A.(bg magenta) ' ' 2 1)
      114: 
      115:   let rec sierp c n = I.(
      116:     if n > 1 then
      117:       let ss = sierp c (pred n) in ss <-> (ss <|> ss)
      118:     else hpad 1 0 (square c)
      119:   )
      120: 
      121:   let grid xxs = xxs |> List.map I.hcat |> I.vcat
      122: 
      123:   let outline attr i =
      124:     let (w, h) = I.(width i, height i) in
      125:     let chr x = I.uchar attr (Uchar.of_int x) 1 1
      126:     and hbar  = I.uchar attr (Uchar.of_int 0x2500) w 1
      127:     and vbar  = I.uchar attr (Uchar.of_int 0x2502) 1 h in
      128:     let (a, b, c, d) = (chr 0x256d, chr 0x256e, chr 0x256f, chr 0x2570) in
      129:     grid [ [a; hbar; b]; [vbar; i; vbar]; [d; hbar; c] ]
      130: end
      131: 
      132: let halfblock = "▄"
      133: 
      134: let pxmatrix w h f = I.tabulate w h @@ fun x y ->
      135:   let y = y * 2 in
      136:   I.string A.(bg (f x y) ++ fg (f x (y + 1))) halfblock
      137: 
      138: module Term = Notty_unix.Term
      139: 
      140: let simpleterm ~imgf ~f ~s =
      141:   let term = Term.create () in
      142:   let imgf (w, h) s =
      143:     I.(string A.(fg lightblack) "[ESC quits.]" <-> imgf (w, h - 1) s) in
      144:   let rec go s =
      145:     Term.image term (imgf (Term.size term) s);
      146:     match Term.event term with
      147:     | `End | `Key (`Escape, []) | `Key (`ASCII 'C', [`Ctrl]) -> ()
      148:     | `Resize _ -> go s
      149:     | #Unescape.event as e ->
      150:         match f s e with Some s -> go s | _ -> ()
      151:   in go s
Added regular file ../notty/examples/common_lwt.ml:
        1: (* Copyright (c) 2016-2017 David Kaloper Meršinjak. All rights reserved.
        2:    See LICENSE.md. *)
        3: 
        4: open Notty
        5: open Lwt.Infix
        6: 
        7: include Common
        8: 
        9: module T = Notty_lwt.Term
       10: 
       11: let simpleterm_lwt ~imgf ~f ~s =
       12:   let term = T.create () in
       13:   let imgf (w, h) s =
       14:     I.(string A.(fg lightblack) "[ESC quits.]" <-> imgf (w, h - 1) s) in
       15:   let step e s = match e with
       16:     | `Key (`Escape, []) | `Key (`ASCII 'C', [`Ctrl]) ->
       17:         T.release term >|= fun () -> s
       18:     | `Resize dim -> T.image term (imgf dim s) >|= fun () -> s
       19:     | #Unescape.event as e ->
       20:         match f s e with
       21:         | Some s -> T.image term (imgf (T.size term) s) >|= fun () -> s
       22:         | None   -> T.release term >|= fun () -> s
       23:   in
       24:   ( T.image term (imgf (T.size term) s)
       25:     >>= fun () -> Lwt_stream.fold_s step (T.events term) s )
       26:   |> Lwt_main.run |> ignore
       27: 
       28: 
       29: let timer = function
       30:   | None   -> Lwt.wait () |> fst
       31:   | Some t -> Lwt_unix.sleep t >|= fun _ -> `Timer
       32: 
       33: let event e = Lwt_stream.get (T.events e) >|= function
       34:   | Some (`Resize _ | #Unescape.event as x) -> x
       35:   | None -> `End
       36: 
       37: let simpleterm_lwt_timed ?delay ~f s0 =
       38:   let term = T.create () in
       39:   let rec loop (e, t) dim s =
       40:     (e <?> t) >>= function
       41:     | `End | `Key (`Escape, []) | `Key (`ASCII 'C', [`Ctrl]) ->
       42:         Lwt.return_unit
       43:     | `Resize dim as evt     -> invoke (event term, t) dim s evt
       44:     | #Unescape.event as evt -> invoke (event term, t) dim s evt
       45:     | `Timer as evt          -> invoke (e, timer delay) dim s evt
       46:   and invoke es dim s e =
       47:     match f dim s e with
       48:     | `Continue s    -> loop es dim s
       49:     | `Redraw (s, i) -> T.image term i >>= fun () -> loop es dim s
       50:     | `Stop          -> Lwt.return_unit in
       51:   let size = T.size term in
       52:   loop (event term, timer delay) size s0
Added regular file ../notty/examples/crops.ml:
        1: (* Copyright (c) 2016-2017 David Kaloper Meršinjak. All rights reserved.
        2:    See LICENSE.md. *)
        3: 
        4: (**
        5:  * Demonstrates edge-case behavior of functions that produce rectangle-like
        6:  * things.
        7:  *)
        8: open Notty
        9: open Common
       10: 
       11: let hdistribute ?align w imgs =
       12:   let n = List.length imgs in
       13:   I.(List.map (hsnap ?align (w / n)) imgs |> hcat)
       14: 
       15: let take w h i = I.(vsnap h i |> hsnap w)
       16: 
       17: let () =
       18:   simpleterm ~s:(2, 2)
       19:     ~f:(fun (w, h as s) -> function
       20:         `Key (`Arrow `Left, _) -> Some (w - 1, h)
       21:       | `Key (`Arrow `Right, _) -> Some (w + 1, h)
       22:       | `Key (`Arrow `Up, _) -> Some (w, h - 1)
       23:       | `Key (`Arrow `Down, _) -> Some (w, h + 1)
       24:       | `Key (`ASCII '0', _) -> Some (0, 0)
       25:       | _ -> Some s)
       26:     ~imgf:I.(fun (ow, oh) (w, h) ->
       27:       let (a1, a2, a3) = A.(fg lightmagenta, fg lightred, fg lightblue) in
       28:       strf "Sizing edge behavior. Dim: (%d, %d)" w h <->
       29:       ( hdistribute ow Images.[
       30:           outline a1 (uchar a1 (Uchar.of_int 0x2022) w h)
       31:         ; outline a2 (uchar a2 (Uchar.of_int 0x2022) 300 300 |> take w h)
       32:         ; outline a3 (void w h)
       33:         ] |> vsnap (oh - 4) )
       34:       <->
       35:       hdistribute ow [string a1 "char"; string a2 "crop"; string a3 "void"]
       36:     )
Added regular file ../notty/examples/cursor.ml:
        1: (* Copyright (c) 2016-2017 David Kaloper Meršinjak. All rights reserved.
        2:    See LICENSE.md. *)
        3: 
        4: open Notty
        5: open Common
        6: 
        7: let rec main t (x, y as pos) =
        8:   let img =
        9:     let dot = I.string A.(bg lightred ++ fg black) "✓" |> I.pad ~l:x ~t:y
       10:     and txt = I.strf ~attr:A.(fg lightblack) "@(%d, %d)" x y in
       11:     I.(txt </> dot) in
       12:   Term.image t img;
       13:   Term.cursor t (Some pos);
       14:   match Term.event t with
       15:   | `End | `Key (`Escape, []) | `Key (`ASCII 'C', [`Ctrl]) -> ()
       16:   | `Resize _ -> main t pos
       17:   | `Mouse ((`Press _ | `Drag), pos, _) -> main t pos
       18:   | `Key (`Arrow d, _) ->
       19:     ( main t @@ match d with
       20:       | `Up    -> (x, y - 1)
       21:       | `Down  -> (x, y + 1)
       22:       | `Left  -> (x - 1, y)
       23:       | `Right -> (x + 1, y) )
       24:   | _ -> main t pos
       25: 
       26: let () = main (Term.create ()) (0, 1)
Added regular file ../notty/examples/cuts.ml:
        1: (* Copyright (c) 2016-2017 David Kaloper Meršinjak. All rights reserved.
        2:    See LICENSE.md. *)
        3: 
        4: (**
        5:  * Demonstrates text cropping, particularly of grapheme clusters and wide
        6:  * characters.
        7:  *)
        8: open Notty
        9: open Notty_unix
       10: open Common
       11: 
       12: let hpadwith attr c a b i =
       13:   I.(char attr c a 1 <|> i <|> char attr c b 1)
       14: 
       15: let cuts i =
       16:   let w = I.width i in
       17:   List.(
       18:     range 0 w |> map (fun a ->
       19:       range 0 (w - a) |> map (fun b ->
       20:         i |> I.hcrop a b |> hpadwith A.(fg lightblack) '.' a b
       21:       ) |> I.vcat |> I.hpad 1 1
       22:     ) |> I.hcat |> I.vpad 1 1
       23:   )
       24: 
       25: let colors = A.[red; green; yellow; blue; magenta; cyan]
       26: 
       27: let patterns = [
       28:   "desu"
       29: ; ".▪e\204\129●."
       30: ; "(茶‸茶‶)"
       31: ; "(⌐■_■)"
       32: (* ; "¯\\(ツ)/¯" *)
       33: (* ; "ಠ_ಠ" *)
       34: (* ; "ಡ_ಡ" *)
       35: (* ; "\xe0\xb2\xa0\x5f\xe0\xb1\x83" *)
       36: (* ; "ತಎತ" *)
       37: (* ; "ಥ_ಥ" *)
       38: ; "ᕕ( ᐛ )ᕗ"
       39: (* ; "ᕙ(⇀‸↼‶)ᕗ" *)
       40: (* ; "ᕦ(ò_óˇ)ᕤ" *)
       41: (* ; "(╯ ︵╰ )" *)
       42: (* ; "\x28\x20\xcd\xa1\xc2\xb0\x20\xcd\x9c\xca\x96\x20\xcd\xa1\xc2\xb0\x29" *)
       43: ]
       44: 
       45: 
       46: let () =
       47:   let open I in
       48: 
       49:   patterns |> List.map (fun s ->
       50:     cuts (string A.(fg lightmagenta ++ bg lightblack) s)
       51:   ) |> I.vcat |> eol |> output_image ;
       52: 
       53:   colors |> List.mapi (fun i c ->
       54:     pad ~l:i ~t:i (
       55:       string A.(fg black ++ bg c ++ st blink) "茶" <|>
       56:       pad ~l:2 ~t:1
       57:         (string A.(fg c ++ st blink) "PARTY!"))
       58:   ) |> zcat |> pad ~l:2 ~t:2 ~b:2 |> output_image
Added regular file ../notty/examples/dune:
        1: (library
        2:   (name common)
        3:   (modules common)
        4:   (libraries notty notty.unix))
        5: 
        6: (library
        7:   (name common_lwt)
        8:   (modules common_lwt)
        9:   (libraries common notty.lwt))
       10: 
       11: (executables
       12:   (names testpatterns colors almondbread crops cursor cuts emoji inline keys
       13:          letters mouse thisbig runes sierpinski rain sierpinski_lwt linear
       14:          life)
       15:   (modules testpatterns colors almondbread crops cursor cuts emoji inline keys
       16:            letters mouse thisbig runes sierpinski rain sierpinski_lwt linear
       17:            life)
       18:   (libraries common common_lwt))
       19: 
       20: (alias
       21:   (name ex)
       22:   (package notty)
       23:   (deps testpatterns.exe colors.exe almondbread.exe crops.exe cursor.exe
       24:         cuts.exe emoji.exe inline.exe keys.exe letters.exe mouse.exe
       25:         thisbig.exe runes.exe sierpinski.exe rain.exe sierpinski_lwt.exe
       26:         linear.exe life.exe))
Added regular file ../notty/examples/emoji.ml:
        1: open Notty
        2: open Common
        3: 
        4: let es = [
        5:   [0x2e; 0x2e; 0x2e; 0x2e];
        6:   [0x25aa; 0x25fe; 0x25fc; 0x2b1b];
        7:   [0x1f346; 0x1f351; 0x1f605; 0x1f4a6];
        8:   [0x1f62d; 0x1f52a; 0x1f52a; 0x1f47c];
        9: ]
       10: 
       11: let image =
       12:   es |> List.(map (map @@ fun x ->
       13:     let i = I.uchar A.(fg lightwhite) (Uchar.of_int x) 1 1 in
       14:     I.(pad ~r:(3 - width i) i)
       15:   )) |> Images.grid |> I.pad ~l:1 |> Images.outline A.(fg lightblack)
       16: 
       17: let () = Notty_unix.output_image_size @@ fun (w, _) ->
       18:   I.(pad ~l:((w - width image) / 2) ~b:1 image)
Added regular file ../notty/examples/inline.ml:
        1: (* Copyright (c) 2017 David Kaloper Meršinjak. All rights reserved.
        2:    See LICENSE.md. *)
        3: 
        4: (** Demonstrates manual cursor positioning. *)
        5: 
        6: open Notty
        7: open Notty.Infix
        8: open Notty_unix
        9: 
       10: let sleep n = flush stdout; Unix.select [] [] [] n |> ignore
       11: 
       12: let pp_str attr = I.pp_attr attr Format.pp_print_string
       13: 
       14: let rewind n = move_cursor `Home; move_cursor (`By (0, - (max n 0)))
       15: 
       16: let output_subst ~prev i =
       17:   let h = I.height prev in
       18:   let d = h - I.height i in
       19:   if d > 0 then ( rewind (d - 1); output_image (I.void 0 d) );
       20:   rewind (h - 1); output_image i
       21: 
       22: let cmyk = function
       23:   | 0 -> A.rgb ~r:0 ~g:5 ~b:5
       24:   | 1 -> A.rgb ~r:5 ~g:0 ~b:5
       25:   | 2 -> A.rgb ~r:5 ~g:5 ~b:0
       26:   | 3 -> A.rgb ~r:0 ~g:0 ~b:0
       27:   | _ -> A.rgb ~r:5 ~g:5 ~b:5
       28: 
       29: let () =
       30: 
       31:   let (w, h) = match winsize Unix.stdout with
       32:     Some dim -> dim | _ -> assert false
       33:   and attr = A.(fg lightwhite ++ bg blue) in
       34:   let img1 =
       35:     I.(string attr "THE BLUE STRIPE ABOVE" <->
       36:          tabulate 1 h (fun _ _ -> I.strf "HIDDEN"))
       37:   and img2 =
       38:     I.(strf "Top line. There's a %a above. ^^^"
       39:          (pp_str attr) "blue stripe" |> vpad 0 2) in
       40: 
       41:   output_image img1; output_subst ~prev:img1 img2;
       42: 
       43:   output_image I.(string A.(fg white) "[..]" |> eol);
       44:   for i = 0 to 5 do
       45:     let a  = A.(bg (rgb ~r:i ~b:(5 - i) ~g:0)) in
       46:     let bg = I.tabulate 1 i (fun _ -> I.strf "HIDDEN [%d]") |> eol
       47:     and fg = I.char a ' ' 19 (5 - i) <|> I.char a '-' 1 (5 - i) |> eol in
       48:     output_image bg; output_subst ~prev:bg fg;
       49:   done;
       50:   output_image I.(string A.(fg white) "[..]" |> vpad 0 2);
       51: 
       52:   let rec go prev n =
       53:     if n <= w then
       54:       let h = log (float n) |> truncate in
       55:       let i = prev <|> I.tabulate 1 h (fun _ y -> I.char A.(bg (cmyk y)) ' ' 1 1) in
       56:       output_subst ~prev i; sleep 0.01; go i (n + 1)
       57:     else output_subst ~prev I.empty in
       58:   show_cursor false;
       59:   go I.empty 1;
       60:   show_cursor true;
       61: 
       62:   output_image
       63:     I.(strf "It doesn't say %a anywhere on screen, either."
       64:         (pp_attr A.(fg white) Format.pp_print_string) "hidden" |> eol)
       65: 
Added regular file ../notty/examples/keys.ml:
        1: (* Copyright (c) 2016-2017 David Kaloper Meršinjak. All rights reserved.
        2:    See LICENSE.md. *)
        3: 
        4: (**
        5:  * Demonstrates input parsing.
        6:  *)
        7: open Notty
        8: open Common
        9: 
       10: let pps = Format.pp_print_string
       11: let ppi = Format.pp_print_int
       12: 
       13: let pp_special fmt = function
       14:   | `Escape       -> pps fmt "ESCAPE"
       15:   | `Enter        -> pps fmt "ENTER"
       16:   | `Tab          -> pps fmt "TAB"
       17:   | `Backspace    -> pps fmt "BACKSPACE"
       18:   | `Arrow `Up    -> pps fmt "UP"
       19:   | `Arrow `Down  -> pps fmt "DOWN"
       20:   | `Arrow `Left  -> pps fmt "LEFT"
       21:   | `Arrow `Right -> pps fmt "RIGHT"
       22:   | `Page `Up     -> pps fmt "PAGE UP"
       23:   | `Page `Down   -> pps fmt "PAGE DOWN"
       24:   | `Home         -> pps fmt "HOME"
       25:   | `End          -> pps fmt "END"
       26:   | `Insert       -> pps fmt "INSERT"
       27:   | `Delete       -> pps fmt "DELETE"
       28:   | `Function n   -> pps fmt "FN"; ppi fmt n
       29: 
       30: let pp_mods fmt = function
       31:   | [] -> ()
       32:   | ms -> ms |> List.iter (fun m ->
       33:       pps fmt @@ match m with `Meta -> "M" | `Ctrl -> "C" | `Shift -> "S"
       34:     )
       35: 
       36: let pp_mouse fmt = function
       37:   | `Release -> pps fmt "Release"
       38:   | `Drag    -> pps fmt "Drag"
       39:   | `Move    -> pps fmt "Move"
       40:   | `Press k ->
       41:       pps fmt "Press ";
       42:       pps fmt @@ match k with
       43:         | `Left         -> "Left"
       44:         | `Middle       -> "Middle"
       45:         | `Right        -> "Right"
       46:         | `Scroll `Up   -> "Scroll Up"
       47:         | `Scroll `Down -> "Scroll Down"
       48: 
       49: let pp_u ppf u = Format.fprintf ppf "U+%04X" (Uchar.to_int u)
       50: 
       51: let () =
       52:   let magenta = A.(fg lightmagenta ++ bg black)
       53:   and green   = A.(fg lightgreen   ++ bg black)
       54:   and blue    = A.(fg lightblue    ++ bg black) in
       55:   let pp_mods  = I.pp_attr green pp_mods
       56:   and pp_mouse = I.pp_attr blue pp_mouse in
       57:   simpleterm ~s:[]
       58:     ~f:(fun xs x -> Some (List.take 100 (x::xs)))
       59:     ~imgf:(fun (_, h) xs ->
       60:       let attr = magenta in
       61:       let msg = I.string A.empty "Push keys."
       62:       and ks = List.map (function
       63:         | `Key ((`ASCII _ | `Uchar _) as c, mods) ->
       64:             let u = Unescape.uchar c in
       65:             I.(uchar blue u 1 1 <|> strf ~attr " %a %a" pp_u u pp_mods mods)
       66:         | `Key (#Unescape.special as k, mods) ->
       67:             I.strf ~attr "%a %a" pp_special k pp_mods mods
       68:         | `Mouse (e, (x, y), mods) ->
       69:             I.strf ~attr "MOUSE %a (%d, %d) %a" pp_mouse e x y pp_mods mods
       70:         | `Paste e ->
       71:             I.strf ~attr "PASTE %s" (if e = `Start then "START" else "END")
       72:         ) xs |> I.vcat in
       73:       I.(vsnap ~align:`Top (h - 3) ks <-> void 0 1 <-> msg |> pad ~l:1 ~t:1))
Added regular file ../notty/examples/letters.ml:
        1: (* Copyright (c) 2016-2017 David Kaloper Meršinjak. All rights reserved.
        2:    See LICENSE.md. *)
        3: 
        4: (**
        5:  * Dancing letters.
        6:  *)
        7: open Notty
        8: open Common
        9: 
       10: let nw = 6
       11: and nh = 5
       12: 
       13: let () =
       14:   simpleterm ~s:[]
       15:     ~f:(fun us -> function
       16:       | `Key ((`Delete|`Backspace), _) ->
       17:           Some (match us with _::xs -> xs | _ -> us)
       18:       | `Key ((`ASCII _|`Uchar _ as u), _) ->
       19:           Some (List.take (nw * nh) (Unescape.uchar u :: us))
       20:       | _  -> Some us)
       21:     ~imgf:(fun _ us ->
       22:       let open List in
       23:       let uus = chunks nw (rev us) in
       24:       mapi (fun i us ->
       25:         mapi (fun j u ->
       26:           I.uchar A.(fg white ++ bg (rgb ~r:0 ~g:i ~b:j)) u 1 1
       27:         ) us |> I.hcat
       28:       ) uus |> I.vcat
       29:       |> I.pad ~t:1 ~l:1
       30:       |> I.hsnap ~align:`Left (nw + 1)
       31:       |> tile nw 1)
Added regular file ../notty/examples/life.ml:
        1: (* Copyright (c) 2016-2017 David Kaloper Meršinjak. All rights reserved.
        2:    See LICENSE.md. *)
        3: 
        4: (*
        5:  * Game of Life with some ZX spectrum kitsch.
        6:  *)
        7: 
        8: let flip f a b = f b a
        9: 
       10: (** Live, **)
       11: 
       12: module Coord = struct
       13:   type t = int * int
       14:   let compare ((a, b) : t) (c, d) =
       15:     match compare a c with 0 -> compare b d | r -> r
       16:   let equal ((a, b) : t) (c, d) = a = c && b = d
       17: end
       18: 
       19: module CSet = struct
       20:   include Set.Make (Coord)
       21:   let of_list = List.fold_left (flip add) empty
       22:   let map f s = fold (fun x s -> add (f x) s) s empty
       23: end
       24: 
       25: module CMap = struct
       26:   include Map.Make (Coord)
       27:   let preimg p m =
       28:     fold (fun k v s -> if p v then CSet.add k s else s) m CSet.empty
       29: end
       30: 
       31: let erem x y = (x mod y + y) mod y
       32: let square (w, h) (a, b as ab) =
       33:   if a < 0 || a >= w || b < 0 || b >= h then (-1, -1) else ab
       34: let torus (w, h) (a, b) = (erem a w, erem b h)
       35: let moebius (w, h) (a, b as ab) =
       36:   if a < 0 || a >= w then (erem a w, h - b - 1) else ab
       37: 
       38: let neigh topo (a, b) = [
       39:   (a-1, b); (a+1, b); (a-1, b-1); (a-1, b+1)
       40: ; (a, b-1); (a, b+1); (a+1, b-1); (a+1, b+1)
       41: ] |> List.map topo
       42: 
       43: let step topo life =
       44:   let nlive pt =
       45:     List.(neigh topo pt |> filter (flip CSet.mem life) |> length) in
       46:   let f1 pt acc =
       47:     pt :: neigh topo pt |> List.fold_left (fun acc -> function
       48:       | (-1, -1) -> acc
       49:       | pt when CMap.mem pt acc -> acc
       50:       | pt ->
       51:           let n = nlive pt in
       52:           acc |> CMap.add pt
       53:             (if n = 3 || (n = 2 && CSet.mem pt life) then 0 else 1)
       54:     ) acc in
       55:   CSet.fold f1 life CMap.empty |> CMap.preimg ((=) 0)
       56: 
       57: let glider = CSet.of_list [(2,1); (3,2); (1,3); (2,3); (3,3)]
       58: 
       59: (** ...render, **)
       60: 
       61: open Notty
       62: open Notty.Infix
       63: 
       64: let dot = I.string A.(fg lightred) "●"
       65: 
       66: let background step (n, m) =
       67:   let k = 24. *. sin (float (step + m + n) /. 10.) |> truncate in
       68:   if k > 0 then I.string A.(fg (gray k)) "." else I.void 1 1
       69: 
       70: let render (w, h) step life =
       71:   I.tabulate w (h - 1) (fun x y ->
       72:     let pt = (x, y) in if CSet.mem pt life then dot else background step pt
       73:   ) <->
       74:   I.(strf ~attr:A.(fg lightblack) "[generation %04d]" step |>
       75:       hsnap ~align:`Right w)
       76: 
       77: (** ...and interact. **)
       78: 
       79: open Lwt.Infix
       80: open Notty_lwt
       81: 
       82: let timer () = Lwt_unix.sleep 0.1 >|= fun () -> `Timer
       83: let event term = Lwt_stream.get (Term.events term) >|= function
       84:   | Some (`Resize _ | #Unescape.event as x) -> x
       85:   | None -> `End
       86: 
       87: let rec loop term (e, t) (dim, n, life as st) =
       88:   (e <?> t) >>= function
       89:   | `End | `Key (`Escape, []) | `Key (`ASCII 'C', [`Ctrl]) ->
       90:       Lwt.return_unit
       91:   | `Timer ->
       92:       Term.image term (render dim n life) >>= fun () ->
       93:         loop term (e, timer ())
       94:           (dim, n + 1, step (torus dim) life)
       95:   | `Mouse ((`Press `Left|`Drag), (x, y), _) ->
       96:       loop term (event term, t)
       97:         (dim, n, CSet.add (torus dim (x, y)) life)
       98:   | `Resize dim ->
       99:       let life = CSet.map (torus dim) life in
      100:       Term.image term (render dim n life) >>= fun () ->
      101:         loop term (event term, t) (dim, n, life)
      102:   | _ -> loop term (event term, t) st
      103: 
      104: let main () =
      105:   let t = Term.create () in
      106:   loop t (event t, timer ()) (Term.size t, 0, glider)
      107: 
      108: let () = Lwt_main.run @@ main ()
Added regular file ../notty/examples/linear.ml:
        1: (* Copyright (c) 2016-2017 David Kaloper Meršinjak. All rights reserved.
        2:    See LICENSE.md. *)
        3: 
        4: (*
        5:  * Elementary Cellular Automata
        6:  *)
        7: open Notty
        8: open Notty.Infix
        9: open Common_lwt
       10: 
       11: let flip f a b = f b a
       12: let rec take n = function
       13:   | x::xs when n > 0 -> x :: take (pred n) xs
       14:   | _                -> []
       15: 
       16: let getd arr d i =
       17:   if i < 0 || i >= Array.length arr then d else arr.(i)
       18: 
       19: let f ~rule a b c =
       20:   if rule land (1 lsl (a lsl 2 + b lsl 1 + c)) > 0 then 1 else 0
       21: 
       22: let step ~rule w arr =
       23:   let get = getd arr 0 in
       24:   Array.init w @@ fun i ->
       25:     f ~rule (get (i - 1)) (get i) (get (i + 1))
       26: 
       27: let dot  = I.char A.(bg lightwhite) ' ' 1 1
       28: let void = I.void 1 1
       29: 
       30: let render ~rule ~h xss =
       31:   let cons k = function
       32:     | 0 -> I.void k 1
       33:     | _ -> I.char A.(bg lightwhite) ' ' k 1 in
       34:   let rec rline s k i arr =
       35:     if i >= Array.length arr then
       36:       cons k s
       37:     else if arr.(i) = s then
       38:       rline s (k + 1) (i + 1) arr
       39:     else cons k s <|> rline (1 - s) 1 (i + 1) arr in
       40:   ( xss |> List.rev |> List.map (rline 0 0 0) |> I.vcat
       41:     |> I.vsnap ~align:`Top (h - 2) ) <->
       42:   ( I.strf ~attr:A.(fg lightgreen ++ bg black) " RULE %d " rule
       43:     |> I.vpad 1 0 )
       44: 
       45: let rule = 124 (* 110 mirrored *)
       46: 
       47: let main () =
       48:   simpleterm_lwt_timed ~delay:0.1 ([], rule)
       49:   ~f:(fun (w, h) (lines, rule) -> function
       50:     | `Timer ->
       51:         let prev  = match lines with [] -> [|1|] | h::_ -> h in
       52:         let lines = step ~rule w prev :: lines |> take (h - 2) in
       53:         `Redraw ((lines, rule), render ~rule ~h lines)
       54:     | `Resize _ ->
       55:         let lines = lines |> take h in
       56:         `Redraw ((lines, rule), render ~rule ~h lines)
       57:     | `Key (`Arrow `Left, []) ->
       58:         `Redraw (([], rule - 1), render ~rule ~h lines)
       59:     | `Key (`Arrow `Right, []) ->
       60:         `Redraw (([], rule + 1), render ~rule ~h lines)
       61:     | _ -> `Continue (lines, rule)
       62:   )
       63: 
       64: let () = Lwt_main.run @@ main ()
Added regular file ../notty/examples/mouse.ml:
        1: (* Copyright (c) 2016-2017 David Kaloper Meršinjak. All rights reserved.
        2:    See LICENSE.md. *)
        3: 
        4: (**
        5:  * Demonstrates mouse input.
        6:  *)
        7: open Notty
        8: open Common
        9: 
       10: let lnv = Uchar.of_int 0x2502
       11: and lnh = Uchar.of_int 0x2500
       12: and crs = Uchar.of_int 0x253c
       13: 
       14: let clip a b x = min b (max a x)
       15: 
       16: let () =
       17:   simpleterm ~s:(`Down, (0, 0), [], 11)
       18:     ~f:(fun (st, pos, mods, scr as s) -> function
       19:       | `Mouse ((`Press `Left|`Drag), pos, mods) -> Some (`Drag, pos, mods, scr)
       20:       | `Mouse (`Press (`Scroll s), _, _) ->
       21:           Some (st, pos, mods, clip 0 23 (scr + match s with `Up -> 1 | _ -> -1))
       22:       | `Mouse (`Release, pos, _) -> Some (`Down, pos, [], scr)
       23:       | _ -> Some s)
       24:     ~imgf:I.(fun (w, h) (st, (x, y), mods, scr) ->
       25:       let cross =
       26:         let a  = match st with `Drag -> A.(fg lightgreen) | `Down -> A.(fg green) in
       27:         (uchar a lnh x 1 |> vpad y 0) <|>
       28:         (uchar a lnv 1 y <-> uchar a crs 1 1 <-> uchar a lnv 1 (h - y)) <|>
       29:         (uchar a lnh (w - x - 1) 1 |> vpad y 0)
       30:         |> crop ~t:1 ~l:1 ~r:3
       31:         |> hpad 1 1
       32:         |> vsnap ~align:`Top (h - 1)
       33:       and scroll =
       34:         List.(range 0 scr |> rev |> map @@ fun level ->
       35:           Images.dot A.(gray level)
       36:         ) |> vcat |> vsnap ~align:`Bottom (h - 1)
       37:       and status =
       38:         let a = A.(fg lightblack ++ bg black) in
       39:         let fa m = if List.mem m mods then A.(fg lightgreen ++ bg black) else a in
       40:         string A.empty "Use the mouse." </>
       41:         (hcat [ string a "["
       42:               ; string (fa `Ctrl) "C"
       43:               ; string (fa `Meta) "M"
       44:               ; strf ~attr:a "] @(%03d, %03d)" x y ]
       45:          |> hsnap ~align:`Right w)
       46:       in (cross <|> scroll) <-> status
       47:     )
Added regular file ../notty/examples/rain.ml:
        1: 
        2: let () = Random.self_init ()
        3: 
        4: let rec (--) a b = if a > b then [] else a :: succ a -- b
        5: 
        6: let utf8_of_code_point =
        7:   let buf = Buffer.create 7 in fun cp ->
        8:     Buffer.clear buf;
        9:     Uutf.Buffer.add_utf_8 buf (Uchar.of_int cp);
       10:     Buffer.contents buf
       11: 
       12: let nsym = 4096
       13: let glitch = nsym / 20
       14: let symbols = Array.(concat [
       15:   init 58 (fun x -> utf8_of_code_point (0xff66 + x));
       16:   init 10 (fun x -> utf8_of_code_point (0x30 + x));
       17:   (* init 26 (fun x -> utf8_of_code_point (0x61 + x)); *)
       18:   (* init 14 (fun x -> utf8_of_code_point (0x21 + x)); *)
       19: ])
       20: let sym () = symbols.(Random.int (Array.length symbols))
       21: let syms = Array.init nsym (fun _ -> sym ())
       22: 
       23: let gen_wait h = `Wait Random.(int (h / 2))
       24: and gen_line h =
       25:   `Line Random.(0, int (nsym - h), int (h + h / 2) + 1, int 2 + 1)
       26: let gen (w, h as dim) =
       27:   let lines = 1 -- w |> List.map @@ fun _ ->
       28:     if Random.float 1. < 0.1 then gen_line h else gen_wait h in
       29:   (dim, lines)
       30: 
       31: let step ((_, h as dim), xs) =
       32:   let xs = xs |> List.map @@ function
       33:       `Wait 0 -> gen_line h
       34:     | `Wait n -> `Wait (n - 1)
       35:     | `Line (i, _, win, k) when i - win + k >= h -> gen_wait h
       36:     | `Line (i, s, win, k) -> `Line (i + k, s, win, k) in
       37:   Random.(for _ = 0 to int glitch do syms.(int nsym) <- sym () done);
       38:   (dim, xs)
       39: 
       40: open Notty
       41: open Notty.Infix
       42: 
       43: let bgc = A.(bg @@ rgb ~r:0 ~g:0 ~b:0)
       44: 
       45: let color i n =
       46:   let chan x = x *. 255. |> truncate
       47:   and t  = float i /. float n in
       48:   let t1 = exp (-. t /. 0.02) |> chan
       49:   and t2 = exp (-. t /. 0.45) |> chan in
       50:   A.rgb_888 ~r:t1 ~b:t1 ~g:t2
       51: 
       52: let show ((w, h), xs) =
       53:   let f = function
       54:     `Wait _ -> I.void 1 0
       55:   | `Line (i, sym, win, _) ->
       56:       let last = i - win
       57:       and off = max 0 (i - h + 1) in
       58:       let rec chars w =
       59:         let ix = w + last in
       60:         if 0 <= min ix w then syms.(sym + ix) :: chars (w - 1) else [] in
       61:       let rec images acc i = function
       62:         | []    -> acc
       63:         | x::xs -> let img = I.string A.(fg (color i win) ++ bgc) x in
       64:                    images (img :: acc) (i + 1) xs in
       65:       chars (win - off) |> images [] off
       66:         |> I.vcat |> I.vpad (max 0 (i - win)) 0 in
       67:   (List.map f xs |> I.hcat) </> I.char bgc ' ' w h
       68: 
       69: open Notty_unix
       70: 
       71: type r = [ Unescape.event | `Resize of int * int | `End | `Timer ]
       72: 
       73: let event ~delay t =
       74:   if Term.pending t then (Term.event t :> r) else
       75:     let open Unix in
       76:     match select [Term.fds t |> fst] [] [] delay with
       77:     | ([], _, _) -> `Timer
       78:     | (_::_, _, _) -> (Term.event t :> r)
       79:     | exception Unix_error (EINTR, _, _) -> (Term.event t :> r)
       80: 
       81: let loop t ~frame st =
       82:   let rec go st deadline =
       83:     let now = Unix.gettimeofday () in
       84:     if deadline <= now then
       85:       ( Term.image t (show st); go (step st) (frame +. deadline) )
       86:     else match event ~delay:(deadline -. now) t with
       87:       | `End | `Key (`Escape, _) | `Key (`ASCII 'C', [`Ctrl]) -> ()
       88:       | `Resize _ | `Key (`ASCII ' ', _) -> go (gen (Term.size t)) deadline
       89:       | _ -> go st deadline in
       90:   go st (Unix.gettimeofday ())
       91: 
       92: let () =
       93:   let t = Term.create () in
       94:   loop t ~frame:0.075 (gen (Term.size t));
       95:   Term.release t
Added regular file ../notty/examples/runes.ml:
        1: (* Copyright (c) 2016-2017 David Kaloper Meršinjak. All rights reserved.
        2:    See LICENSE.md. *)
        3: 
        4: (**
        5:  * Demonstrates geometry computation with various scripts. A few of those will
        6:  * usually break.
        7:  *)
        8: open Notty
        9: open Notty.Infix
       10: open Common
       11: 
       12: let hpad_sp attr l r i =
       13:   let h = I.height i in
       14:   I.(char attr ' ' l h <|> i <|> char attr ' ' r h)
       15: 
       16: let vpad_sp attr t b i =
       17:   let w = I.width i in
       18:   I.(char attr ' ' w t <-> i <-> char attr ' ' w b)
       19: 
       20: let grid xxs = xxs |> List.map I.hcat |> I.vcat
       21: 
       22: let centered attr xs =
       23:   let lns = List.map I.(string attr) xs in
       24:   let w   = List.fold_left (fun a i -> max a I.(width i)) 0 lns in
       25:   lns |> List.map I.(fun ln ->
       26:     let d = w - I.width ln in
       27:     char attr ' ' (d / 2) 1 <|> ln <|> char attr ' ' (d - d / 2) 1
       28:   ) |> I.vcat
       29: 
       30: let note xs = I.(
       31:   string A.(st bold) "Note:" <|>
       32:   (xs |> List.map (string A.empty) |> vcat |> hpad 1 0)
       33: )
       34: 
       35: let text = [
       36:     "\225\154\160\225\155\135\225\154\187\225\155\171\225\155\146\225\155\166\225\154\166\225\155\171\225\154\160\225\154\177\225\154\169\225\154\160\225\154\162\225\154\177\225\155\171\225\154\160\225\155\129\225\154\177\225\154\170\225\155\171\225\154\183\225\155\150\225\154\187\225\154\185\225\155\166\225\155\154\225\154\179\225\154\162\225\155\151"
       37:   ; "\225\155\139\225\154\179\225\155\150\225\154\170\225\155\154\225\155\171\225\154\166\225\155\150\225\154\170\225\154\187\225\155\171\225\155\151\225\154\170\225\154\190\225\154\190\225\154\170\225\155\171\225\154\183\225\155\150\225\154\187\225\154\185\225\155\166\225\155\154\225\154\179\225\155\171\225\155\151\225\155\129\225\154\179\225\155\154\225\154\162\225\154\190\225\155\171\225\154\187\225\155\166\225\155\143\225\155\171\225\155\158\225\154\171\225\155\154\225\154\170\225\154\190"
       38:   ; "\225\154\183\225\155\129\225\154\160\225\155\171\225\154\187\225\155\150\225\155\171\225\154\185\225\155\129\225\155\154\225\155\150\225\155\171\225\154\160\225\154\169\225\154\177\225\155\171\225\155\158\225\154\177\225\155\129\225\154\187\225\155\143\225\154\190\225\155\150\225\155\171\225\155\158\225\154\169\225\155\151\225\155\150\225\155\139\225\155\171\225\154\187\225\155\154\225\155\135\225\155\143\225\154\170\225\154\190\225\155\172"
       39:   ; ""
       40:   ; "\227\129\132\227\130\141\227\129\175\227\129\171\227\129\187\227\129\184\227\129\168\227\129\161\227\130\138\227\129\172\227\130\139\227\130\146"
       41:   ; "\227\130\143\227\129\139\227\130\136\227\129\159\227\130\140\227\129\157\227\129\164\227\129\173\227\129\170\227\130\137\227\130\128"
       42:   ; "\227\129\134\227\130\144\227\129\174\227\129\138\227\129\143\227\130\132\227\129\190\227\129\145\227\129\181\227\129\147\227\129\136\227\129\166"
       43:   ; "\227\129\130\227\129\149\227\129\141\227\130\134\227\130\129\227\129\191\227\129\151\227\130\145\227\129\178\227\130\130\227\129\155\227\129\153"
       44:   ; ""
       45:   ; "\227\130\164\227\131\173\227\131\143\227\131\139\227\131\155\227\131\152\227\131\136 \227\131\129\227\131\170\227\131\140\227\131\171\227\131\178 \227\131\175\227\130\171\227\131\168\227\130\191\227\131\172\227\130\189 \227\131\132\227\131\141\227\131\138\227\131\169\227\131\160"
       46:   ; "\227\130\166\227\131\176\227\131\142\227\130\170\227\130\175\227\131\164\227\131\158 \227\130\177\227\131\149\227\130\179\227\130\168\227\131\134 \227\130\162\227\130\181\227\130\173\227\131\166\227\131\161\227\131\159\227\130\183 \227\131\177\227\131\146\227\131\162\227\130\187\227\130\185\227\131\179"
       47:   ; ""
       48:   ; "\237\130\164\236\138\164\236\157\152 \234\179\160\236\156\160\236\161\176\234\177\180\236\157\128 \236\158\133\236\136\160\235\129\188\235\166\172 \235\167\140\235\130\152\236\149\188"
       49:   ; "\237\149\152\234\179\160 \237\138\185\235\179\132\237\149\156 \234\184\176\236\136\160\236\157\128 \237\149\132\236\154\148\236\185\152 \236\149\138\235\139\164"
       50:   ; ""
       51:   ; "\206\158\206\181\207\131\206\186\206\181\207\128\206\172\206\182\207\137 \207\132\225\189\180\206\189 \207\136\207\133\207\135\206\191\207\134\206\184\207\140\207\129\206\177 \206\178\206\180\206\181\206\187\207\133\206\179\206\188\206\175\206\177"
       52:   ; ""
       53:   ; "\208\167\208\181\209\136\209\155\208\181 \209\134e\209\146\208\181\209\154\208\181 \208\188\209\128e\208\182\208\176\209\129\209\130\208\184\208\188 \209\159\208\176\208\186\208\190\208\188 \208\191\208\190\208\177\208\190\209\153\209\136\208\176\208\178\208\176"
       54:   ; "\209\132\208\181\209\128\209\130\208\184\208\187\208\184\208\183\208\176\209\134\208\184\209\152\209\131 \208\179\208\181\208\189\209\129\208\186\208\184\209\133 \209\133\208\184\208\177\209\128\208\184\208\180\208\176!"
       55:   ; ""
       56:   ; "Heiz\195\182lr\195\188cksto\195\159abd\195\164mpfung."
       57:   ; ""
       58:   ; "\208\146 \209\135\208\176\209\137\208\176\209\133 \209\142\208\179\208\176 \208\182\208\184\208\187 \208\177\209\139 \209\134\208\184\209\130\209\128\209\131\209\129? \208\148\208\176, \208\189\208\190 \209\132\208\176\208\187\209\140\209\136\208\184\208\178\209\139\208\185 \209\141\208\186\208\183\208\181\208\188\208\191\208\187\209\143\209\128!"
       59:   ; ""
       60:   ; "\225\131\149\225\131\148\225\131\158\225\131\174\225\131\152\225\131\161 \225\131\162\225\131\167\225\131\144\225\131\157\225\131\161\225\131\144\225\131\156\225\131\152 \225\131\168\225\131\157\225\131\151\225\131\144 \225\131\160\225\131\163\225\131\161\225\131\151\225\131\144\225\131\149\225\131\148\225\131\154\225\131\152"
       61:   ; ""
       62:   ; "Lu\195\173s arg\195\188ia \195\160 J\195\186lia que \194\171bra\195\167\195\181es, f\195\169, ch\195\161,"
       63:   ; "\195\179xido, p\195\180r, z\195\162ng\195\163o\194\187 eram palavras do portugu\195\170s."
       64:   ; ""
       65:   ; "ding ↹ ∀ ⌘ ▓ ◭ ☃ ♠ ♋ ♕ ⚅ ♩ ☭ ✎ 🂡 bats"
       66:   ; ""
       67:   ; "\216\181\217\144\217\129 \216\174\217\142\217\132\217\130\217\142 \216\174\217\142\217\136\216\175\217\144 \217\131\217\142\217\133\217\144\216\171\217\132\217\144 \216\167\217\132\216\180\217\142\217\133\216\179\217\144 \216\165\217\144\216\176 \216\168\217\142\216\178\217\142\216\186\217\142\216\170 \226\128\148 \217\138\217\142\216\173\216\184\217\137 \216\167\217\132\216\182\217\142\216\172\217\138\216\185\217\143 \216\168\217\144\217\135\216\167 \217\134\217\142\216\172\217\132\216\167\216\161\217\142 \217\133\217\144\216\185\216\183\216\167\216\177\217\144"
       68:   ; ""
       69:   ; "\215\147\215\146 \215\161\215\167\215\168\215\159 \215\169\215\152 \215\145\215\153\215\157 \215\158\215\144\215\149\215\155\215\150\215\145 \215\149\215\156\215\164\215\170\215\162 \215\158\215\166\215\144 \215\156\215\149 \215\151\215\145\215\168\215\148 \215\144\215\153\215\154 \215\148\215\167\215\156\215\153\215\152\215\148"
       70:   ; ""
       71:   ; "\224\174\175\224\174\190\224\174\174\224\174\177\224\174\191\224\174\168\224\175\141\224\174\164 \224\174\174\224\175\138\224\174\180\224\174\191\224\174\149\224\174\179\224\174\191\224\174\178\224\175\135 \224\174\164\224\174\174\224\174\191\224\174\180\224\175\141\224\174\174\224\175\138\224\174\180\224\174\191 \224\174\170\224\175\139\224\174\178\224\175\141 \224\174\135\224\174\169\224\174\191\224\174\164\224\174\190\224\174\181\224\174\164\224\175\129 \224\174\142\224\174\153\224\175\141\224\174\149\224\175\129\224\174\174\224\175\141 \224\174\149\224\174\190\224\174\163\224\175\139\224\174\174\224\175\141,"
       72:   ; "\224\174\170\224\174\190\224\174\174\224\174\176\224\174\176\224\174\190\224\174\175\224\175\141 \224\174\181\224\174\191\224\174\178\224\174\153\224\175\141\224\174\149\224\175\129\224\174\149\224\174\179\224\174\190\224\174\175\224\175\141, \224\174\137\224\174\178\224\174\149\224\174\169\224\175\136\224\174\164\224\175\141\224\174\164\224\175\129\224\174\174\224\175\141 \224\174\135\224\174\149\224\174\180\224\175\141\224\174\154\224\175\141\224\174\154\224\174\191\224\174\154\224\175\138\224\174\178\224\174\170\224\175\141 \224\174\170\224\174\190\224\174\169\224\175\141\224\174\174\224\175\136 \224\174\149\224\175\134\224\174\159\224\175\141\224\174\159\224\175\129"
       73:   ; ""
       74:   ; "\224\178\172\224\178\190 \224\178\135\224\178\178\224\179\141\224\178\178\224\178\191 \224\178\184\224\178\130\224\178\173\224\178\181\224\178\191\224\178\184\224\179\129 \224\178\135\224\178\130\224\178\166\224\179\134\224\178\168\224\179\141\224\178\168 \224\178\185\224\179\131\224\178\166\224\178\175\224\178\166\224\178\178\224\178\191"
       75:   ; "\224\178\168\224\178\191\224\178\164\224\179\141\224\178\175\224\178\181\224\179\130 \224\178\133\224\178\181\224\178\164\224\178\176\224\178\191\224\178\170 \224\178\184\224\178\164\224\179\141\224\178\175\224\178\190\224\178\181\224\178\164\224\178\190\224\178\176"
       76:   ; ""
       77:   ; "\224\164\139\224\164\183\224\164\191\224\164\175\224\165\139\224\164\130 \224\164\149\224\165\139 \224\164\184\224\164\164\224\164\190\224\164\168\224\165\135 \224\164\181\224\164\190\224\164\178\224\165\135 \224\164\166\224\165\129\224\164\183\224\165\141\224\164\159 \224\164\176\224\164\190\224\164\149\224\165\141\224\164\183\224\164\184\224\165\139\224\164\130 \224\164\149\224\165\135 \224\164\176\224\164\190\224\164\156\224\164\190 \224\164\176\224\164\190\224\164\181\224\164\163 \224\164\149\224\164\190 \224\164\184\224\164\176\224\165\141\224\164\181\224\164\168\224\164\190\224\164\182 \224\164\149\224\164\176\224\164\168\224\165\135 \224\164\181\224\164\190\224\164\178\224\165\135"
       78:   ; "\224\164\181\224\164\191\224\164\183\224\165\141\224\164\163\224\165\129\224\164\181\224\164\164\224\164\190\224\164\176 \224\164\173\224\164\151\224\164\181\224\164\190\224\164\168 \224\164\182\224\165\141\224\164\176\224\165\128\224\164\176\224\164\190\224\164\174, \224\164\133\224\164\175\224\165\139\224\164\167\224\165\141\224\164\175\224\164\190 \224\164\149\224\165\135 \224\164\174\224\164\185\224\164\190\224\164\176\224\164\190\224\164\156 \224\164\166\224\164\182\224\164\176\224\164\165 \224\164\149\224\165\135 \224\164\172\224\164\161\224\164\188\224\165\135 \224\164\184\224\164\170\224\165\129\224\164\164\224\165\141\224\164\176 \224\164\165\224\165\135\224\165\164"
       79: ]
       80: 
       81: let () =
       82:   let attr = A.(fg lightmagenta) in
       83:   let img = I.(
       84:     centered attr text
       85:     |> vpad_sp attr 1 1 |> hpad_sp attr 2 2
       86:     |> Images.outline attr
       87:     |> pad ~t:1 ~b:1 ~l:2 ~r:2
       88:   ) <->
       89:     note [ "Alignment will usually break on the last few scripts."
       90:          ; "This is at the limit of what terminals can do."
       91:          ; ":(" ]
       92:   in Notty_unix.(eol img |> output_image)
Added regular file ../notty/examples/sierpinski.ml:
        1: (* Copyright (c) 2016-2017 David Kaloper Meršinjak. All rights reserved.
        2:    See LICENSE.md. *)
        3: 
        4: (**
        5:  * A classic example in combinatory graphics.
        6:  *
        7:  * Demonstrates interaction.
        8:  *)
        9: open Notty
       10: open Common
       11: 
       12: let () =
       13:   simpleterm ~s:1
       14:     ~f:(fun s -> function
       15:       | `Key (`ASCII 'q', _) -> None
       16:       | `Key (`Arrow a, _) ->
       17:         ( match a with
       18:           | `Up | `Left -> Some (max 1 (s - 1))
       19:           | `Down | `Right -> Some (min 10 (s + 1)) )
       20:       | _ -> Some s)
       21:     ~imgf:I.(fun _ s ->
       22:       string A.empty (string_of_int s) <->
       23:       pad ~l:2 ~t:1 (Images.sierp A.magenta s)
       24:     )
Added regular file ../notty/examples/sierpinski_lwt.ml:
        1: (* Copyright (c) 2016-2017 David Kaloper Meršinjak. All rights reserved.
        2:    See LICENSE.md. *)
        3: 
        4: (**
        5:  * Demonstrates Lwt interaction.
        6:  *)
        7: open Notty
        8: open Common_lwt
        9: 
       10: let img s = I.(
       11:   string A.empty (string_of_int s) <-> hpad 2 0 (Images.sierp A.magenta s)
       12: )
       13: 
       14: let () =
       15:   simpleterm_lwt ~s:1
       16:     ~f:(fun s -> function
       17:       | `Key (`ASCII 'q', _) -> None
       18:       | `Key (`Arrow a, _) ->
       19:         ( match a with
       20:           | `Up | `Left -> Some (max 1 (s - 1))
       21:           | `Down | `Right -> Some (min 10 (s + 1)) )
       22:       | _ -> Some s)
       23:     ~imgf:I.(fun _ s ->
       24:       string A.empty (string_of_int s) <->
       25:       pad ~l:2 ~t:1 (Images.sierp A.magenta s)
       26:     )
Added regular file ../notty/examples/testpatterns.ml:
        1: (* Copyright (c) 2016-2017 David Kaloper Meršinjak. All rights reserved.
        2:    See LICENSE.md. *)
        3: 
        4: (**
        5:  * A few images that exercise image composition, cropping, and padding. This
        6:  * test is a good canary.
        7:  *)
        8: open Common
        9: open Notty_unix
       10: 
       11: let () = Images.[i3; i5; checker1] |> List.map eol |> List.iter output_image
Added regular file ../notty/examples/thisbig.ml:
        1: (* Copyright (c) 2016-2017 David Kaloper Meršinjak. All rights reserved.
        2:    See LICENSE.md. *)
        3: 
        4: open Notty
        5: open Common
        6: 
        7: let () =
        8:   Notty_unix.output_image_size @@ fun (w, h) ->
        9:     Images.outline A.(fg lightblue)
       10:       I.(hsnap (w - 2) @@
       11:           vsnap (h - 3) @@ (* +1 for the prompt *)
       12:             Images.sierp A.lightblue 5)
Added regular file ../notty/notty.opam:
        1: opam-version: "2.0"
        2: homepage:     "https://github.com/pqwy/notty"
        3: dev-repo:     "git+https://github.com/pqwy/notty.git"
        4: bug-reports:  "https://github.com/pqwy/notty/issues"
        5: doc:          "https://pqwy.github.io/notty/doc"
        6: author:       "David Kaloper <dk505@cam.ac.uk>"
        7: maintainer:   "David Kaloper <dk505@cam.ac.uk>"
        8: license:      "ISC"
        9: synopsis:     "Declaring terminals"
       10: description:
       11:   "Notty is a declarative terminal library for OCaml structured around a notion
       12:   of composable images. It tries to abstract away the basic terminal programming
       13:   model, providing something simpler and more expressive."
       14: 
       15: build: [ [ "dune" "subst" ] {dev}
       16:          [ "dune" "build" "-p" name "-j" jobs ] ]
       17: depends: [
       18:   "ocaml" {>= "4.08.0"}
       19:   "dune" {>= "1.7"}
       20:   "cppo" {build & >= "1.1.0"}
       21:   "uutf" {>= "1.0.0"}
       22: ]
       23: depopts: [ "lwt" ]
       24: conflicts: [ "lwt" {<"2.5.2"} ]
Added regular file ../notty/src/dune:
        1: (include_subdirs unqualified)
        2: 
        3: (library
        4:   (public_name notty)
        5:   (synopsis "Declaring terminals")
        6:   (libraries uutf)
        7:   (wrapped false)
        8:   (modules notty notty_grapheme_cluster notty_uucp notty_uucp_data)
        9:   (private_modules notty_grapheme_cluster notty_uucp notty_uucp_data))
       10: 
       11: (library
       12:   (public_name notty.top)
       13:   (synopsis "Notty toplevel support")
       14:   (name notty_top)
       15:   (wrapped false)
       16:   (modules notty_top)
       17:   (preprocess (action (run %{bin:cppo} -V OCAML:%{ocaml_version} %{input-file})))
       18:   (libraries notty compiler-libs.toplevel))
       19: 
       20: (install
       21:   (section lib)
       22:   (files (notty_top_init.ml as top/notty_top_init.ml)))
Added regular file ../notty/src/no-uucp/README.md:
        1: Cannibalized bits of Uucp:
        2: 
        3: - `Notty_uucp_data` is generated from an actual Uucp installation.
        4: - `Notty_uucp` uses it to provide the few Unicode properties that Notty needs.
        5: - `Notty_grapheme_cluster` is `Grapheme_cluster` from Uuseg, adapted to use the
        6:   above.
        7: 
        8: Compiled size of these is on the order of 70K. Uucp is presently a monolithic 10M.
        9: 
       10: The idea is to remove these in favor of the actual Uucp/Uuseg, as soon as it
       11: becomes possible to depend only on the necessary parts of Uucp.
       12: 
       13: Uucp and Uuseg are Copyright (c) 2014 Daniel C. Bünzli.
Added regular file ../notty/src/no-uucp/notty_grapheme_cluster.ml:
        1: (*---------------------------------------------------------------------------
        2:    Copyright (c) 2014 Daniel C. Bünzli. All rights reserved.
        3:    Distributed under the ISC license, see terms at the end of the file.
        4:    %%NAME%% %%VERSION%%
        5:   ---------------------------------------------------------------------------*)
        6: 
        7: (* These are the rules as found in [1], with property values aliases [2]
        8:    substituted.
        9: 
       10:    GB1.               sot ÷ Any
       11:    GB2.               Any ÷ eot
       12:    GB3.                CR × LF
       13:    GB4.        (CN|CR|LF) ÷
       14:    GB5.                   ÷ (CN|CR|LF)
       15:    GB6.                 L × (L|V|LV|LVT)
       16:    GB7.            (LV|V) × (V|T)
       17:    GB8.           (LVT|T) × T
       18:    GB9.                   × (EX|ZWJ)
       19:    GB9a.                  × SM
       20:    GB9b.               PP ×
       21:    GB10. (v10.0.0) (EB|EBG) EX* × EM
       22:    GB11. (v10.0.0)          ZWJ × (GAZ|EBG)
       23:    GB12.  sot (RI RI)* RI × RI
       24:    GB13.   [^RI] (RI RI)* × RI
       25:    GB999.             Any ÷ Any
       26: 
       27:    [1]: http://www.unicode.org/reports/tr29/#Grapheme_Cluster_Boundaries
       28:    [2]: http://www.unicode.org/Public/7.0.0/ucd/PropertyValueAliases.txt
       29:    [3]: http://www.unicode.org/Public/7.0.0/ucd/auxiliary/GraphemeBreakTest.html
       30: 
       31:    By the structure of the rules we see that grapheme clusters
       32:    boundaries can *mostly* be determined by simply looking at the
       33:    grapheme cluster break property value of the character on the left
       34:    and on the right of a boundary. The exceptions are GB10 and GB12-13
       35:    which are handled specially by enriching the segmenter state in
       36:    a horribly ad-hoc fashion. *)
       37: 
       38: type ret = [ `Await | `Boundary | `End | `Uchar of Uchar.t ]
       39: 
       40: type gcb =
       41:   | CN | CR | EX | EB | EBG | EM | GAZ | L | LF | LV | LVT | PP | RI
       42:   | SM | T | V | XX | ZWJ | Sot
       43: 
       44: (* WARNING. The indexes used here need to be synchronized with those
       45:    assigned by uucp for Uucp.Break.Low.grapheme_cluster. *)
       46: 
       47: let byte_to_gcb =
       48:   [| CN; CR; EX; EB; EBG; EM; GAZ; L; LF; LV; LVT; PP; RI;
       49:      SM; T; V; XX; ZWJ; |]
       50: 
       51: let gcb u = byte_to_gcb.(Notty_uucp.grapheme_cluster_boundary u)
       52: 
       53: type state =
       54: | Fill  (* get next uchar to decide boundary. *)
       55: | Flush (* an uchar is buffered, client needs to get it out with `Await. *)
       56: | End   (* `End was added. *)
       57: 
       58: type t =
       59:   { mutable state : state;                                 (* current state. *)
       60:     mutable left : gcb;            (* break property value left of boundary. *)
       61:     mutable odd_ri : bool;                  (* odd number of RI on the left. *)
       62:     mutable emoji_seq : bool;               (* (EB|EBG) Extend* on the left. *)
       63:     mutable buf : [ `Uchar of Uchar.t ] }                 (* bufferized add. *)
       64: 
       65: let nul_buf = `Uchar (Uchar.unsafe_of_int 0x0000)
       66: 
       67: let create () =
       68:   { state = Fill; left = Sot;
       69:     odd_ri = false; emoji_seq = false;
       70:     buf = nul_buf (* overwritten *); }
       71: 
       72: let break s right = match s.left, right with
       73: | (* GB1 *)   Sot, _ -> true
       74:   (* GB2 is handled by `End *)
       75: | (* GB3 *)   CR, LF -> false
       76: | (* GB4 *)   (CN|CR|LF), _ -> true
       77: | (* GB5 *)   _, (CN|CR|LF) -> true
       78: | (* GB6 *)   L, (L|V|LV|LVT) -> false
       79: | (* GB7 *)   (LV|V), (V|T) -> false
       80: | (* GB8 *)   (LVT|T), T -> false
       81: | (* GB9+a *) _, (EX|ZWJ|SM) -> false
       82: | (* GB9b *)  PP, _ -> false
       83: | (* GB10 *)  _, EM when s.emoji_seq -> false
       84: | (* GB11 *)  ZWJ, (GAZ|EBG) -> false
       85: | (* GB12+13 *) RI, RI when s.odd_ri -> false
       86: | (* GB999 *) _, _ -> true
       87: 
       88: let update_left s right =
       89:   s.left <- right;
       90:   match s.left with
       91:   | EX -> (* keep s.emoji_seq as is *) s.odd_ri <- false
       92:   | EB | EBG -> s.emoji_seq <- true; s.odd_ri <- false
       93:   | RI -> s.emoji_seq <- false; s.odd_ri <- not s.odd_ri
       94:   | _ -> s.emoji_seq <- false; s.odd_ri <- false
       95: 
       96: let add s = function
       97: | `Uchar u as add ->
       98:     begin match s.state with
       99:     | Fill ->
      100:         let right = gcb u in
      101:         let break = break s right in
      102:         update_left s right;
      103:         if not break then add else
      104:         (s.state <- Flush; s.buf <- add; `Boundary)
      105:     | Flush | End -> assert false
      106:     end
      107: | `Await ->
      108:     begin match s.state with
      109:     | Flush -> s.state <- Fill; (s.buf :> ret)
      110:     | End -> `End
      111:     | Fill -> `Await
      112:     end
      113: | `End ->
      114:     begin match s.state with
      115:     | Fill -> s.state <- End; if s.left = Sot then `End else `Boundary
      116:     | Flush | End -> assert false
      117:     end
      118: 
      119: (*---------------------------------------------------------------------------
      120:    Copyright (c) 2014 Daniel C. Bünzli
      121: 
      122:    Permission to use, copy, modify, and/or distribute this software for any
      123:    purpose with or without fee is hereby granted, provided that the above
      124:    copyright notice and this permission notice appear in all copies.
      125: 
      126:    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
      127:    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
      128:    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
      129:    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
      130:    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
      131:    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
      132:    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
      133:   ---------------------------------------------------------------------------*)
Added regular file ../notty/src/no-uucp/notty_grapheme_cluster.mli:
        1: (*---------------------------------------------------------------------------
        2:    Copyright (c) 2014 Daniel C. Bünzli. All rights reserved.
        3:    Distributed under the ISC license, see terms at the end of the file.
        4:    %%NAME%% %%VERSION%%
        5:   ---------------------------------------------------------------------------*)
        6: 
        7: type ret = [ `Await | `Boundary | `End | `Uchar of Uchar.t ]
        8: 
        9: type t
       10: val create : unit -> t
       11: val add : t -> [ `Await | `End | `Uchar of Uchar.t ] -> ret
       12: 
       13: (*---------------------------------------------------------------------------
       14:    Copyright (c) 2014 Daniel C. Bünzli
       15: 
       16:    Permission to use, copy, modify, and/or distribute this software for any
       17:    purpose with or without fee is hereby granted, provided that the above
       18:    copyright notice and this permission notice appear in all copies.
       19: 
       20:    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
       21:    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
       22:    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
       23:    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
       24:    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
       25:    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
       26:    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
       27:   ---------------------------------------------------------------------------*)
Added regular file ../notty/src/no-uucp/notty_uucp.ml:
        1: (* Copyright (c) 2020 David Kaloper Meršinjak. All rights reserved.
        2:    See LICENSE.md. *)
        3: 
        4: (* Unpacked interval lookup table. *)
        5: let find_i ~def k (xs, _, _ as tab) =
        6:   let rec go i j (los, his, vs as tab) (k: int) def =
        7:     if i > j then def else
        8:     let x = (i + j) / 2 in
        9:     if k < Array.unsafe_get los x then go i (x - 1) tab k def else
       10:     if k > Array.unsafe_get his x then go (x + 1) j tab k def else
       11:       Array.unsafe_get vs x in
       12:   go 0 (Array.length xs - 1) tab k def
       13: 
       14: (* 12-6-6-bit (0xfff-0x3f-0x3f) trie, 3 levels, array-array-string.
       15:    Root is variable; lower levels are either empty or complete. *)
       16: let find_t ~def k tab =
       17:   let k = if k > 0xd7ff then k - 0x800 else k in (* Pack to continuous range. *)
       18:   let b0 = (k lsr 12) land 0xfff in
       19:   if Array.length tab <= b0 then def else
       20:   match Array.unsafe_get tab b0 with
       21:   | [||] -> def
       22:   | arr -> match Array.unsafe_get arr ((k lsr 6) land 0x3f) with
       23:     | "" -> def
       24:     | str -> String.unsafe_get str (k land 0x3f) |> Char.code
       25: 
       26: (* We catch w = -1 and default to w = 1 to minimize the table. *)
       27: let tty_width_hint u = match Uchar.to_int u with
       28: | 0 -> 0
       29: | u when u <= 0x001F || 0x007F <= u && u <= 0x009F -> -1
       30: | u when u <= 0x02ff -> 1
       31: | u -> find_i ~def:1 u Notty_uucp_data.tty_width_hint
       32: 
       33: let grapheme_cluster_boundary u =
       34:   find_t ~def:16 (Uchar.to_int u) Notty_uucp_data.grapheme_cluster_boundary
       35: 
       36: (* let check () = *)
       37: (*   let pp_u ppf u = Format.fprintf ppf "u+%04x" (Uchar.to_int u) in *)
       38: (*   let rec go i u = *)
       39: (*     let w1 = tty_width_hint u *)
       40: (*     and w2 = Uucp.Break.tty_width_hint u in *)
       41: (*     if w1 <> w2 then Format.printf "w: %a here: %d there: %d@." pp_u u w1 w2; *)
       42: (*     let gc1 = grapheme_cluster_boundary u *)
       43: (*     and gc2 = Uucp.Break.Low.grapheme_cluster u in *)
       44: (*     if gc1 <> gc2 then Format.printf "gc: %a here: %d there: %d@." pp_u u gc1 gc2; *)
       45: (*     if u = Uchar.max then i else go (i + 1) (Uchar.succ u) in *)
       46: (*   let n = go 1 Uchar.min in *)
       47: (*   Format.printf "Checked equality for %d code points.@." n *)
       48: 
Added regular file ../notty/src/no-uucp/notty_uucp.mli:
        1: (* Copyright (c) 2020 David Kaloper Meršinjak. All rights reserved.
        2:    See LICENSE.md. *)
        3: 
        4: (* This is a local copy of the (very few) relevant [uucp] properties. *)
        5: 
        6: val tty_width_hint : Uchar.t -> int
        7: (* [Uucp.Break.tty_width_hint]. *)
        8: 
        9: val grapheme_cluster_boundary : Uchar.t -> int
       10: (* [Uucp.Break.Low.grapheme_cluster]. *)
       11: 
       12: (* val check : unit -> unit *)
       13: 
Added regular file ../notty/src/no-uucp/notty_uucp_data.ml:
        1: (* Do not edit.
        2:  *
        3:  * This module contains select unicode properties extracted from Uucp,
        4:  * using `./support/gen_unicode_props.ml`.
        5:  *
        6:  * Unicode version 13.0.0.
        7:  *)
        8: 
        9: 
       10: let tty_width_hint =
       11:   ([|0x0000; 0x0300; 0x0483; 0x0591; 0x05bf; 0x05c1; 0x05c4; 0x05c7; 0x0600;
       12:      0x0610; 0x061c; 0x064b; 0x0670; 0x06d6; 0x06df; 0x06e7; 0x06ea; 0x070f;
       13:      0x0711; 0x0730; 0x07a6; 0x07eb; 0x07fd; 0x0816; 0x081b; 0x0825; 0x0829;
       14:      0x0859; 0x08d3; 0x093a; 0x093c; 0x0941; 0x094d; 0x0951; 0x0962; 0x0981;
       15:      0x09bc; 0x09c1; 0x09cd; 0x09e2; 0x09fe; 0x0a01; 0x0a3c; 0x0a41; 0x0a47;
       16:      0x0a4b; 0x0a51; 0x0a70; 0x0a75; 0x0a81; 0x0abc; 0x0ac1; 0x0ac7; 0x0acd;
       17:      0x0ae2; 0x0afa; 0x0b01; 0x0b3c; 0x0b3f; 0x0b41; 0x0b4d; 0x0b55; 0x0b62;
       18:      0x0b82; 0x0bc0; 0x0bcd; 0x0c00; 0x0c04; 0x0c3e; 0x0c46; 0x0c4a; 0x0c55;
       19:      0x0c62; 0x0c81; 0x0cbc; 0x0cbf; 0x0cc6; 0x0ccc; 0x0ce2; 0x0d00; 0x0d3b;
       20:      0x0d41; 0x0d4d; 0x0d62; 0x0d81; 0x0dca; 0x0dd2; 0x0dd6; 0x0e31; 0x0e34;
       21:      0x0e47; 0x0eb1; 0x0eb4; 0x0ec8; 0x0f18; 0x0f35; 0x0f37; 0x0f39; 0x0f71;
       22:      0x0f80; 0x0f86; 0x0f8d; 0x0f99; 0x0fc6; 0x102d; 0x1032; 0x1039; 0x103d;
       23:      0x1058; 0x105e; 0x1071; 0x1082; 0x1085; 0x108d; 0x109d; 0x1100; 0x135d;
       24:      0x1712; 0x1732; 0x1752; 0x1772; 0x17b4; 0x17b7; 0x17c6; 0x17c9; 0x17dd;
       25:      0x180b; 0x1885; 0x18a9; 0x1920; 0x1927; 0x1932; 0x1939; 0x1a17; 0x1a1b;
       26:      0x1a56; 0x1a58; 0x1a60; 0x1a62; 0x1a65; 0x1a73; 0x1a7f; 0x1ab0; 0x1b00;
       27:      0x1b34; 0x1b36; 0x1b3c; 0x1b42; 0x1b6b; 0x1b80; 0x1ba2; 0x1ba8; 0x1bab;
       28:      0x1be6; 0x1be8; 0x1bed; 0x1bef; 0x1c2c; 0x1c36; 0x1cd0; 0x1cd4; 0x1ce2;
       29:      0x1ced; 0x1cf4; 0x1cf8; 0x1dc0; 0x1dfb; 0x200b; 0x202a; 0x2060; 0x2066;
       30:      0x20d0; 0x231a; 0x2329; 0x23e9; 0x23f0; 0x23f3; 0x25fd; 0x2614; 0x2648;
       31:      0x267f; 0x2693; 0x26a1; 0x26aa; 0x26bd; 0x26c4; 0x26ce; 0x26d4; 0x26ea;
       32:      0x26f2; 0x26f5; 0x26fa; 0x26fd; 0x2705; 0x270a; 0x2728; 0x274c; 0x274e;
       33:      0x2753; 0x2757; 0x2795; 0x27b0; 0x27bf; 0x2b1b; 0x2b50; 0x2b55; 0x2cef;
       34:      0x2d7f; 0x2de0; 0x2e80; 0x2e9b; 0x2f00; 0x2ff0; 0x3000; 0x302a; 0x302e;
       35:      0x3041; 0x3099; 0x309b; 0x3105; 0x3131; 0x3190; 0x31f0; 0x3220; 0x3250;
       36:      0x4e00; 0xa490; 0xa66f; 0xa674; 0xa69e; 0xa6f0; 0xa802; 0xa806; 0xa80b;
       37:      0xa825; 0xa82c; 0xa8c4; 0xa8e0; 0xa8ff; 0xa926; 0xa947; 0xa960; 0xa980;
       38:      0xa9b3; 0xa9b6; 0xa9bc; 0xa9e5; 0xaa29; 0xaa31; 0xaa35; 0xaa43; 0xaa4c;
       39:      0xaa7c; 0xaab0; 0xaab2; 0xaab7; 0xaabe; 0xaac1; 0xaaec; 0xaaf6; 0xabe5;
       40:      0xabe8; 0xabed; 0xac00; 0xf900; 0xfb1e; 0xfe00; 0xfe10; 0xfe20; 0xfe30;
       41:      0xfe54; 0xfe68; 0xfeff; 0xff01; 0xffe0; 0xfff9; 0x101fd; 0x102e0;
       42:      0x10376; 0x10a01; 0x10a05; 0x10a0c; 0x10a38; 0x10a3f; 0x10ae5; 0x10d24;
       43:      0x10eab; 0x10f46; 0x11001; 0x11038; 0x1107f; 0x110b3; 0x110b9; 0x110bd;
       44:      0x110cd; 0x11100; 0x11127; 0x1112d; 0x11173; 0x11180; 0x111b6; 0x111c9;
       45:      0x111cf; 0x1122f; 0x11234; 0x11236; 0x1123e; 0x112df; 0x112e3; 0x11300;
       46:      0x1133b; 0x11340; 0x11366; 0x11370; 0x11438; 0x11442; 0x11446; 0x1145e;
       47:      0x114b3; 0x114ba; 0x114bf; 0x114c2; 0x115b2; 0x115bc; 0x115bf; 0x115dc;
       48:      0x11633; 0x1163d; 0x1163f; 0x116ab; 0x116ad; 0x116b0; 0x116b7; 0x1171d;
       49:      0x11722; 0x11727; 0x1182f; 0x11839; 0x1193b; 0x1193e; 0x11943; 0x119d4;
       50:      0x119da; 0x119e0; 0x11a01; 0x11a33; 0x11a3b; 0x11a47; 0x11a51; 0x11a59;
       51:      0x11a8a; 0x11a98; 0x11c30; 0x11c38; 0x11c3f; 0x11c92; 0x11caa; 0x11cb2;
       52:      0x11cb5; 0x11d31; 0x11d3a; 0x11d3c; 0x11d3f; 0x11d47; 0x11d90; 0x11d95;
       53:      0x11d97; 0x11ef3; 0x13430; 0x16af0; 0x16b30; 0x16f4f; 0x16f8f; 0x16fe0;
       54:      0x16fe4; 0x16ff0; 0x17000; 0x18800; 0x18d00; 0x1b000; 0x1b150; 0x1b164;
       55:      0x1b170; 0x1bc9d; 0x1bca0; 0x1d167; 0x1d173; 0x1d185; 0x1d1aa; 0x1d242;
       56:      0x1da00; 0x1da3b; 0x1da75; 0x1da84; 0x1da9b; 0x1daa1; 0x1e000; 0x1e008;
       57:      0x1e01b; 0x1e023; 0x1e026; 0x1e130; 0x1e2ec; 0x1e8d0; 0x1e944; 0x1f004;
       58:      0x1f0cf; 0x1f18e; 0x1f191; 0x1f200; 0x1f210; 0x1f240; 0x1f250; 0x1f260;
       59:      0x1f300; 0x1f32d; 0x1f337; 0x1f37e; 0x1f3a0; 0x1f3cf; 0x1f3e0; 0x1f3f4;
       60:      0x1f3f8; 0x1f440; 0x1f442; 0x1f4ff; 0x1f54b; 0x1f550; 0x1f57a; 0x1f595;
       61:      0x1f5a4; 0x1f5fb; 0x1f680; 0x1f6cc; 0x1f6d0; 0x1f6d5; 0x1f6eb; 0x1f6f4;
       62:      0x1f7e0; 0x1f90c; 0x1f93c; 0x1f947; 0x1f97a; 0x1f9cd; 0x1fa70; 0x1fa78;
       63:      0x1fa80; 0x1fa90; 0x1fab0; 0x1fac0; 0x1fad0; 0x20000; 0x30000; 0xe0001;
       64:      0xe0020; 0xe0100|],
       65:    [|0x0000; 0x036f; 0x0489; 0x05bd; 0x05bf; 0x05c2; 0x05c5; 0x05c7; 0x0605;
       66:      0x061a; 0x061c; 0x065f; 0x0670; 0x06dd; 0x06e4; 0x06e8; 0x06ed; 0x070f;
       67:      0x0711; 0x074a; 0x07b0; 0x07f3; 0x07fd; 0x0819; 0x0823; 0x0827; 0x082d;
       68:      0x085b; 0x0902; 0x093a; 0x093c; 0x0948; 0x094d; 0x0957; 0x0963; 0x0981;
       69:      0x09bc; 0x09c4; 0x09cd; 0x09e3; 0x09fe; 0x0a02; 0x0a3c; 0x0a42; 0x0a48;
       70:      0x0a4d; 0x0a51; 0x0a71; 0x0a75; 0x0a82; 0x0abc; 0x0ac5; 0x0ac8; 0x0acd;
       71:      0x0ae3; 0x0aff; 0x0b01; 0x0b3c; 0x0b3f; 0x0b44; 0x0b4d; 0x0b56; 0x0b63;
       72:      0x0b82; 0x0bc0; 0x0bcd; 0x0c00; 0x0c04; 0x0c40; 0x0c48; 0x0c4d; 0x0c56;
       73:      0x0c63; 0x0c81; 0x0cbc; 0x0cbf; 0x0cc6; 0x0ccd; 0x0ce3; 0x0d01; 0x0d3c;
       74:      0x0d44; 0x0d4d; 0x0d63; 0x0d81; 0x0dca; 0x0dd4; 0x0dd6; 0x0e31; 0x0e3a;
       75:      0x0e4e; 0x0eb1; 0x0ebc; 0x0ecd; 0x0f19; 0x0f35; 0x0f37; 0x0f39; 0x0f7e;
       76:      0x0f84; 0x0f87; 0x0f97; 0x0fbc; 0x0fc6; 0x1030; 0x1037; 0x103a; 0x103e;
       77:      0x1059; 0x1060; 0x1074; 0x1082; 0x1086; 0x108d; 0x109d; 0x115f; 0x135f;
       78:      0x1714; 0x1734; 0x1753; 0x1773; 0x17b5; 0x17bd; 0x17c6; 0x17d3; 0x17dd;
       79:      0x180e; 0x1886; 0x18a9; 0x1922; 0x1928; 0x1932; 0x193b; 0x1a18; 0x1a1b;
       80:      0x1a56; 0x1a5e; 0x1a60; 0x1a62; 0x1a6c; 0x1a7c; 0x1a7f; 0x1ac0; 0x1b03;
       81:      0x1b34; 0x1b3a; 0x1b3c; 0x1b42; 0x1b73; 0x1b81; 0x1ba5; 0x1ba9; 0x1bad;
       82:      0x1be6; 0x1be9; 0x1bed; 0x1bf1; 0x1c33; 0x1c37; 0x1cd2; 0x1ce0; 0x1ce8;
       83:      0x1ced; 0x1cf4; 0x1cf9; 0x1df9; 0x1dff; 0x200f; 0x202e; 0x2064; 0x206f;
       84:      0x20f0; 0x231b; 0x232a; 0x23ec; 0x23f0; 0x23f3; 0x25fe; 0x2615; 0x2653;
       85:      0x267f; 0x2693; 0x26a1; 0x26ab; 0x26be; 0x26c5; 0x26ce; 0x26d4; 0x26ea;
       86:      0x26f3; 0x26f5; 0x26fa; 0x26fd; 0x2705; 0x270b; 0x2728; 0x274c; 0x274e;
       87:      0x2755; 0x2757; 0x2797; 0x27b0; 0x27bf; 0x2b1c; 0x2b50; 0x2b55; 0x2cf1;
       88:      0x2d7f; 0x2dff; 0x2e99; 0x2ef3; 0x2fd5; 0x2ffb; 0x3029; 0x302d; 0x303e;
       89:      0x3096; 0x309a; 0x30ff; 0x312f; 0x318e; 0x31e3; 0x321e; 0x3247; 0x4dbf;
       90:      0xa48c; 0xa4c6; 0xa672; 0xa67d; 0xa69f; 0xa6f1; 0xa802; 0xa806; 0xa80b;
       91:      0xa826; 0xa82c; 0xa8c5; 0xa8f1; 0xa8ff; 0xa92d; 0xa951; 0xa97c; 0xa982;
       92:      0xa9b3; 0xa9b9; 0xa9bd; 0xa9e5; 0xaa2e; 0xaa32; 0xaa36; 0xaa43; 0xaa4c;
       93:      0xaa7c; 0xaab0; 0xaab4; 0xaab8; 0xaabf; 0xaac1; 0xaaed; 0xaaf6; 0xabe5;
       94:      0xabe8; 0xabed; 0xd7a3; 0xfaff; 0xfb1e; 0xfe0f; 0xfe19; 0xfe2f; 0xfe52;
       95:      0xfe66; 0xfe6b; 0xfeff; 0xff60; 0xffe6; 0xfffb; 0x101fd; 0x102e0;
       96:      0x1037a; 0x10a03; 0x10a06; 0x10a0f; 0x10a3a; 0x10a3f; 0x10ae6; 0x10d27;
       97:      0x10eac; 0x10f50; 0x11001; 0x11046; 0x11081; 0x110b6; 0x110ba; 0x110bd;
       98:      0x110cd; 0x11102; 0x1112b; 0x11134; 0x11173; 0x11181; 0x111be; 0x111cc;
       99:      0x111cf; 0x11231; 0x11234; 0x11237; 0x1123e; 0x112df; 0x112ea; 0x11301;
      100:      0x1133c; 0x11340; 0x1136c; 0x11374; 0x1143f; 0x11444; 0x11446; 0x1145e;
      101:      0x114b8; 0x114ba; 0x114c0; 0x114c3; 0x115b5; 0x115bd; 0x115c0; 0x115dd;
      102:      0x1163a; 0x1163d; 0x11640; 0x116ab; 0x116ad; 0x116b5; 0x116b7; 0x1171f;
      103:      0x11725; 0x1172b; 0x11837; 0x1183a; 0x1193c; 0x1193e; 0x11943; 0x119d7;
      104:      0x119db; 0x119e0; 0x11a0a; 0x11a38; 0x11a3e; 0x11a47; 0x11a56; 0x11a5b;
      105:      0x11a96; 0x11a99; 0x11c36; 0x11c3d; 0x11c3f; 0x11ca7; 0x11cb0; 0x11cb3;
      106:      0x11cb6; 0x11d36; 0x11d3a; 0x11d3d; 0x11d45; 0x11d47; 0x11d91; 0x11d95;
      107:      0x11d97; 0x11ef4; 0x13438; 0x16af4; 0x16b36; 0x16f4f; 0x16f92; 0x16fe3;
      108:      0x16fe4; 0x16ff1; 0x187f7; 0x18cd5; 0x18d08; 0x1b11e; 0x1b152; 0x1b167;
      109:      0x1b2fb; 0x1bc9e; 0x1bca3; 0x1d169; 0x1d182; 0x1d18b; 0x1d1ad; 0x1d244;
      110:      0x1da36; 0x1da6c; 0x1da75; 0x1da84; 0x1da9f; 0x1daaf; 0x1e006; 0x1e018;
      111:      0x1e021; 0x1e024; 0x1e02a; 0x1e136; 0x1e2ef; 0x1e8d6; 0x1e94a; 0x1f004;
      112:      0x1f0cf; 0x1f18e; 0x1f19a; 0x1f202; 0x1f23b; 0x1f248; 0x1f251; 0x1f265;
      113:      0x1f320; 0x1f335; 0x1f37c; 0x1f393; 0x1f3ca; 0x1f3d3; 0x1f3f0; 0x1f3f4;
      114:      0x1f43e; 0x1f440; 0x1f4fc; 0x1f53d; 0x1f54e; 0x1f567; 0x1f57a; 0x1f596;
      115:      0x1f5a4; 0x1f64f; 0x1f6c5; 0x1f6cc; 0x1f6d2; 0x1f6d7; 0x1f6ec; 0x1f6fc;
      116:      0x1f7eb; 0x1f93a; 0x1f945; 0x1f978; 0x1f9cb; 0x1f9ff; 0x1fa74; 0x1fa7a;
      117:      0x1fa86; 0x1faa8; 0x1fab6; 0x1fac2; 0x1fad6; 0x2fffd; 0x3fffd; 0xe0001;
      118:      0xe007f; 0xe01ef|],
      119:    [|0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0;
      120:      0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0;
      121:      0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0;
      122:      0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0;
      123:      0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 2; 0; 0; 0; 0;
      124:      0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0;
      125:      0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0;
      126:      0; 0; 0; 0; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2;
      127:      2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 0; 0; 0; 2; 2; 2; 2; 2; 0; 2;
      128:      2; 0; 2; 2; 2; 2; 2; 2; 2; 2; 2; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0;
      129:      0; 2; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 2;
      130:      2; 0; 0; 2; 0; 2; 2; 2; 0; 2; 2; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0;
      131:      0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0;
      132:      0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0;
      133:      0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0;
      134:      0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 2; 0; 2; 2; 2; 2; 2; 2; 2; 2; 0;
      135:      0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 2; 2; 2;
      136:      2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2;
      137:      2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 0; 0; 0|])
      138: 
      139: let s000 = ""
      140: let s001 = "\000\000\000\000\000\000\000\000\000\000\b\000\000\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
      141: let s002 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\000"
      142: let s003 = "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\016\016\016\016\016\016\016\016\016\016\016\016\016\000\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
      143: let s004 = "\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002"
      144: let s005 = "\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
      145: let s006 = "\016\016\016\002\002\002\002\002\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
      146: let s007 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\016\002"
      147: let s008 = "\016\002\002\016\002\002\016\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
      148: let s009 = "\011\011\011\011\011\011\016\016\016\016\016\016\016\016\016\016\002\002\002\002\002\002\002\002\002\002\002\016\000\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
      149: let s010 = "\016\016\016\016\016\016\016\016\016\016\016\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
      150: let s011 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\002\002\002\002\002\011\016\002\002\002\002\002\002\016\016\002\002\016\002\002\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
      151: let s012 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\011\016\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002"
      152: let s013 = "\002\002\002\002\002\002\002\002\002\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
      153: let s014 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\002\002\002\002\002\002\002\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
      154: let s015 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\002\002\002\002\002\002\002\016\016\016\016\016\016\016\016\016\002\016\016"
      155: let s016 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\002\002\016\002\002\002\002\002\002\002\002\002\016\002\002\002\016\002\002\002\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
      156: let s017 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
      157: let s018 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\011\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002"
      158: let s019 = "\002\002\002\r\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\r\002\016\r\r"
      159: let s020 = "\r\002\002\002\002\002\002\002\002\r\r\r\r\002\r\r\016\002\002\002\002\002\002\002\016\016\016\016\016\016\016\016\016\016\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
      160: let s021 = "\016\002\r\r\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\016\002\r"
      161: let s022 = "\r\002\002\002\002\016\016\r\r\016\016\r\r\002\016\016\016\016\016\016\016\016\016\002\016\016\016\016\016\016\016\016\016\016\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\016"
      162: let s023 = "\016\002\002\r\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\016\r\r"
      163: let s024 = "\r\002\002\016\016\016\016\002\002\016\016\002\002\002\016\016\016\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\016\016\016\002\016\016\016\016\016\016\016\016\016\016"
      164: let s025 = "\r\002\002\002\002\002\016\002\002\r\016\r\r\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\002\002\002\002"
      165: let s026 = "\016\002\r\r\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\016\002\002"
      166: let s027 = "\r\002\002\002\002\016\016\r\r\016\016\r\r\002\016\016\016\016\016\016\016\002\002\002\016\016\016\016\016\016\016\016\016\016\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
      167: let s028 = "\016\016\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\r"
      168: let s029 = "\002\r\r\016\016\016\r\r\r\016\r\r\r\002\016\016\016\016\016\016\016\016\016\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
      169: let s030 = "\002\r\r\r\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002"
      170: let s031 = "\002\r\r\r\r\016\002\002\002\016\002\002\002\002\016\016\016\016\016\016\016\002\002\016\016\016\016\016\016\016\016\016\016\016\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
      171: let s032 = "\016\002\r\r\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\016\r\002"
      172: let s033 = "\r\r\002\r\r\016\002\r\r\016\r\r\002\002\016\016\016\016\016\016\016\002\002\016\016\016\016\016\016\016\016\016\016\016\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
      173: let s034 = "\002\002\r\r\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\016\002\r"
      174: let s035 = "\r\002\002\002\002\016\r\r\r\016\r\r\r\002\011\016\016\016\016\016\016\016\016\002\016\016\016\016\016\016\016\016\016\016\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
      175: let s036 = "\016\002\r\r\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
      176: let s037 = "\016\016\016\016\016\016\016\016\016\016\002\016\016\016\016\002\r\r\002\002\002\016\002\016\r\r\r\r\r\r\r\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\r\r\016\016\016\016\016\016\016\016\016\016\016\016"
      177: let s038 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\016\r\002\002\002\002\002\002\002\016\016\016\016\016"
      178: let s039 = "\016\016\016\016\016\016\016\002\002\002\002\002\002\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
      179: let s040 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\016\r\002\002\002\002\002\002\002\002\002\016\016\016"
      180: let s041 = "\016\016\016\016\016\016\016\016\002\002\002\002\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
      181: let s042 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\016\002\016\002\016\016\016\016\r\r"
      182: let s043 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\002\002\002\002\002\002\002\002\002\002\002\002\r"
      183: let s044 = "\002\002\002\002\002\016\002\002\016\016\016\016\016\002\002\002\002\002\002\002\002\002\002\002\016\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\016\016\016"
      184: let s045 = "\016\016\016\016\016\016\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
      185: let s046 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\002\002\r\002\002\002\002\002\002\016\002\002\r\r\002\002\016"
      186: let s047 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\r\r\002\002\016\016\016\016\002\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\002\002\016\016\016\016\016\016\016\016\016\016\016"
      187: let s048 = "\016\016\002\016\r\002\002\016\016\016\016\016\016\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
      188: let s049 = "\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007"
      189: let s050 = "\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\015\015\015\015\015\015\015\015\015\015\015\015\015\015\015\015\015\015\015\015\015\015\015\015\015\015\015\015\015\015\015\015"
      190: let s051 = "\015\015\015\015\015\015\015\015\015\015\015\015\015\015\015\015\015\015\015\015\015\015\015\015\015\015\015\015\015\015\015\015\015\015\015\015\015\015\015\015\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014"
      191: let s052 = "\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014"
      192: let s053 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
      193: let s054 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\002\016\016\016\016\016\016\016\016\016\016\016"
      194: let s055 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\016\016\016\016\016\016\016\016\016\016\016\016"
      195: let s056 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\r\002\002\002\002\002\002\002\r\r"
      196: let s057 = "\r\r\r\r\r\r\002\r\r\002\002\002\002\002\002\002\002\002\002\002\016\016\016\016\016\016\016\016\016\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
      197: let s058 = "\016\016\016\016\016\016\016\016\016\016\016\002\002\002\000\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
      198: let s059 = "\016\016\016\016\016\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
      199: let s060 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\002\r\r\r\r\002\002\r\r\r\016\016\016\016\r\r\002\r\r\r\r\r\r\002\002\002\016\016\016\016"
      200: let s061 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\r\r\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
      201: let s062 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\r\002\r\002\002\002\002\002\002\002\016\002\016\002\016\016\002\002\002\002\002\002\002\002\r\r\r\r\r\r\002\002\002\002\002\002\002\002\002\002\016\016\002"
      202: let s063 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002"
      203: let s064 = "\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
      204: let s065 = "\002\002\002\002\r\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\002\002\002\002\002\r\002\r\r\r"
      205: let s066 = "\r\r\002\r\r\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\002\002\002\002\002\002\002\016\016\016\016\016\016\016\016\016\016\016\016"
      206: let s067 = "\002\002\r\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\r\002\002\002\002\r\r\002\002\r\002\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
      207: let s068 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\r\002\002\r\r\r\002\r\002\002\002\r\r\016\016\016\016\016\016\016\016\016\016\016\016"
      208: let s069 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\r\r\r\r\r\r\r\r\002\002\002\002\002\002\002\002\r\r\002\002\016\016\016\016\016\016\016\016"
      209: let s070 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\002\016\002\002\002\002\002\002\002\002\002\002\002\002\002\r\002\002\002\002\002\002\002\016\016\016\016\002\016\016\016\016\016\016\002\016\016\r\002\002\016\016\016\016\016\016"
      210: let s071 = "\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\016\002\002\002\002\002"
      211: let s072 = "\016\016\016\016\016\016\016\016\016\016\016\000\002\017\000\000\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\000\000\000\000\000\000\000\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
      212: let s073 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
      213: let s074 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
      214: let s075 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
      215: let s076 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002"
      216: let s077 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002"
      217: let s078 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\002\002\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
      218: let s079 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
      219: let s080 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\002\002\016\002\002\002\002\002\002\002\002\002\002\016\016"
      220: let s081 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
      221: let s082 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
      222: let s083 = "\016\016\002\016\016\016\002\016\016\016\016\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\r\r\002\002\r\016\016\016\016\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
      223: let s084 = "\r\r\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\r\r\r\r\r\r\r\r\r\r\r\r"
      224: let s085 = "\r\r\r\r\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\002"
      225: let s086 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\002\002\002\002\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
      226: let s087 = "\016\016\016\016\016\016\016\002\002\002\002\002\002\002\002\002\002\002\r\r\016\016\016\016\016\016\016\016\016\016\016\016\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\016\016\016"
      227: let s088 = "\002\002\002\r\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\r\r\002\002\002\002\r\r\002\002\r\r"
      228: let s089 = "\r\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
      229: let s090 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\002\002\002\002\r\r\002\002\r\r\002\002\016\016\016\016\016\016\016\016\016"
      230: let s091 = "\016\016\016\002\016\016\016\016\016\016\016\016\002\r\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\016\016\016"
      231: let s092 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\016\002\002\002\016\016\002\002\016\016\016\016\016\002\002"
      232: let s093 = "\016\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\r\002\002\r\r\016\016\016\016\016\r\002\016\016\016\016\016\016\016\016\016"
      233: let s094 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\r\r\002\r\r\002\r\r\016\r\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
      234: let s095 = "\t\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\t\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\t\n\n\n\n\n\n\n"
      235: let s096 = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\t\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\t\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
      236: let s097 = "\n\n\n\n\n\n\n\n\n\n\n\n\t\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\t\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
      237: let s098 = "\n\n\n\n\t\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\t\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\t\n\n\n"
      238: let s099 = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\t\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\t\n\n\n\n\n\n\n\n\n\n\n"
      239: let s100 = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\t\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\t\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
      240: let s101 = "\n\n\n\n\n\n\n\n\t\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\t\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
      241: let s102 = "\n\n\n\n\n\n\n\n\t\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\016\016\016\016\016\016\016\016\016\016\016\016\015\015\015\015\015\015\015\015\015\015\015\015\015\015\015\015"
      242: let s103 = "\015\015\015\015\015\015\015\016\016\016\016\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\016\016\016\016"
      243: let s104 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
      244: let s105 = "\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
      245: let s106 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\000\000\000\000\000\000\000\000\000\000\000\000\016\016\016\016"
      246: let s107 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\016\016"
      247: let s108 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
      248: let s109 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\002\002\002\016\016\016\016\016"
      249: let s110 = "\016\002\002\002\016\002\002\016\016\016\016\016\002\002\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\002\016\016\016\016\002"
      250: let s111 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
      251: let s112 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
      252: let s113 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
      253: let s114 = "\016\016\016\016\016\016\002\002\002\002\002\002\002\002\002\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
      254: let s115 = "\r\002\r\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\002\002\002\002\002\002"
      255: let s116 = "\002\002\002\002\002\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002"
      256: let s117 = "\002\002\r\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\r\r\r\002\002\002\002\r\r\002\002\016\016\011\016\016"
      257: let s118 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\011\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
      258: let s119 = "\002\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\002\002\002\r\002\002\002\002\002\002\002\002\016\016\016\016\016\016\016\016\016\016\016"
      259: let s120 = "\016\016\016\016\016\r\r\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\016\016\016\016\016\016\016\016\016\016\016\016"
      260: let s121 = "\002\002\r\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\r\r\r\002\002\002\002\002\002\002\002\002\r"
      261: let s122 = "\r\016\011\011\016\016\016\016\016\002\002\002\002\016\r\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
      262: let s123 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\r\r\r\002\002\002\r\r\002\r\002\002\016\016\016\016\016\016\002\016"
      263: let s124 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\r\r\r\002\002\002\002\002\002\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
      264: let s125 = "\002\r\r\r\r\016\016\r\r\016\016\r\r\r\016\016\016\016\016\016\016\016\016\002\016\016\016\016\016\016\016\016\016\016\r\r\016\016\002\002\002\002\002\002\002\016\016\016\002\002\002\002\002\016\016\016\016\016\016\016\016\016\016\016"
      265: let s126 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\r\r\r\002\002\002\002\002\002\002\002"
      266: let s127 = "\r\r\002\002\002\r\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
      267: let s128 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\r\r\002\002\002\002\002\002\r\002\r\r\002\r\002"
      268: let s129 = "\002\r\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
      269: let s130 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\r\r\002\002\002\002\016\016\r\r\r\r\002\002\r\002"
      270: let s131 = "\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
      271: let s132 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\r\r\r\002\002\002\002\002\002\002\002\r\r\002\r\002"
      272: let s133 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\r\002\r\r\002\002\002\002\002\002\r\002\016\016\016\016\016\016\016\016"
      273: let s134 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\002\r\r\002\002\002\002\r\002\002\002\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
      274: let s135 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\r\r\r\002\002\002\002\002\002\002\002\002\r\002\002\016\016\016\016\016"
      275: let s136 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\r\r\r\r\r\016\r\r\016\016\002\002\r\002\011"
      276: let s137 = "\r\011\r\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
      277: let s138 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\r\r\r\002\002\002\002\016\016\002\002\r\r\r\r\002\016\016\016\r\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
      278: let s139 = "\016\002\002\002\002\002\002\002\002\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\002\002\002\002\r\011\002\002\002\002\016"
      279: let s140 = "\016\016\016\016\016\016\016\002\016\016\016\016\016\016\016\016\016\002\002\002\002\002\002\r\r\002\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
      280: let s141 = "\016\016\016\016\011\011\011\011\011\011\002\002\002\002\002\002\002\002\002\002\002\002\002\r\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
      281: let s142 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\r\002\002\002\002\002\002\002\016\002\002\002\002\002\002\r\002"
      282: let s143 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\016\r\002\002\002\002\002\002\002\r\002\002\r\002\002\016\016\016\016\016\016\016\016\016"
      283: let s144 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\002\002\002\002\016\016\016\002\016\002\002\016\002"
      284: let s145 = "\002\002\002\002\002\002\011\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
      285: let s146 = "\016\016\016\016\016\016\016\016\016\016\r\r\r\r\r\016\002\002\016\r\r\002\r\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
      286: let s147 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\r\r\016\016\016\016\016\016\016\016\016"
      287: let s148 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\000\000\000\000\000\000\000\000\000\016\016\016\016\016\016\016"
      288: let s149 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\002\002\002\016\016\016\016\016\016\016\016\016\016\016"
      289: let s150 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\002\002\002\002\002\016\016\016\016\016\016\016\016\016"
      290: let s151 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\016\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r"
      291: let s152 = "\r\r\r\r\r\r\r\r\016\016\016\016\016\016\016\002\002\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
      292: let s153 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\016\016\016\016\016\016\016\016\016\016\016\r\r\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
      293: let s154 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\016\000\000\000\000\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
      294: let s155 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\r\002\002\002\016\016\016\r\002\002\002\002\002\000\000\000\000\000\000\000\000\002\002\002\002\002"
      295: let s156 = "\002\002\002\016\016\002\002\002\002\002\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
      296: let s157 = "\016\016\002\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
      297: let s158 = "\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\016\016\016\016\002\002\002\002\002"
      298: let s159 = "\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\016\016\016\016\016\016\016\016\002\016\016\016\016\016\016\016\016\016\016"
      299: let s160 = "\016\016\016\016\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\002\002\002\016\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
      300: let s161 = "\002\002\002\002\002\002\002\016\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\016\016\002\002\002\002\002\002\002\016\002\002\016\002\002\002\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
      301: let s162 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
      302: let s163 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\002\002\002\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
      303: let s164 = "\016\016\016\016\002\002\002\002\002\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
      304: let s165 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\012\012\012\012\012\012\012\012\012\012\012\012\012\012\012\012\012\012\012\012\012\012\012\012\012\012"
      305: let s166 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\002\002\002"
      306: let s167 = "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002"
      307: let s168 = "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
      308: let s169 = "\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
      309: 
      310: let grapheme_cluster_boundary =
      311:   [|[|s001; s002; s003; s000; s000; s000; s000; s000; s000; s000; s000; s000;
      312:       s004; s005; s000; s000; s000; s000; s006; s000; s000; s000; s007; s008;
      313:       s009; s010; s000; s011; s012; s013; s014; s015; s016; s017; s000; s018;
      314:       s019; s020; s021; s022; s023; s024; s023; s025; s026; s027; s028; s029;
      315:       s030; s031; s032; s033; s034; s035; s036; s037; s038; s039; s040; s041;
      316:       s042; s043; s044; s045|];
      317:     [|s046; s047; s048; s000; s049; s050; s051; s052; s000; s000; s000; s000;
      318:       s000; s053; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000;
      319:       s000; s000; s000; s000; s054; s055; s056; s057; s058; s000; s059; s000;
      320:       s060; s000; s000; s000; s061; s062; s063; s064; s065; s066; s067; s068;
      321:       s069; s000; s000; s070; s000; s000; s000; s071; s000; s000; s000; s000;
      322:       s000; s000; s000; s000|];
      323:     [|s072; s073; s000; s074; s000; s000; s000; s000; s000; s000; s000; s000;
      324:       s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000;
      325:       s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000;
      326:       s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000;
      327:       s000; s000; s000; s075; s000; s076; s000; s077; s000; s000; s000; s000;
      328:       s000; s000; s000; s000|];
      329:     [|s078; s000; s079; s000; s000; s000; s000; s000; s000; s000; s000; s000;
      330:       s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000;
      331:       s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000;
      332:       s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000;
      333:       s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000;
      334:       s000; s000; s000; s000|];
      335:     [||]; [||]; [||]; [||]; [||]; [||];
      336:     [|s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000;
      337:       s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000;
      338:       s000; s080; s081; s082; s000; s000; s000; s000; s083; s000; s084; s085;
      339:       s086; s087; s088; s089; s090; s091; s092; s093; s000; s000; s000; s094;
      340:       s095; s096; s097; s098; s099; s100; s101; s095; s096; s097; s098; s099;
      341:       s100; s101; s095; s096|];
      342:     [|s097; s098; s099; s100; s101; s095; s096; s097; s098; s099; s100; s101;
      343:       s095; s096; s097; s098; s099; s100; s101; s095; s096; s097; s098; s099;
      344:       s100; s101; s095; s096; s097; s098; s099; s100; s101; s095; s096; s097;
      345:       s098; s099; s100; s101; s095; s096; s097; s098; s099; s100; s101; s095;
      346:       s096; s097; s098; s099; s100; s101; s095; s096; s097; s098; s099; s100;
      347:       s101; s095; s096; s097|];
      348:     [|s098; s099; s100; s101; s095; s096; s097; s098; s099; s100; s101; s095;
      349:       s096; s097; s098; s099; s100; s101; s095; s096; s097; s098; s099; s100;
      350:       s101; s095; s096; s097; s098; s099; s100; s101; s095; s096; s097; s098;
      351:       s099; s100; s101; s095; s096; s097; s098; s099; s100; s101; s095; s096;
      352:       s097; s098; s099; s100; s101; s095; s096; s097; s098; s099; s100; s101;
      353:       s095; s096; s097; s098|];
      354:     [|s099; s100; s101; s095; s096; s097; s098; s099; s100; s101; s095; s096;
      355:       s097; s098; s099; s100; s101; s095; s096; s097; s098; s099; s100; s101;
      356:       s095; s096; s097; s098; s099; s100; s102; s103; s000; s000; s000; s000;
      357:       s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000;
      358:       s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000;
      359:       s000; s000; s000; s000|];
      360:     [||];
      361:     [|s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000;
      362:       s104; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000;
      363:       s105; s000; s000; s002; s000; s000; s081; s106; s000; s000; s000; s000;
      364:       s000; s000; s000; s107; s000; s000; s000; s108; s000; s109; s000; s000;
      365:       s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000;
      366:       s000; s000; s000; s000|];
      367:     [|s000; s000; s000; s000; s000; s000; s000; s000; s110; s000; s000; s111;
      368:       s000; s000; s000; s000; s000; s000; s000; s000; s112; s000; s000; s000;
      369:       s000; s000; s113; s000; s000; s114; s000; s000; s115; s116; s117; s118;
      370:       s119; s120; s121; s122; s123; s000; s000; s124; s034; s125; s000; s000;
      371:       s126; s127; s128; s129; s000; s000; s130; s131; s132; s064; s133; s000;
      372:       s134; s000; s000; s000|];
      373:     [|s135; s000; s000; s000; s136; s137; s000; s138; s139; s140; s141; s000;
      374:       s000; s000; s000; s000; s142; s000; s143; s000; s144; s145; s146; s000;
      375:       s000; s000; s000; s147; s000; s000; s000; s000; s000; s000; s000; s000;
      376:       s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000;
      377:       s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000;
      378:       s000; s000; s000; s000|];
      379:     [|s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000;
      380:       s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000;
      381:       s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000;
      382:       s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000;
      383:       s148; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000;
      384:       s000; s000; s000; s000|];
      385:     [||]; [||]; [||];
      386:     [|s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s149;
      387:       s150; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000;
      388:       s000; s000; s000; s000; s000; s151; s152; s153; s000; s000; s000; s000;
      389:       s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000;
      390:       s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000;
      391:       s000; s000; s000; s000|];
      392:     [||]; [||]; [||]; [||];
      393:     [|s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000;
      394:       s000; s000; s000; s000; s000; s000; s154; s000; s000; s000; s000; s000;
      395:       s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000;
      396:       s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000;
      397:       s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000;
      398:       s000; s000; s000; s000|];
      399:     [|s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000;
      400:       s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000;
      401:       s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000;
      402:       s000; s155; s156; s000; s000; s157; s000; s000; s000; s000; s000; s000;
      403:       s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000;
      404:       s000; s000; s000; s000|];
      405:     [|s000; s000; s000; s000; s000; s000; s000; s000; s158; s159; s160; s000;
      406:       s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000;
      407:       s000; s000; s000; s000; s000; s000; s000; s000; s161; s000; s000; s000;
      408:       s150; s000; s000; s000; s000; s000; s000; s162; s000; s000; s000; s000;
      409:       s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000;
      410:       s000; s000; s000; s000|];
      411:     [|s000; s000; s000; s163; s000; s164; s000; s000; s000; s000; s000; s000;
      412:       s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000;
      413:       s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000;
      414:       s000; s000; s000; s165; s000; s000; s000; s000; s000; s000; s000; s166;
      415:       s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000;
      416:       s000; s000; s000; s000|];
      417:     [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; 
      418:     [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; 
      419:     [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; 
      420:     [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; 
      421:     [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; 
      422:     [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; 
      423:     [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; 
      424:     [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; 
      425:     [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; 
      426:     [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; 
      427:     [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; 
      428:     [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; 
      429:     [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; 
      430:     [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; 
      431:     [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; 
      432:     [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; 
      433:     [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; 
      434:     [||]; [||]; [||]; [||]; [||];
      435:     [|s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000;
      436:       s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000;
      437:       s000; s000; s000; s000; s000; s000; s000; s000; s167; s004; s168; s168;
      438:       s004; s004; s004; s169; s168; s168; s168; s168; s168; s168; s168; s168;
      439:       s168; s168; s168; s168; s168; s168; s168; s168; s168; s168; s168; s168;
      440:       s168; s168; s168; s168|];
      441:     [|s168; s168; s168; s168; s168; s168; s168; s168; s168; s168; s168; s168;
      442:       s168; s168; s168; s168; s168; s168; s168; s168; s168; s168; s168; s168;
      443:       s168; s168; s168; s168; s168; s168; s168; s168; s000; s000; s000; s000;
      444:       s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000;
      445:       s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000;
      446:       s000; s000; s000; s000|]|]
Added regular file ../notty/src/no-uucp/notty_uucp_data.mli:
        1: (* Do not edit.
        2:  *
        3:  * This module contains select unicode properties extracted from Uucp,
        4:  * using `./support/gen_unicode_props.ml`.
        5:  *
        6:  * Unicode version 13.0.0.
        7:  *)
        8: 
        9: (* Uucp.Break.tty_width_hint *)
       10: val tty_width_hint: int array * int array * int array
       11: 
       12: (* Uucp.Break.Low.grapheme_cluster. *)
       13: val grapheme_cluster_boundary: string array array
       14: 
Added regular file ../notty/src/notty.ml:
        1: (* Copyright (c) 2016-2017 David Kaloper Meršinjak. All rights reserved.
        2:    See LICENSE.md. *)
        3: 
        4: let invalid_arg fmt = Format.kasprintf invalid_arg fmt
        5: 
        6: let (&.) f g x = f (g x)
        7: 
        8: let btw (x : int) a b = a <= x && x <= b
        9: let bit n b = b land (1 lsl n) > 0
       10: 
       11: let max (a : int) b = if a > b then a else b
       12: let min (a : int) b = if a < b then a else b
       13: 
       14: let is_C0 x = x < 0x20 || x = 0x7f
       15: and is_C1 x = 0x80 <= x && x < 0xa0
       16: let is_ctrl x = is_C0 x || is_C1 x
       17: and is_ascii x = x < 0x80
       18: 
       19: let rec concatm z (@) xs =
       20:   let rec accum (@) = function
       21:     | []|[_] as xs -> xs
       22:     | a::b::xs -> (a @ b) :: accum (@) xs in
       23:   match xs with [] -> z | [x] -> x | xs -> concatm z (@) (accum (@) xs)
       24: 
       25: let rec linspcm z (@) x n f = match n with
       26:   | 0 -> z
       27:   | 1 -> f x
       28:   | _ -> let m = n / 2 in linspcm z (@) x m f @ linspcm z (@) (x + m) (n - m) f
       29: 
       30: let memo (type a) ?(hash=Hashtbl.hash) ?(eq=(=)) ~size f =
       31:   let module H = Ephemeron.K1.Make
       32:     (struct type t = a let (hash, equal) = (hash, eq) end) in
       33:   let t = H.create size in fun x ->
       34:     try H.find t x with Not_found -> let y = f x in H.add t x y; y
       35: 
       36: module Buffer = struct
       37:   include Buffer
       38:   let buf = Buffer.create 1024
       39:   let mkstring f = f buf; let res = contents buf in reset buf; res
       40:   let add_decimal b = function
       41:     | x when btw x 0 999 ->
       42:         let d1 = x / 100 and d2 = (x mod 100) / 10 and d3 = x mod 10 in
       43:         if d1 > 0 then 0x30 + d1 |> Char.unsafe_chr |> add_char b;
       44:         if (d1 + d2) > 0 then 0x30 + d2 |> Char.unsafe_chr |> add_char b;
       45:         0x30 + d3 |> Char.unsafe_chr |> add_char b
       46:     | x -> string_of_int x |> add_string b
       47:   let add_chars b c n = for _ = 1 to n do add_char b c done
       48: end
       49: 
       50: module String = struct
       51:   include String
       52:   let sub0cp s i len = if i > 0 || len < length s then sub s i len else s
       53:   let of_chars_rev = function
       54:     | []  -> ""
       55:     | [c] -> String.make 1 c
       56:     | cs  ->
       57:         let n = List.length cs in
       58:         let rec go bs i = Bytes.(function
       59:           | []    -> unsafe_to_string bs
       60:           | x::xs -> unsafe_set bs i x; go bs (pred i) xs
       61:         ) in go (Bytes.create n) (n - 1) cs
       62: end
       63: 
       64: module Option = struct
       65: 
       66:   let map f = function Some x -> Some (f x) | _ -> None
       67:   let get def = function Some x -> x | _ -> def
       68:   let to_list = function Some x -> [x] | _ -> []
       69:   let (>>|) a f = map f a
       70:   let (>>=) a f = match a with Some x -> f x | _ -> None
       71: end
       72: 
       73: module Text = struct
       74: 
       75:   let err_ctrl u = invalid_arg "Notty: control char: U+%02X, %S" (Char.code u)
       76:   let err_malformed = invalid_arg "Notty: malformed UTF-8: %s, %S"
       77: 
       78:   type t =
       79:     | Ascii of string * int * int
       80:     | Utf8  of string * int array * int * int
       81: 
       82:   let equal t1 t2 = match (t1, t2) with
       83:     | (Utf8 (s1, _, i1, n1), Utf8 (s2, _, i2, n2))
       84:     | (Ascii (s1, i1, n1), Ascii (s2, i2, n2)) -> i1 = i2 && n1 = n2 && s1 = s2
       85:     | _ -> false
       86: 
       87:   let width = function Utf8 (_, _, _, w) -> w | Ascii (_, _, w)   -> w
       88: 
       89:   let empty = Ascii ("", 0, 0)
       90: 
       91:   let is_empty t = width t = 0
       92: 
       93:   let graphemes str =
       94:     let module Uuseg = Notty_grapheme_cluster in
       95:     let seg = Uuseg.create () in
       96:     let rec f (is, w as acc) i evt =
       97:       match Uuseg.add seg evt with
       98:       | `Await | `End -> acc
       99:       | `Uchar u      -> f (is, w + Notty_uucp.tty_width_hint u) i `Await
      100:       | `Boundary     ->
      101:           let is = match w with 0 -> is | 1 -> i::is | _ -> i::(-1)::is in
      102:           f (is, 0) i `Await in
      103:     let acc = Uutf.String.fold_utf_8 (fun acc i -> function
      104:       | `Malformed err -> err_malformed err str
      105:       | `Uchar _ as u  -> f acc i u
      106:       ) ([0], 0) str in
      107:     f acc (String.length str) `End |> fst |> List.rev |> Array.of_list (*XXX*)
      108: 
      109:   let dead = ' '
      110: 
      111:   let to_buffer buf = function
      112:     | Ascii (s, off, w)    -> Buffer.add_substring buf s off w
      113:     | Utf8 (s, ix, off, w) ->
      114:         let x1 = match ix.(off) with
      115:           | -1 -> Buffer.add_char buf dead; ix.(off + 1) | x -> x
      116:         and x2 = ix.(off + w) in
      117:         Buffer.add_substring buf s x1 @@
      118:           (if x2 = -1 then ix.(off + w - 1) else x2) - x1;
      119:         if x2 = -1 then Buffer.add_char buf dead
      120: 
      121:   let sub t x w =
      122:     let w1 = width t in
      123:     if w = 0 || x >= w1 then empty else
      124:       let w = min w (w1 - x) in
      125:       if w = w1 then t else match t with
      126:         Ascii (s, off, _) -> Ascii (s, off + x, w)
      127:       | Utf8 (s, ix, off, _) -> Utf8 (s, ix, off + x, w)
      128: 
      129:   let is_ascii_or_raise_ctrl s =
      130:     let (@!) s i = String.unsafe_get s i |> Char.code in
      131:     let rec go s acc i n =
      132:       if n = 0 then acc else
      133:         let x = s @! i in
      134:         if is_C0 x then
      135:           err_ctrl s.[i] s
      136:         else if x = 0xc2 && n > 1 && is_C1 (s @! (i + 1)) then
      137:           err_ctrl s.[i + 1] s
      138:         else go s (acc && is_ascii x) (i + 1) (n - 1) in
      139:     go s true 0 (String.length s)
      140: 
      141:   let of_ascii s = Ascii (s, 0, String.length s)
      142:   and of_unicode s = let x = graphemes s in Utf8 (s, x, 0, Array.length x - 1)
      143:   let of_unicode = memo ~eq:String.equal ~size:128 of_unicode
      144: 
      145:   let of_string = function
      146:     | "" -> empty
      147:     | s  -> if is_ascii_or_raise_ctrl s then of_ascii s else of_unicode s
      148: 
      149:   let of_uchars ucs = of_string @@ Buffer.mkstring @@ fun buf ->
      150:     Array.iter (Buffer.add_utf_8_uchar buf) ucs
      151: 
      152:   let replicateu w u =
      153:     if is_ctrl (Uchar.to_int u) then
      154:       err_ctrl (Uchar.unsafe_to_char u) "<repeated character>"
      155:     else if w < 1 then empty
      156:     else if is_ascii (Uchar.to_int u) then
      157:       of_ascii (String.make w (Uchar.unsafe_to_char u))
      158:     else of_unicode @@ Buffer.mkstring @@ fun buf ->
      159:       for _ = 1 to w do Buffer.add_utf_8_uchar buf u done
      160: 
      161:   let replicatec w c = replicateu w (Uchar.of_char c)
      162: end
      163: 
      164: module A = struct
      165: 
      166:   type color = int
      167:   type style = int
      168:   type t = { fg : color; bg : color; st : style }
      169: 
      170:   let equal t1 t2 = t1.fg = t2.fg && t1.bg = t2.bg && t1.st = t2.st
      171:   let unsafe_color_of_int int= int
      172:   let unsafe_style_of_int int= int
      173: 
      174:   let black        = 0x01000000
      175:   and red          = 0x01000001
      176:   and green        = 0x01000002
      177:   and yellow       = 0x01000003
      178:   and blue         = 0x01000004
      179:   and magenta      = 0x01000005
      180:   and cyan         = 0x01000006
      181:   and white        = 0x01000007
      182:   and lightblack   = 0x01000008
      183:   and lightred     = 0x01000009
      184:   and lightgreen   = 0x0100000a
      185:   and lightyellow  = 0x0100000b
      186:   and lightblue    = 0x0100000c
      187:   and lightmagenta = 0x0100000d
      188:   and lightcyan    = 0x0100000e
      189:   and lightwhite   = 0x0100000f
      190: 
      191:   let tag c = (c land 0x03000000) lsr 24
      192: 
      193:   let rgb ~r ~g ~b =
      194:     if r < 0 || g < 0 || b < 0 || r > 5 || g > 5 || b > 5 then
      195:       invalid_arg "Notty.A.rgb %d %d %d: channel out of range" r g b
      196:     else 0x01000000 lor (r * 36 + g * 6 + b + 16)
      197: 
      198:   let gray level =
      199:     if level < 0 || level > 23 then
      200:       invalid_arg "Notty.A.gray %d: level out of range" level
      201:     else 0x01000000 lor (level + 232)
      202: 
      203:   let rgb_888 ~r ~g ~b =
      204:     if r < 0 || g < 0 || b < 0 || r > 255 || g > 255 || b > 255 then
      205:       invalid_arg "Notty.A.rgb_888 %d %d %d: channel out of range" r g b
      206:     else 0x02000000 lor ((r lsl 16) lor (g lsl 8) lor b)
      207: 
      208:   let i x = x land 0xff
      209:   and r x = x lsr 16 land 0xff
      210:   and g x = x lsr 8 land 0xff
      211:   and b x = x land 0xff
      212: 
      213:   let bold      = 1
      214:   and italic    = 2
      215:   and underline = 4
      216:   and blink     = 8
      217:   and reverse   = 16
      218: 
      219:   let empty = { fg = 0; bg = 0; st = 0 }
      220: 
      221:  let (++) a1 a2 =
      222:    if a1 == empty then a2 else if a2 == empty then a1 else
      223:      { fg = (match a2.fg with 0 -> a1.fg | x -> x)
      224:      ; bg = (match a2.bg with 0 -> a1.bg | x -> x)
      225:      ; st = a1.st lor a2.st }
      226: 
      227:   let fg fg = { empty with fg }
      228:   let bg bg = { empty with bg }
      229:   let st st = { empty with st }
      230: end
      231: 
      232: module I = struct
      233: 
      234:   type dim = int * int
      235: 
      236:   type t =
      237:     | Empty
      238:     | Segment  of A.t * Text.t
      239:     | Hcompose of (t * t) * dim
      240:     | Vcompose of (t * t) * dim
      241:     | Zcompose of (t * t) * dim
      242:     | Hcrop    of (t * int * int) * dim
      243:     | Vcrop    of (t * int * int) * dim
      244:     | Void     of dim
      245: 
      246:   let width = function
      247:     | Empty -> 0
      248:     | Segment (_, text) -> Text.width text
      249:     | Hcompose (_, (w, _)) -> w
      250:     | Vcompose (_, (w, _)) -> w
      251:     | Zcompose (_, (w, _)) -> w
      252:     | Hcrop    (_, (w, _)) -> w
      253:     | Vcrop    (_, (w, _)) -> w
      254:     | Void         (w, _)  -> w [@@inline]
      255: 
      256:   let height = function
      257:     | Empty -> 0
      258:     | Segment _ -> 1
      259:     | Hcompose (_, (_, h)) -> h
      260:     | Vcompose (_, (_, h)) -> h
      261:     | Zcompose (_, (_, h)) -> h
      262:     | Hcrop    (_, (_, h)) -> h
      263:     | Vcrop    (_, (_, h)) -> h
      264:     | Void         (_, h)  -> h [@@inline]
      265: 
      266:   let equal t1 t2 =
      267:     let rec eq t1 t2 = match (t1, t2) with
      268:       | (Empty, Empty) -> true
      269:       | (Segment (a1, t1), Segment (a2, t2)) ->
      270:           A.equal a1 a2 && Text.equal t1 t2
      271:       | (Hcompose ((a, b), _), Hcompose ((c, d), _))
      272:       | (Vcompose ((a, b), _), Vcompose ((c, d), _))
      273:       | (Zcompose ((a, b), _), Zcompose ((c, d), _)) -> eq a c && eq b d
      274:       | (Hcrop ((a, i1, n1), _), Hcrop ((b, i2, n2), _))
      275:       | (Vcrop ((a, i1, n1), _), Vcrop ((b, i2, n2), _)) ->
      276:           i1 = i2 && n1 = n2 && eq a b
      277:       | (Void (a, b), Void (c, d)) -> a = c && b = d
      278:       | _ -> false in
      279:     width t1 = width t2 && height t1 = height t2 && eq t1 t2
      280: 
      281:   let empty = Empty
      282: 
      283:   let (<|>) t1 t2 = match (t1, t2) with
      284:     | (_, Empty) -> t1
      285:     | (Empty, _) -> t2
      286:     | _          ->
      287:         let w = width t1 + width t2
      288:         and h = max (height t1) (height t2) in
      289:         Hcompose ((t1, t2), (w, h))
      290: 
      291:   let (<->) t1 t2 = match (t1, t2) with
      292:     | (_, Empty) -> t1
      293:     | (Empty, _) -> t2
      294:     | _          ->
      295:         let w = max (width t1) (width t2)
      296:         and h = height t1 + height t2 in
      297:         Vcompose ((t1, t2), (w, h))
      298: 
      299:   let (</>) t1 t2 = match (t1, t2) with
      300:     | (_, Empty) -> t1
      301:     | (Empty, _) -> t2
      302:     | _          ->
      303:         let w = max (width t1) (width t2)
      304:         and h = max (height t1) (height t2) in
      305:         Zcompose ((t1, t2), (w, h))
      306: 
      307:   let void w h =
      308:     if w < 1 && h < 1 then Empty else Void (max 0 w, max 0 h)
      309: 
      310:   let lincropinv crop void (++) init fini img =
      311:     match (init >= 0, fini >= 0) with
      312:     | (true, true) -> crop init fini img
      313:     | (true, _   ) -> crop init 0 img ++ void (-fini)
      314:     | (_   , true) -> void (-init) ++ crop 0 fini img
      315:     | _            -> void (-init) ++ img ++ void (-fini)
      316: 
      317:   let hcrop =
      318:     let ctor left right img =
      319:       let h = height img and w = width img - left - right in
      320:       if w > 0 then Hcrop ((img, left, right), (w, h)) else void w h
      321:     in lincropinv ctor (fun w -> void w 0) (<|>)
      322: 
      323:   let vcrop =
      324:     let ctor top bottom img =
      325:       let w = width img and h = height img - top - bottom in
      326:       if h > 0 then Vcrop ((img, top, bottom), (w, h)) else void w h
      327:     in lincropinv ctor (void 0) (<->)
      328: 
      329:   let crop ?(l=0) ?(r=0) ?(t=0) ?(b=0) img =
      330:     let img = if l <> 0 || r <> 0 then hcrop l r img else img in
      331:     if t <> 0 || b <> 0 then vcrop t b img else img
      332: 
      333:   let hpad left right img = hcrop (-left) (-right) img
      334: 
      335:   let vpad top bottom img = vcrop (-top) (-bottom) img
      336: 
      337:   let pad ?(l=0) ?(r=0) ?(t=0) ?(b=0) img =
      338:     crop ~l:(-l) ~r:(-r) ~t:(-t) ~b:(-b) img
      339: 
      340:   let hcat = concatm empty (<|>)
      341: 
      342:   let vcat = concatm empty (<->)
      343: 
      344:   let zcat xs = List.fold_right (</>) xs empty
      345: 
      346:   let text attr tx =
      347:     if Text.is_empty tx then void 0 1 else Segment (attr, tx)
      348: 
      349:   let string attr s = text attr (Text.of_string s)
      350: 
      351:   let uchars attr a = text attr (Text.of_uchars a)
      352: 
      353:   let tabulate m n f =
      354:     let m = max m 0 and n = max n 0 in
      355:     linspcm empty (<->) 0 n (fun y -> linspcm empty (<|>) 0 m (fun x -> f x y))
      356: 
      357:   let chars ctor attr c w h =
      358:     if w < 1 || h < 1 then void w h else
      359:       let line = text attr (ctor w c) in tabulate 1 h (fun _ _ -> line)
      360: 
      361:   let char  = chars Text.replicatec
      362:   let uchar = chars Text.replicateu
      363: 
      364:   let hsnap ?(align=`Middle) w img =
      365:     let off = width img - w in match align with
      366:       | `Left   -> hcrop 0 off img
      367:       | `Right  -> hcrop off 0 img
      368:       | `Middle -> let w1 = off / 2 in hcrop w1 (off - w1) img
      369: 
      370:   let vsnap ?(align=`Middle) h img =
      371:     let off = height img - h in match align with
      372:       | `Top    -> vcrop 0 off img
      373:       | `Bottom -> vcrop off 0 img
      374:       | `Middle -> let h1 = off / 2 in vcrop h1 (off - h1) img
      375: 
      376:   module Fmt = struct
      377: 
      378:     open Format
      379: 
      380:     type stag += Attr of A.t
      381: 
      382:     let push r x = r := x :: !r
      383:     let pop r = r := (match !r with _::xs -> xs | _ -> [])
      384:     let top_a r = match !r with a::_ -> a | _ -> A.empty
      385: 
      386:     let create () =
      387:       let img, line, attr = ref empty, ref empty, ref [] in
      388:       let fmt = formatter_of_out_functions {
      389:           out_flush = (fun () ->
      390:             img := !img <-> !line; line := empty; attr := [])
      391:         ; out_newline = (fun () ->
      392:             img := !img <-> !line; line := void 0 1)
      393:         ; out_string = (fun s i n ->
      394:             line := !line <|> string (top_a attr) String.(sub0cp s i n))
      395:         (* Not entirely clear; either or both could be void: *)
      396:         ; out_spaces = (fun w -> line := !line <|> char (top_a attr) ' ' w 1)
      397:         ; out_indent = (fun w -> line := !line <|> char (top_a attr) ' ' w 1)
      398:       } in
      399:       pp_set_formatter_stag_functions fmt {
      400:         (pp_get_formatter_stag_functions fmt ()) with
      401:             mark_open_stag =
      402:               (function Attr a -> push attr A.(top_a attr ++ a); "" | _ -> "")
      403:           ; mark_close_stag = (fun _ -> pop attr; "") };
      404:       pp_set_mark_tags fmt true;
      405:       fmt, fun () -> let i = !img in img := empty; line := empty; attr := []; i
      406: 
      407:     let ppf, reset = create ()
      408: 
      409:     let kstrf ?(attr = A.empty) ?(w = 1000000) k format =
      410:       let m = ref 0 in
      411:       let f1 _ () =
      412:         m := pp_get_margin ppf ();
      413:         pp_set_margin ppf w;
      414:         pp_open_stag ppf (Attr attr)
      415:       and k _ =
      416:         pp_print_flush ppf ();
      417:         pp_set_margin ppf !m;
      418:         reset () |> k
      419:       in kfprintf k ppf ("%a" ^^ format) f1 ()
      420: 
      421:     let strf ?attr ?w format = kstrf ?attr ?w (fun i -> i) format
      422: 
      423:     let attr attr f fmt x =
      424:       pp_open_stag fmt (Attr attr); f fmt x; pp_close_stag fmt ()
      425:   end
      426: 
      427:   let kstrf, strf, pp_attr = Fmt.(kstrf, strf, attr)
      428: end
      429: 
      430: module Operation = struct
      431: 
      432:   type t =
      433:     End
      434:   | Skip of int * t
      435:   | Text of A.t * Text.t * t
      436: 
      437:   let skip n k = if n = 0 then k else match k with
      438:       End         -> End
      439:     | Skip (m, k) -> Skip (m + n, k)
      440:     | _           -> Skip (n, k) [@@inline]
      441: 
      442:   let rec scan x w row i k =
      443:     let open I in match i with
      444: 
      445:     | Empty | Void _ -> skip w k
      446: 
      447:     | Segment _ when row > 0 -> skip w k
      448:     | Segment (attr, text) ->
      449:         let t  = Text.sub text x w in
      450:         let w1 = Text.width t in
      451:         let p  = if w > w1 then skip (w - w1) k else k in
      452:         if w1 > 0 then Text (attr, t, p) else p
      453: 
      454:     | Hcompose ((i1, i2), _) ->
      455:         let w1 = width i1
      456:         and w2 = width i2 in
      457:         if x >= w1 + w2 then skip w k else
      458:         if x >= w1 then scan (x - w1) w row i2 k else
      459:         if x + w <= w1 then scan x w row i1 k else
      460:           scan x (w1 - x) row i1 @@ scan 0 (w - w1 + x) row i2 @@ k
      461: 
      462:     | Vcompose ((i1, i2), _) ->
      463:         let h1 = height i1
      464:         and h2 = height i2 in
      465:         if row >= h1 + h2 then skip w k else
      466:         if row >= h1 then scan x w (row - h1) i2 k else scan x w row i1 k
      467: 
      468:     | Zcompose ((i1, i2), _) ->
      469:         let rec stitch x w row i = function
      470:           | End -> scan x w row i End
      471:           | Text (a, t, ops) as opss ->
      472:               let w1 = Text.width t in
      473:               if w1 >= w then opss else
      474:                 Text (a, t, stitch (x + w1) (w - w1) row i ops)
      475:           | Skip (w1, ops) ->
      476:               scan x w1 row i @@
      477:                 if w1 >= w then ops else stitch (x + w1) (w - w1) row i ops
      478:         in stitch x w row i2 @@ scan x w row i1 @@ k
      479: 
      480:     | Hcrop ((i, left, _), (w1, _)) ->
      481:         if x >= w1 then skip w k else
      482:         if x + w <= w1 then scan (x + left) w row i k else
      483:           scan (x + left) (w1 - x) row i @@ skip (w - w1 + x) k
      484: 
      485:     | Vcrop ((i, top, _), (_, h1)) ->
      486:         if row < h1 then scan x w (top + row) i k else skip w k
      487: 
      488:   let of_image (x, y) (w, h) i =
      489:     List.init h (fun off -> scan x (x + w) (y + off) i End)
      490: end
      491: 
      492: module Cap = struct
      493: 
      494:   type op = Buffer.t -> unit
      495: 
      496:   let (&) op1 op2 buf = op1 buf; op2 buf
      497: 
      498:   type t = {
      499:     skip    : int -> op
      500:   ; sgr     : A.t -> op
      501:   ; newline : op
      502:   ; clreol  : op
      503:   ; cursvis : bool -> op
      504:   ; cursat  : int -> int -> op
      505:   ; cubcuf  : int -> op
      506:   ; cuucud  : int -> op
      507:   ; cr      : op
      508:   ; altscr  : bool -> op
      509:   ; mouse   : bool -> op
      510:   ; bpaste  : bool -> op
      511:   }
      512: 
      513:   let ((<|), (<.), (<!)) = Buffer.(add_string, add_char, add_decimal)
      514: 
      515:   let sts = [ ";1"; ";3"; ";4"; ";5"; ";7" ]
      516: 
      517:   let sgr { A.fg; bg; st } buf =
      518:     buf <| "\x1b[0";
      519:     let rgb888 buf x =
      520:       buf <! A.r x; buf <. ';'; buf <! A.g x; buf <. ';'; buf <! A.b x in
      521:     ( match A.tag fg with
      522:         0 -> ()
      523:       | 1 -> let c = A.i fg in
      524:              if c < 8  then ( buf <. ';'; buf <! (c + 30) )
      525:              else if c < 16 then ( buf <. ';'; buf <! (c + 82) )
      526:              else ( buf <| ";38;5;"; buf <! c )
      527:       | _ -> buf <| ";38;2;"; rgb888 buf fg );
      528:     ( match A.tag bg with
      529:         0 -> ()
      530:       | 1 -> let c = A.i bg in
      531:              if c < 8  then ( buf <. ';'; buf <! (c + 40) )
      532:              else if c < 16 then ( buf <. ';'; buf <! (c + 92) )
      533:              else ( buf <| ";48;5;"; buf <! c )
      534:       | _ -> buf <| ";48;2;"; rgb888 buf bg );
      535:     if st <> 0 then
      536:       ( let rec go f xs = match (f, xs) with
      537:           | (0, _) | (_, []) -> ()
      538:           | (_, x::xs) -> if f land 1 > 0 then buf <| x; go (f lsr 1) xs in
      539:         go st sts );
      540:     buf <. 'm'
      541: 
      542:   let ansi = {
      543:       skip    = (fun n b -> b <| "\x1b[0m"; Buffer.add_chars b ' ' n)
      544:     ; newline = (fun b -> b <| "\x1bE")
      545:     ; altscr  = (fun x b -> b <| if x then "\x1b[?1049h" else "\x1b[?1049l")
      546:     ; cursat  = (fun w h b -> b <| "\x1b["; b <! h; b <. ';'; b <! w; b <. 'H')
      547:     ; cubcuf  = (fun x b -> b <| "\x1b["; b <! abs x; b <. if x < 0 then 'D' else 'C')
      548:     ; cuucud  = (fun y b -> b <| "\x1b["; b <! abs y; b <. if y < 0 then 'A' else 'B')
      549:     ; cr      = (fun b -> b <| "\x1b[1G")
      550:     ; clreol  = (fun b -> b <| "\x1b[K")
      551:     ; cursvis = (fun x b -> b <| if x then "\x1b[34h\x1b[?25h" else "\x1b[?25l")
      552:     ; mouse   = (fun x b -> b <| if x then "\x1b[?1000;1002;1005;1015;1006h"
      553:                                       else "\x1b[?1000;1002;1005;1015;1006l")
      554:     ; bpaste  = (fun x b -> b <| if x then "\x1b[?2004h" else "\x1b[?2004l")
      555:     ; sgr }
      556: 
      557:   let no0 _     = ()
      558:   and no1 _ _   = ()
      559:   and no2 _ _ _ = ()
      560: 
      561:   let dumb = {
      562:       skip    = (fun n b -> Buffer.add_chars b ' ' n)
      563:     ; newline = (fun b -> b <| "\n")
      564:     ; altscr  = no1
      565:     ; cursat  = no2
      566:     ; cubcuf  = no1
      567:     ; cuucud  = no1
      568:     ; cr      = no0
      569:     ; clreol  = no0
      570:     ; cursvis = no1
      571:     ; sgr     = no1
      572:     ; mouse   = no1
      573:     ; bpaste  = no1
      574:     }
      575: 
      576:   let erase cap buf = cap.sgr A.empty buf; cap.clreol buf (* KEEP ETA-LONG. *)
      577:   let cursat0 cap w h = cap.cursat (max w 0 + 1) (max h 0 + 1)
      578: end
      579: 
      580: module Render = struct
      581: 
      582:   open Cap
      583:   open Operation
      584: 
      585:   let skip_op cap buf n = cap.skip n buf
      586:   let text_op cap buf a x = cap.sgr a buf; Text.to_buffer buf x
      587: 
      588:   let rec line cap buf = function
      589:     End              -> erase cap buf
      590:   | Skip (n,    End) -> erase cap buf; skip_op cap buf n
      591:   | Text (a, x, End) -> erase cap buf; text_op cap buf a x
      592:   | Skip (n,    ops) -> skip_op cap buf n; line cap buf ops
      593:   | Text (a, x, ops) -> text_op cap buf a x; line cap buf ops
      594: 
      595:   let rec lines cap buf = function
      596:     []      -> ()
      597:   | [ln]    -> line cap buf ln; cap.sgr A.empty buf
      598:   | ln::lns -> line cap buf ln; cap.newline buf; lines cap buf lns
      599: 
      600:   let to_buffer buf cap off dim img =
      601:     Operation.of_image off dim img |> lines cap buf
      602: 
      603:   let pp cap ppf img =
      604:     let open Format in
      605:     let buf = Buffer.create (I.width img * 2) in
      606:     let h, w = I.(height img, width img |> min (pp_get_margin ppf ())) in
      607:     let img = I.(img </> vpad (h - 1) 0 (char A.empty ' ' w 1)) in
      608:     pp_open_vbox ppf 0;
      609:     for y = 0 to h - 1 do
      610:       Buffer.clear buf; to_buffer buf cap (0, y) (w, 1) img;
      611:       pp_print_as ppf w (Buffer.contents buf);
      612:       if y < h - 1 then pp_print_cut ppf ()
      613:     done;
      614:     pp_close_box ppf ()
      615: 
      616:   let pp_image = pp Cap.ansi
      617:   let pp_attr ppf a =
      618:     let string_ = I.string A.empty in
      619:     pp_image ppf I.(string_ "<" <|> string a "ATTR" <|> string_ ">")
      620: end
      621: 
      622: module Unescape = struct
      623: 
      624:   type special = [
      625:     `Escape
      626:   | `Enter
      627:   | `Tab
      628:   | `Backspace
      629:   | `Insert
      630:   | `Delete
      631:   | `Home | `End
      632:   | `Arrow of [ `Up | `Down | `Left | `Right ]
      633:   | `Page of [ `Up | `Down ]
      634:   | `Function of int
      635:   ]
      636: 
      637:   type button = [ `Left | `Middle | `Right | `Scroll of [ `Up | `Down ] ]
      638: 
      639:   type mods = [ `Meta | `Ctrl | `Shift ] list
      640: 
      641:   type key = [ special | `Uchar of Uchar.t  | `ASCII of char ] * mods
      642: 
      643:   type mouse = [ `Press of button | `Drag | `Release ] * (int * int) * mods
      644: 
      645:   type paste = [ `Start | `End ]
      646: 
      647:   type event = [ `Key of key | `Mouse of mouse | `Paste of paste ]
      648: 
      649:   type esc =
      650:     C0    of char
      651:   | C1    of char
      652:   | SS2   of char
      653:   | CSI   of string * int list * char
      654:   | Esc_M of int * int * int
      655:   | Uchar of Uchar.t
      656: 
      657:   let uchar = function `Uchar u -> u | `ASCII c -> Uchar.of_char c
      658: 
      659:   let csi =
      660:     let open Option in
      661:     let rec priv acc = function
      662:       | x::xs when btw x 0x3c 0x3f -> priv (Char.unsafe_chr x::acc) xs
      663:       | xs                         -> param (String.of_chars_rev acc) None [] xs
      664:     and param prv p ps = function
      665:       | x::xs when btw x 0x30 0x39 -> param prv (Some (get 0 p * 10 + x - 0x30)) ps xs
      666:       | 0x3b::xs                   -> param prv None (get 0 p :: ps) xs
      667:       | xs                         -> code prv (List.rev (to_list p @ ps)) xs
      668:     and code prv ps = function (* Conflate two classes because urxvt... *)
      669:       | x::xs when btw x 0x20 0x2f || btw x 0x40 0x7e ->
      670:           Some (CSI (prv, ps, (Char.chr x)), xs)
      671:       | _ -> None in
      672:     priv []
      673: 
      674:   let rec demux =
      675:     let chr = Char.chr in function
      676:     | 0x1b::0x5b::0x4d::a::b::c::xs -> Esc_M (a, b, c) :: demux xs
      677:     | 0x1b::0x5b::xs | 0x9b::xs ->
      678:         let (r, xs) = csi xs |> Option.get (C1 '\x5b', xs) in r :: demux xs
      679:     | 0x1b::0x4f::x::xs | 0x8f::x::xs
      680:         when is_ascii x                 -> SS2 (chr x) :: demux xs
      681:     | 0x1b::x::xs when is_C1 (x + 0x40) -> C1 (chr x) :: demux xs
      682:     | x::xs when is_C1 x                -> C1 (chr (x - 0x40)) :: demux xs
      683:     | x::xs when is_C0 x                -> C0 (chr x) :: demux xs
      684:     | x::xs -> Uchar (Uchar.unsafe_of_int x) :: demux xs
      685:     | [] -> []
      686: 
      687:   let xtrm_mod_flags = function
      688:     | 2 -> Some [`Shift]
      689:     | 3 -> Some [`Meta]
      690:     | 4 -> Some [`Shift; `Meta]
      691:     | 5 -> Some [`Ctrl]
      692:     | 6 -> Some [`Shift; `Ctrl]
      693:     | 7 -> Some [`Meta; `Ctrl]
      694:     | 8 -> Some [`Shift; `Meta; `Ctrl]
      695:     | _ -> None
      696: 
      697:   let mods_xtrm = function
      698:     | [1;p] -> xtrm_mod_flags p
      699:     | []    -> Some []
      700:     | _     -> None
      701: 
      702:   let mods_rxvt = function
      703:     | '~' -> Some []
      704:     | '$' -> Some [`Shift]
      705:     | '^' -> Some [`Ctrl]
      706:     | '@' -> Some [`Ctrl; `Shift]
      707:     | _ -> None
      708: 
      709:   let mods_common ps code = match (ps, code) with
      710:     | ([], '~')  -> Some []
      711:     | ([], c)    -> mods_rxvt c
      712:     | ([p], '~') -> xtrm_mod_flags p
      713:     | _          -> None
      714: 
      715:   let mouse_p p =
      716:     let btn = match p land 3 with
      717:       | 0 when bit 6 p -> `Scroll `Up
      718:       | 0              -> `Left
      719:       | 1 when bit 6 p -> `Scroll `Down
      720:       | 1              -> `Middle
      721:       | 2 when bit 6 p -> `ALL (* `Scroll `Left *)
      722:       | 2              -> `Right
      723:       | 3 when bit 6 p -> `ALL (* `Scroll `Right *)
      724:       | _              -> `ALL
      725:     and drag = bit 5 p
      726:     and mods =
      727:       (if bit 3 p then [`Meta] else []) @
      728:       (if bit 4 p then [`Ctrl] else [])
      729:     in (btn, drag, mods)
      730: 
      731:   let key k mods = Some (`Key (k, mods))
      732: 
      733:   let event_of_control_code =
      734:     let open Option in function
      735:     | Uchar u when Uchar.to_int u |> is_ascii ->
      736:         Some (`Key (`ASCII (Uchar.unsafe_to_char u), []))
      737:     | Uchar u -> Some (`Key (`Uchar u, []))
      738: 
      739:     | C0 '\x1b'        -> key `Escape []
      740:     | C0 ('\b'|'\x7f') -> key `Backspace []
      741:     | C0 '\n'          -> key `Enter []
      742:     | C0 '\t'          -> key `Tab []
      743: 
      744:     | C0 x -> key (`ASCII Char.(code x + 0x40 |> unsafe_chr)) [`Ctrl]
      745:     | C1 x -> key (`ASCII x) [`Meta]
      746: 
      747:     | CSI ("",[],'Z') -> key `Tab [`Shift]
      748: 
      749:     | CSI ("",p,'A') -> mods_xtrm p >>= key (`Arrow `Up)
      750:     | CSI ("",p,'B') -> mods_xtrm p >>= key (`Arrow `Down)
      751:     | CSI ("",p,'C') -> mods_xtrm p >>= key (`Arrow `Right)
      752:     | CSI ("",p,'D') -> mods_xtrm p >>= key (`Arrow `Left)
      753: 
      754:     | CSI ("",[],'a') -> key (`Arrow `Up) [`Shift]
      755:     | CSI ("",[],'b') -> key (`Arrow `Down) [`Shift]
      756:     | CSI ("",[],'c') -> key (`Arrow `Right) [`Shift]
      757:     | CSI ("",[],'d') -> key (`Arrow `Left) [`Shift]
      758:     | SS2 ('A'|'a') -> key (`Arrow `Up) [`Ctrl]
      759:     | SS2 ('B'|'b') -> key (`Arrow `Down) [`Ctrl]
      760:     | SS2 ('C'|'c') -> key (`Arrow `Right) [`Ctrl]
      761:     | SS2 ('D'|'d') -> key (`Arrow `Left) [`Ctrl]
      762: 
      763:     | CSI ("",5::p,c) -> mods_common p c >>= key (`Page `Up)
      764:     | CSI ("",6::p,c) -> mods_common p c >>= key (`Page `Down)
      765: 
      766:     | CSI ("",2::p,c) -> mods_common p c >>= key `Insert
      767:     | CSI ("",3::p,c) -> mods_common p c >>= key `Delete
      768: 
      769:     | CSI ("",[4],'h') -> key `Insert []
      770:     | CSI ("",[],'L')  -> key `Insert [`Ctrl]
      771:     | CSI ("",[],'P')  -> key `Delete []
      772:     | CSI ("",[],'M')  -> key `Delete [`Ctrl]
      773: 
      774:     | CSI ("",p,'H')   -> mods_xtrm p >>= key `Home
      775:     | CSI ("",[7|1],c) -> mods_rxvt c >>= key `Home
      776: 
      777:     | CSI ("",p,'F')   -> mods_xtrm p >>= key `End
      778:     | CSI ("",[8|4],c) -> mods_rxvt c >>= key `End
      779:     | CSI ("",[],'J')  -> key `End [`Ctrl]
      780: 
      781:     | SS2 ('P'..'S' as c) -> key (`Function (Char.code c - 0x4f)) []
      782: 
      783:     | CSI ("",p,('P'..'S' as c)) ->
      784:         mods_xtrm p >>= key (`Function (Char.code c - 0x4f))
      785: 
      786:     | CSI ("",k::p,c) when btw k 11 15 || btw k 17 21 || btw k 23 26 ->
      787:         mods_common p c >>= key (`Function ((k - 10) - (k - 10) / 6))
      788: 
      789:     | CSI ("<",[p;x;y],('M'|'m' as c)) ->
      790:         let (btn, drag, mods) = mouse_p p in
      791:         ( match (c, btn, drag) with
      792:           | ('M', (#button as b), false) -> Some (`Press b)
      793:           | ('M', #button, true)         -> Some `Drag
      794:           | ('m', #button, false)        -> Some `Release
      795:           (* | ('M', `ALL   , true)         -> Some `Move *)
      796:           | _                            -> None
      797:         ) >>| fun e -> `Mouse (e, (x - 1, y - 1), mods)
      798: 
      799:     | CSI ("",[p;x;y],'M') | Esc_M (p,x,y) as evt ->
      800:         let (x, y) = match evt with Esc_M _ -> x - 32, y - 32 | _ -> x, y
      801:         and (btn, drag, mods) = mouse_p (p - 32) in
      802:         ( match (btn, drag) with
      803:           | (#button as b, false) -> Some (`Press b)
      804:           | (#button     , true ) -> Some `Drag
      805:           | (`ALL        , false) -> Some `Release
      806:           (* | (`ALL        , true)  -> Some `Move *)
      807:           | _                     -> None
      808:         ) >>| fun e -> `Mouse (e, (x - 1, y - 1), mods)
      809: 
      810:     | CSI ("",[200],'~') -> Some (`Paste `Start)
      811:     | CSI ("",[201],'~') -> Some (`Paste `End)
      812: 
      813:     | CSI _ | SS2 _ -> None
      814: 
      815:   let rec events = function
      816:     | C0 '\x1b' :: cc :: ccs ->
      817:       ( match event_of_control_code cc with
      818:         | Some (`Key (k, mods)) -> `Key (k, `Meta :: mods) :: events ccs
      819:         | Some _                -> `Key (`Escape, []) :: events (cc::ccs)
      820:         | None                  -> events ccs )
      821:     | cc::ccs -> (event_of_control_code cc |> Option.to_list) @ events ccs
      822:     | [] -> []
      823: 
      824:   let decode = events &. demux &. List.map Uchar.to_int
      825: 
      826:   type t = (event list * bool) ref
      827: 
      828:   let create () = ref ([], false)
      829: 
      830:   let next t = match !t with
      831:     | (#event as e::es, eof) -> t := (es, eof) ; e
      832:     | ([], false) -> `Await
      833:     | _           -> `End
      834: 
      835:   let list_of_utf8 buf i l =
      836:     let f cs _ = function `Uchar c -> c::cs | _ -> cs in
      837:     String.sub0cp (Bytes.unsafe_to_string buf) i l
      838:     |> Uutf.String.fold_utf_8 f [] |> List.rev
      839: 
      840:   let input t buf i l = t := match !t with
      841:     | (es, false) when l > 0 -> (es @ (list_of_utf8 buf i l |> decode), false)
      842:     | (es, _)                -> (es, true)
      843: 
      844:   let pending t = match !t with ([], false) -> false | _ -> true
      845: end
      846: 
      847: module Tmachine = struct
      848: 
      849:   open Cap
      850:   (* XXX This is sad. This should be a composable, stateless transducer. *)
      851: 
      852:   type t = {
      853:     cap           : Cap.t
      854:   ; mutable write : Buffer.t -> unit
      855:   ; mutable curs  : (int * int) option
      856:   ; mutable dim   : (int * int)
      857:   ; mutable image : I.t
      858:   ; mutable dead  : bool
      859:   }
      860: 
      861:   let emit t op =
      862:     if t.dead then
      863:       invalid_arg "Notty: use of released terminal"
      864:     else t.write <- t.write & op
      865: 
      866:   let cursor cap = function
      867:     | None        -> cap.cursvis false
      868:     | Some (w, h) -> cap.cursvis true & cursat0 cap w h
      869: 
      870:   let create ~mouse ~bpaste cap = {
      871:       cap
      872:     ; curs  = None
      873:     ; dim   = (0, 0)
      874:     ; image = I.empty
      875:     ; dead  = false
      876:     ; write =
      877:         cap.altscr true & cursor cap None & cap.mouse mouse & cap.bpaste bpaste
      878:     }
      879: 
      880:   let release t =
      881:     if t.dead then false else
      882:       ( emit t ( t.cap.altscr false & t.cap.cursvis true &
      883:                  t.cap.mouse false & t.cap.bpaste false );
      884:         t.dead <- true; true )
      885: 
      886:   let output t buf = t.write buf; t.write <- ignore
      887: 
      888:   let refresh ({ dim; image; _ } as t) =
      889:     emit t ( cursor t.cap None & cursat0 t.cap 0 0 &
      890:              (fun buf -> Render.to_buffer buf t.cap (0, 0) dim image) &
      891:              cursor t.cap t.curs )
      892: 
      893:   let set_size t dim = t.dim <- dim
      894:   let image t image = t.image <- image; refresh t
      895:   let cursor t curs = t.curs <- curs; emit t (cursor t.cap curs)
      896: 
      897:   let size t = t.dim
      898:   let dead t = t.dead
      899: end
      900: 
      901: module Direct = struct
      902:   let show_cursor buf cap x = cap.Cap.cursvis x buf
      903:   and move_cursor buf cap cmd = match cmd with
      904:     | `To (w, h) -> Cap.cursat0 cap w h buf
      905:     | `Home      -> cap.Cap.cr buf
      906:     | `By (x, y) ->
      907:         Cap.(if x <> 0 then cap.cubcuf x buf; if y <> 0 then cap.cuucud y buf)
      908: end
      909: 
      910: type attr  = A.t
      911: type image = I.t
      912: 
      913: module Infix = struct
      914:   let ((<->), (<|>), (</>)) = I.((<->), (<|>), (</>))
      915:   let (++) = A.(++)
      916: end
Added regular file ../notty/src/notty.mli:
        1: (* Copyright (c) 2016-2017 David Kaloper Meršinjak. All rights reserved.
        2:    See LICENSE.md. *)
        3: 
        4: (** Declaring terminals.
        5: 
        6:     Notty is a terminal library that revolves around construction and
        7:     composition of displayable images.
        8: 
        9:     This module provides the core {{!I}[image]} abstraction, standalone
       10:     {{!Render}rendering}, and escape sequence {{!Unescape}parsing}. It does not
       11:     depend on any platform code, and does not interact with the environment.
       12:     Input and output are provided by {!Notty_unix} and {!Notty_lwt}.
       13: 
       14:     Consult the {{!basics}basics}, {{!examples}examples} and
       15:     {{!limitations}limitations}.
       16: 
       17:     {e %%VERSION%% — {{:%%PKG_HOMEPAGE%% }homepage}} *)
       18: 
       19: (** {1 Interface} *)
       20: 
       21: type attr
       22: (** Visual characteristics of displayed text. *)
       23: 
       24: type image
       25: (** Rectangles of styled characters. *)
       26: 
       27: (** [A] is for attribute.
       28: 
       29:     Construction and composition of styling characteristics of text.
       30: 
       31:     Consult the {{!basics}basics} for an overview. *)
       32: module A : sig
       33: 
       34:   (** {1 Colors} *)
       35: 
       36:   type color
       37:   (** An ineffable quality of light.
       38: 
       39:       There are three kinds of colors:
       40:       {ul
       41:       {- {e Core 16 colors.}
       42: 
       43:          ANSI defines 8 color {e names}, with the actual display colors
       44:          considered an implementation detail. Historically, this palette was
       45:          extended with their light (sometimes {e bright} or {e high-intensity})
       46:          counterparts. Their presentation is undefined too, but typically
       47:          produces a brighter shade. These colors - often called the {e ANSI
       48:          colors} - tend to be unpredictable, but ubiquitously supported.
       49: 
       50:          }
       51:       {- {e Extended 256-color palette.}
       52: 
       53:          This common feature extends the palette by further 240 colors. They
       54:          come in two groups:
       55: 
       56:          {ul
       57:          {- The {e color cube}, a 6*6*6 approximation to the usual 24-bit RGB
       58:             color cube; and}
       59:          {- the {e grayscale ramp}, containing (merely) 24 shades of gray.}}
       60: 
       61:          XTerm was the first to support this extension. Many terminals have
       62:          since cloned it, so the support is wide, but not universal.
       63: 
       64:          As the extended colors are still palette-driven they do not have a
       65:          fixed presentation, and the presentation can be changed in some
       66:          terminals. Default palette tends to match {{:
       67:          https://upload.wikimedia.org/wikipedia/commons/1/15/Xterm_256color_chart.svg}
       68:          XTerm's}.
       69: 
       70:          }
       71:       {- {e True color}
       72: 
       73:          A recently established convention allows directly sending 24-bit colors
       74:          to the terminal. This has been adopted by a growing minority of
       75:          terminals. A reasonably up-to-date status document maintained by the
       76:          community can be found {{:https://gist.github.com/XVilka/8346728}here}.}}
       77: 
       78:       Some of the technical and historical background can be found in {{:
       79:       http://invisible-island.net/xterm/xterm.faq.html#problems_colors}
       80:       XTerm's FAQ}.
       81: 
       82:       {b Note} No attempt is made to remap colors depending on the terminal.
       83:       Terminals might ignore, remap, or completely misinterpret unsupported
       84:       colors. *)
       85: 
       86:   (** {2:corecolors Core 16 colors}
       87: 
       88:       The first 8 have their standard ANSI names. *)
       89:     val unsafe_color_of_int:int->color
       90: 
       91:   val black        : color
       92:   val red          : color
       93:   val green        : color
       94:   val yellow       : color
       95:   val blue         : color
       96:   val magenta      : color
       97:   val cyan         : color
       98:   val white        : color
       99:   val lightblack   : color
      100:   val lightred     : color
      101:   val lightgreen   : color
      102:   val lightyellow  : color
      103:   val lightblue    : color
      104:   val lightmagenta : color
      105:   val lightcyan    : color
      106:   val lightwhite   : color
      107: 
      108:   (** {2 Extended 256-color palette} *)
      109: 
      110:   val rgb : r:int -> g:int -> b:int -> color
      111:   (** [rgb ~r:red ~g:green ~b:blue] is an extended-palette color from the color cube.
      112: 
      113:       All three channels must be in the range [0 - 5]. XTerm default palette maps
      114:       this to [0x00], [0x5f], [0x87], [0xaf], [0xd7], and [0xff] independently
      115:       per channel.
      116: 
      117:       @raise Invalid_argument if a channel is outside the range. *)
      118: 
      119:   val gray : int -> color
      120:   (** [gray level] is an extended-palette color from the grayscale ramp.
      121: 
      122:       [level] must be in the range [0 - 23]. XTerm default palette maps this to
      123:       [8 + level * 10] on all three channels.
      124: 
      125:       @raise Invalid_argument if the [level] is outside the range. *)
      126: 
      127:   (** {2 True Color} *)
      128: 
      129:   val rgb_888 : r:int -> g:int -> b:int -> color
      130:   (** [rgb_888 ~r:red ~g:green ~b:blue] is a 24-bit color.
      131: 
      132:       All three channels must be in the range [0 - 255].
      133: 
      134:       @raise Invalid_argument if a channel is outside the range. *)
      135: 
      136:   (** {1 Text styles} *)
      137: 
      138:   type style
      139:   (** Additional text properties. *)
      140: 
      141:   val unsafe_style_of_int: int-> style
      142: 
      143:   val bold      : style
      144:   val italic    : style
      145:   val underline : style
      146:   val blink     : style
      147:   val reverse   : style
      148: 
      149:   (** {1 Attribute construction and composition} *)
      150: 
      151:   type t = attr
      152: 
      153:   val equal : t -> t -> bool
      154: 
      155:   val empty : attr
      156:   (** [empty] is the attribute with the default foreground and background color
      157:       and empty style set. *)
      158: 
      159:   val (++) : attr -> attr -> attr
      160:   (** [a1 ++ a2] is the concatenation of [a1] and [a2], the attribute that has
      161:       [a2]'s foreground (resp. background), unless {e unset}, in which case it
      162:       is [a1]'s, and the union of both style sets.
      163: 
      164:       [++] is left-associative, and forms a monoid with [empty]. *)
      165: 
      166:   val fg : color -> attr
      167:   (** [fg c] is [empty] with foreground [c]. *)
      168: 
      169:   val bg : color -> attr
      170:   (** [bg c] is [empty] with background [c]. *)
      171: 
      172:   val st : style -> attr
      173:   (** [st s] is [empty] with style [s]. *)
      174: end
      175: 
      176: (** [I] is for image.
      177: 
      178:     Construction and composition of images.
      179: 
      180:     Consult the {{!basics}basics} for an overview. *)
      181: module I : sig
      182: 
      183:   type t = image
      184: 
      185:   val height : image -> int
      186:   val width  : image -> int
      187: 
      188:   val equal : t -> t -> bool
      189:   (** [equal t1 t2] is [true] iff [t1] and [t2] are constructed by the same term.
      190: 
      191:       {b Note} This is a weak form of equality. Images that are not [equal]
      192:       could still render the same. *)
      193: 
      194:   (** {1:imgprims Primitives} *)
      195: 
      196:   val empty : image
      197:   (** [empty] is a zero-sized image. *)
      198: 
      199:   val string : attr -> string -> image
      200:   (** [string attr s] is an image containing text [s], styled with [attr].
      201: 
      202:       @raise Invalid_argument if [string] is not a valid UTF-8 sequence, or
      203:       contains {{!ctrls}control characters}. *)
      204: 
      205:   val uchars : attr -> Uchar.t array -> image
      206:   (** [uchars attr us] is an image containing text [us], styled with [attr].
      207: 
      208:       @raise Invalid_argument if [us] contains {{!ctrls}control characters}. *)
      209: 
      210:   val char : attr -> char -> int -> int -> image
      211:   (** [char attr c w h] is a [w * h] grid of [c].
      212: 
      213:       @raise Invalid_argument if [c] is a {{!ctrls}control character}. *)
      214: 
      215:   val uchar : attr -> Uchar.t -> int -> int -> image
      216:   (** [uchar attr u w h] is a [w * h] grid of [u].
      217: 
      218:       @raise Invalid_argument if [u] is a {{!ctrls}control character}. *)
      219: 
      220:   val void  : int -> int -> image
      221:   (** [void w h] is a [w * h] rectangle of transparent cells.
      222: 
      223:       [void] is magical: it has geometry, but no displayable content. This is
      224:       different, for example, from the space character [U+0020], which renders
      225:       as a cell filled with the background color. This means that [void]
      226:       interacts specially with {{!(</>)}overlays}.
      227: 
      228:       [void 0 0 = empty].
      229:       [void] with only one dimension [0] acts as a spacing element in the other
      230:       dimension. Negative size is treated as [0]. *)
      231: 
      232:   (** {1:imgcomp Image composition}
      233: 
      234:       Three basic composition modes allow construction of more complex images
      235:       from simpler ones.
      236: 
      237:       Composition operators are left-associative and form a monoid with [void].
      238:       *)
      239: 
      240:   val (<|>) : image -> image -> image
      241:   (**  [i1 <|> i2] is the horizontal combination of [i1] and [i2].
      242: 
      243:       [width (i1 <|> i2) = width i1 + width i2]
      244:       [height (i1 <|> i2) = max (height i1) (height i2)]
      245: 
      246:       Images are top-aligned. The missing region is implicitly filled with
      247:       {{!void}[void]}.
      248: 
      249: {v
      250: [x] <|> [y] = [xy]
      251:         [y]   [.y]
      252: v}
      253: 
      254:       where [.] denotes {{!void}[void]}. *)
      255: 
      256:   val (<->) : image -> image -> image
      257:   (** [i1 <-> i2] is the vertical combination of [i1] and [i2].
      258: 
      259:       [width (i1 <-> i2) = max (width i1) (width i2)]
      260:       [height (i1 <-> i2) = height i1 + height i2]
      261: 
      262:       Images are left-aligned. The missing region is implicitly filled with
      263:       {{!void}[void]}.
      264: 
      265: {v
      266: [xx] <-> [y] = [xx]
      267:                [y.]
      268: v}
      269:       *)
      270: 
      271:   val (</>) : image -> image -> image
      272:   (** [i1 </> i2] is [i1] overlaid over [i2].
      273: 
      274:       [width (i1 </> i2) = max (width i1) (width i2)]
      275:       [height (i1 </> i2) = max (height i1) (height i2)]
      276: 
      277:       Images are top-left-aligned. In the region of their overlap, only the
      278:       {{!void}[void]} cells of [i1] show fragments of [i2].
      279: 
      280: {v
      281: [x.x] </> [yyyy] = [xyxy]
      282: v}
      283:       *)
      284: 
      285:   (** {1:imgcrop Cropping and padding} *)
      286: 
      287:   val hcrop : int -> int -> image -> image
      288:   (** [hcrop left right i] is [i] with [left] leftmost, and [right]
      289:       rightmost columns missing. If [left + right >= width i] the result is
      290:       [empty].
      291: 
      292:       If either [left] or [right] is negative, instead of being cropped, the
      293:       image is padded on that side.
      294: 
      295:       For example:
      296:       {ul
      297:       {- [hcrop 0 1 [abc]] = [[ab]]}
      298:       {- [hcrop 1 1 [abc]] = [[b]]}
      299:       {- [hcrop (-1) 1 [abc]] = [void 1 1 <|> hcrop 0 1 [abc]] = [[.ab]]}
      300:       {- [hcrop 2 2 [abc]] = [empty]}} *)
      301: 
      302:   val vcrop : int -> int -> image -> image
      303:   (** [vcrop top bottom i] is the vertical analogue to {{!hcrop}[hcrop]}. *)
      304: 
      305:   val crop : ?l:int -> ?r:int -> ?t:int -> ?b:int -> image -> image
      306:   (** [crop ~l:left ~r:right ~t:top ~b:bottom i] is
      307:       [vcrop left right (hcrop top bottom) i].
      308: 
      309:       Missing arguments default to [0]. *)
      310: 
      311:   val hpad : int -> int -> image -> image
      312:   (** {{!hcrop}[hcrop]} with margins negated. *)
      313: 
      314:   val vpad : int -> int -> image -> image
      315:   (** {{!vcrop}[vcrop]} with margins negated. *)
      316: 
      317:   val pad : ?l:int -> ?r:int -> ?t:int -> ?b:int -> image -> image
      318:   (** {{!crop}[crop]} with margins negated. *)
      319: 
      320: 
      321:   (** {1 Additional combinators} *)
      322: 
      323:   val hcat : image list -> image
      324:   (** [hcat xs] horizontally concatenates [xs]. See {{!(<|>)}beside}. *)
      325: 
      326:   val vcat : image list -> image
      327:   (** [vcat xs] vertically concatenates [xs]. See {{!(<->)}above}. *)
      328: 
      329:   val zcat : image list -> image
      330:   (** [zcat xs] overlays [xs]. See {{!(</>)}over}. *)
      331: 
      332:   val tabulate : int -> int -> (int -> int -> image) -> image
      333:   (** [tabulate m n f] is the grid of values [f x y] with [x = 0..m-1]
      334:       and [y = 0..n-1], where [x] grows to the right, and [y] growns down.
      335: 
      336:       [f a y] is to the left of [f b y] if [a < b], and [f x a] is above [f x b]
      337:       if [a < b], but the exact alignment is unspecified if the various [f x y]
      338:       have different dimensions. *)
      339: 
      340:   val hsnap : ?align:[ `Left | `Middle | `Right ] -> int -> image -> image
      341:   (** [hsnap ~align w i] is an image of width strictly [w] obtained by either
      342:       horizontally padding or cropping [i] and positioning it according to
      343:       [~align].
      344: 
      345:       [~align] defaults to [`Middle]. *)
      346: 
      347:   val vsnap : ?align:[ `Top | `Middle | `Bottom ] -> int -> image -> image
      348:   (** [vsnap ~align h i] is an image of height strictly [h] obtained by either
      349:       vertically padding or cropping [i] and positioning it according to
      350:       [~align].
      351: 
      352:       [~align] defaults to [`Middle]. *)
      353: 
      354:   (** {1 [Format] interoperability} *)
      355: 
      356:   val strf : ?attr:attr -> ?w:int -> ('a, Format.formatter, unit, image) format4 -> 'a
      357:   (** [strf ?attr ?w:width format ...] pretty-prints like
      358:       [Format.asprintf format ...], but returns an [image].
      359: 
      360:       [attr] is the (outermost) attribute. Defaults to {!A.empty}.
      361: 
      362:       [width] is used to set the margin on the formatter. This is only a hint,
      363:       and does not guarantee the width of the result. Consult
      364:       {{: http://caml.inria.fr/pub/docs/manual-ocaml/libref/Format.html#VALset_margin}
      365:       [Format.set_margin]} for details. Defaults to an unspecified, large
      366:       number.
      367: 
      368:       @raise Invalid_argument if the printing process attempts to directly
      369:       output {{!ctrls}control characters}, by embedding them in [format] or a
      370:       string printed with the [%s] conversion, for example.
      371:       {{: http://caml.inria.fr/pub/docs/manual-ocaml/libref/Format.html#fpp}
      372:       Formatted printing} is allowed. *)
      373: 
      374:   val kstrf : ?attr:attr -> ?w:int -> (image -> 'a) -> ('b, Format.formatter, unit, 'a) format4 -> 'b
      375:   (** [kstrf ?attr ?w k format ...] is continuation-based [strf ?attr ?w format ...]. *)
      376: 
      377:   val pp_attr : attr -> (Format.formatter -> 'a -> unit) -> Format.formatter -> 'a -> unit
      378:   (** [pp_attr a f] is a pretty-printer like [f], except its output is styled
      379:       with [a]. This applies only outside of any styling [f] itself might embed. *)
      380: end
      381: 
      382: (** Operators, repeated. *)
      383: module Infix : sig
      384: 
      385:   (** {2 [I]}
      386: 
      387:       See {{!I}[I]}. *)
      388: 
      389:   val (<->) : image -> image -> image
      390:   val (<|>) : image -> image -> image
      391:   val (</>) : image -> image -> image
      392: 
      393:   (** {2 [A]}
      394: 
      395:       See {{!A}[A]}. *)
      396: 
      397:   val (++)  : attr -> attr -> attr
      398: end
      399: 
      400: (** {1 Low-level interface}
      401: 
      402:     You can ignore it, unless you are porting [Notty] to a new platform not
      403:     supported by the existing IO backends. *)
      404: 
      405: (** Terminal capabilities.
      406: 
      407:     This module describes how to output things so that a terminal understands
      408:     them. *)
      409: module Cap : sig
      410: 
      411:   type t
      412:   (** A set of capabilities that distinguish terminals from one another.
      413: 
      414:       A bundle of magic strings, really. *)
      415: 
      416:   val ansi : t
      417:   (** The usual ANSI terminal, with colors, text styles and cursor
      418:       positioning. *)
      419: 
      420:   val dumb : t
      421:   (** Pure text output. Text attributes are stripped and positioning is done
      422:       with the character [U+0020], SPACE. *)
      423: end
      424: 
      425: (** Dump images to string buffers. *)
      426: module Render : sig
      427: 
      428:   val to_buffer : Buffer.t -> Cap.t -> int * int -> int * int -> image -> unit
      429:   (** [to_buffer buf cap (x, y) (w, h) i] writes the string representation of
      430:       [i] to [buf], as interpreted by [cap].
      431: 
      432:       It renders the [w * h] rectangle of [i], offset by [(x, y)] from the top
      433:       left. *)
      434: 
      435:   val pp : Cap.t -> Format.formatter -> image -> unit
      436:   (** [pp cap ppf i] renders [i] to the pretty-printer [ppf].
      437: 
      438:       {b Note} [pp] is generally meant for development and debugging. It tries
      439:       to be reasonable, but dedicated IO modules handle the actual output
      440:       better. *)
      441: 
      442:   (**/**)
      443:   (* Toplevel. *)
      444:   val pp_image : Format.formatter -> image -> unit
      445:   val pp_attr : Format.formatter -> attr -> unit
      446:   (**/**)
      447: end
      448: 
      449: (** Parse and decode escape sequences in character streams. *)
      450: module Unescape : sig
      451: 
      452:   (** {1 Input events} *)
      453: 
      454:   type special = [
      455:     `Escape
      456:   | `Enter
      457:   | `Tab
      458:   | `Backspace
      459:   | `Insert
      460:   | `Delete
      461:   | `Home | `End
      462:   | `Arrow of [ `Up | `Down | `Left | `Right ]
      463:   | `Page of [ `Up | `Down ]
      464:   | `Function of int
      465:   ]
      466:   (** A selection of extra keys on the keyboard. *)
      467: 
      468:   type button = [ `Left | `Middle | `Right | `Scroll of [ `Up | `Down ] ]
      469:   (** Mouse buttons. *)
      470: 
      471:   type mods = [ `Meta | `Ctrl | `Shift ] list
      472:   (** Modifier state. *)
      473: 
      474:   type key = [ special | `Uchar of Uchar.t | `ASCII of char ] * mods
      475:   (** Keypress event. *)
      476: 
      477:   type mouse = [ `Press of button | `Drag | `Release ] * (int * int) * mods
      478:   (** Mouse event. *)
      479: 
      480:   type paste = [ `Start | `End ]
      481:   (** Paste event. *)
      482: 
      483:   type event = [ `Key of key | `Mouse of mouse | `Paste of paste ]
      484:   (** Things that terminals say to applications.
      485: 
      486:       {ul
      487:       {- [`Key (k, mods)] is keyboard input.
      488: 
      489:          [k] is a {{!key}key}, one of:
      490:          {ul
      491:          {- [`ASCII c] where [c] is a [char] in the
      492:             {{: https://tools.ietf.org/html/rfc20}ASCII} range;}
      493:          {- [`Uchar u] where [u] is any other {{!Uchar.t}unicode character}; or}
      494:          {- a {{!special}special key}.}}
      495: 
      496:          [`ASCII] and [`Uchar] together represent the textual part of the input.
      497:          These characters are guaranteed not to be {{!ctrls}control
      498:          characters}, and are safe to use when constructing images. ASCII is
      499:          separated from the rest of Unicode for convenient pattern-matching.
      500: 
      501:          [mods] are the extra {{!mods}modifier keys}.
      502: 
      503:          }
      504:       {- [`Mouse (event, (x, y), mods)] is mouse input.
      505: 
      506:          [event] is the actual mouse event: {{!button}[button]} press, release,
      507:          or motion of the mouse with buttons depressed.
      508: 
      509:          [(x, y)] are column and row position of the mouse. The origin is
      510:          [(0,0)], the upper-left corner.
      511: 
      512:          {b Note} Every [`Press (`Left|`Middle|`Right)] generates a corresponding
      513:          [`Release], but there is no portable way to detect which button was
      514:          released. [`Scroll (`Up|`Down)] presses are not followed by releases.
      515: 
      516:          }
      517:       {- [`Paste (`Start|`End)] are {e bracketed paste} events, signalling the
      518:          beginning and end of a sequence of events pasted into the terminal.
      519: 
      520:          {b Note} This mechanism is useful, but not reliable. The pasted text
      521:          could contain spurious start-of-paste or end-of-paste markers, or they
      522:          could be entered by hand. }}
      523: 
      524:       Terminal input protocols are historical cruft, and heavily overload the
      525:       ASCII range. For instance:
      526:       {ul
      527:       {- It is impossible to distinguish lower- and upper-case ASCII characters
      528:          if {b Ctrl} is pressed;}
      529:       {- several combinations of key-presses are aliased as special keys; and}
      530:       {- in a UTF-8 encoded stream, there is no representation for non-ASCII
      531:          characters with modifier keys.}}
      532: 
      533:       This means that many values that inhabit the [event] type are impossible,
      534:       while some reflect multiple different user actions. Limitations include:
      535: 
      536:       {ul
      537:       {- [`Shift] is reported only with special keys, and not all of them.}
      538:       {- [`Meta] and [`Control] are reported with mouse events, key events with
      539:          special keys, and key events with values in the ranges [0x40-0x5f]
      540:          ([@] to [_]) and [0x60-0x7e] ([`] to [~]). If {b Ctrl} is pressed, the higher
      541:          range is mapped into the lower range.}
      542:       {- Terminals will variously under-report modifier key state.}}
      543: 
      544:       Perform own experiments before relying on elaborate key combinations. *)
      545: 
      546:   val uchar : [< `Uchar of Uchar.t | `ASCII of char ] -> Uchar.t
      547:   (** [uchar x] is the {!Uchar.t} corresponding to [x]. This operations merges
      548:       the ASCII and Unicode variants of {{!key}key}. *)
      549: 
      550:   (** {1 Decoding filter}
      551: 
      552:       Simple IO-less terminal input processor. It can be used for building
      553:       custom terminal input abstractions. *)
      554: 
      555:   type t
      556:   (** Input decoding filter.
      557: 
      558:       The filter should be {{!input}fed} strings, which it first decodes from
      559:       UTF-8, and then extracts the input events.
      560: 
      561:       Malformed UTF-8 input bytes and unrecognized escape sequences are silently
      562:       discarded. *)
      563: 
      564:   val create : unit -> t
      565:   (** [create ()] is a new, empty filter. *)
      566: 
      567:   val input : t -> bytes -> int -> int -> unit
      568:   (** [input t buffer i len] feeds [len] bytes of [string] into [t], starting
      569:       from position [len].
      570: 
      571:       [len = 0] signals the end of input.
      572: 
      573:       [buffer] is immediately processed and can be reused after the call
      574:       returns. *)
      575: 
      576:   val next : t -> [ event | `Await | `End ]
      577:   (** [next t] is the next event in the filter's input stream:
      578: 
      579:       {ul
      580:       {- [#event], an input {{!event}[event]}.}
      581:       {- [`Await] if the filter needs more {{!input}input}.}
      582:       {- [`End] if the input had ended.}} *)
      583: 
      584:   val pending : t -> bool
      585:   (** [pending t] is [true] if a call to [next], without any intervening input,
      586:       would {e not} return [`Await]. *)
      587: 
      588:   (** {1 Low-level parsing}
      589: 
      590:       {b Warning} The parsing interface is subject to change.
      591: 
      592:       Implementation of small parts of
      593:       {{: http://www.ecma-international.org/publications/standards/Ecma-035.htm}ECMA-35}
      594:       and
      595:       {{: http://www.ecma-international.org/publications/standards/Ecma-048.htm}ECMA-48},
      596:       as needed by terminal emulators in common use. *)
      597: 
      598:   val decode : Uchar.t list -> event list
      599:   (** [decode us] are the events encoded by [us].
      600: 
      601:       [us] are assumed to have been generated in a burst, and the end of the
      602:       list is taken to mean a pause.
      603:       Therefore, [decode us1 @ decode us2 <> decode (us1 @ us2)] if [us1] ends
      604:       with a partial escape sequence, including a lone [\x1b].
      605: 
      606:       Unsupported escape sequences are silently discarded. *)
      607: end
      608: 
      609: (**/**)
      610: (** {1 Private}
      611: 
      612:     These are private interfaces, prone to breakage. Don't use them. *)
      613: 
      614: module Operation : sig
      615:   type t
      616:   val of_image : (int * int) -> int * int -> image -> t list
      617: end
      618: 
      619: module Tmachine : sig
      620: 
      621:   type t
      622: 
      623:   val create  : mouse:bool -> bpaste:bool -> Cap.t -> t
      624:   val release : t -> bool
      625:   val output  : t -> Buffer.t -> unit
      626: 
      627:   val refresh  : t -> unit
      628:   val cursor   : t -> (int * int) option -> unit
      629:   val image    : t -> image -> unit
      630: 
      631:   val set_size : t -> int * int -> unit
      632: 
      633:   val size : t -> int * int
      634:   val dead : t -> bool
      635: end
      636: 
      637: module Direct : sig
      638:   val move_cursor : Buffer.t -> Cap.t -> [ `Home | `By of int * int | `To of int * int ] -> unit
      639:   val show_cursor : Buffer.t -> Cap.t -> bool -> unit
      640: end
      641: (**/**)
      642: 
      643: (** {1:basics Basics}
      644: 
      645:     Print a red-on-black ["Wow!"] above its right-shifted copy:
      646: {[
      647: let wow = I.string A.(fg red ++ bg black) "Wow!" in
      648: I.(wow <-> (void 2 0 <|> wow)) |> Notty_unix.output_image
      649: ]}
      650: 
      651:     {2:meaning The meaning of images}
      652: 
      653:     An {{!image}[image]} value is a rectangle of styled character cells. It has a
      654:     width and height, but is not anchored to an origin. A single character with
      655:     associated display attributes, or a short fragment of text, are simple
      656:     examples of images.
      657: 
      658:     Images are created by combining text fragments with {{!attributes}display
      659:     attributes}, and composed by placing them {{!I.(<|>)}beside} each other,
      660:     {{!I.(<->)}above} each other, and {{!I.(</>)}over} each other.
      661: 
      662:     Once constructed, an image can be rendered, and only at that point it obtains
      663:     absolute placement.
      664: 
      665:     Consult {{!I}[I]} for more details.
      666: 
      667:     {2:attributes Display attributes}
      668: 
      669:     {{!attr}[attr]} values describe the styling characteristics of fragments of
      670:     text.
      671: 
      672:     They combine a foreground and a background {{!A.color}[color]} with a
      673:     set of {{!A.style}[styles]}. Either color can be {e unset}, which corresponds to
      674:     the terminal's default foreground (resp. background) color.
      675: 
      676:     Attributes are used to construct primitive images.
      677: 
      678:     Consult {{!A}[A]} for more details.
      679: 
      680:     {2:ctrls Control characters}
      681: 
      682:     These are taken to be characters in the ranges [0x00-0x1f] ({b C0}), [0x7f]
      683:     (BACKSPACE), [0x80-0x9f] ({b C1}). This is the
      684:     {{: http://unicode.org/reports/tr44/#General_Category_Values}Unicode
      685:     general category} {b Cc}.
      686: 
      687:     As control characters directly influence the cursor positioning, they
      688:     cannot be used to create images.
      689: 
      690:     This, in particular, means that images cannot contain [U+000a] (NEWLINE).
      691: 
      692:     {1:limitations Limitations}
      693: 
      694:     [Notty] does not use Terminfo. If your terminal is particularly
      695:     idiosyncratic, things might fail to work. Get in touch with the author to
      696:     expand support.
      697: 
      698:     [Notty] assumes that the terminal is using UTF-8 for input and output.
      699:     Things might break arbitrarily if this is not the case.
      700: 
      701:     For performance considerations, consult the {{!perf}performance model}.
      702: 
      703:     {2:cwidth Unicode vs. Text geometry}
      704: 
      705:     [Notty] uses [Uucp.Break.tty_width_hint] to guess the width of text
      706:     fragments when computing geometry, and it suffers from the same
      707:     shortcomings:
      708: 
      709:     {ul
      710:     {- Geometry in general works for alphabets and east Asian scripts, mostly
      711:         works for abjad scripts, and is a matter of luck for abugidas.}
      712:     {- East Asian scripts work better when in
      713:         {{:http://unicode.org/glossary/#normalization_form_c}NFC}.}
      714:     {- For proper emoji display, [Uucp] and the terminal have to agree on the
      715:        Unicode version.}}
      716: 
      717:     When in doubt, see
      718:     {{: http://erratique.ch/software/uucp/doc/Uucp.Break.html#VALtty_width_hint}
      719:     [Uucp.Break.tty_width_hint]}.
      720: 
      721:     Unicode has special interaction with {{!I.hcrop}horizontal cropping}:
      722:     {ul
      723:     {- Strings within images are cropped at {{:
      724:         http://unicode.org/reports/tr29/#Grapheme_Cluster_Boundaries}grapheme
      725:         cluster} boundaries. This means that scalar value sequences that are
      726:         rendered combined, or overlaid, stay unbroken.}
      727:     {- When a crop splits a wide character in two, the remaining half is
      728:         replaced by [U+0020] (SPACE). Hence, character-cell-accurate cropping is
      729:         possible even in the presence of characters that horizontally occupy
      730:         more than one cell.}}
      731: 
      732:     {1:examples Examples}
      733: 
      734:     We assume a toplevel with [Notty] support ([#require "notty.top"]).
      735: 
      736:     {2 Hello}
      737: 
      738:     ["Rad!"] with default foreground and background:
      739: 
      740:     {[I.string A.empty "Rad!"]}
      741: 
      742:     Everything has to start somewhere.
      743: 
      744:     {2 Colors}
      745: 
      746:     ["Rad!"] in rad letters:
      747: 
      748:     {[I.string A.(fg lightred) "Rad!"]}
      749: 
      750:     {2 Padding and spacing}
      751: 
      752: {[
      753: let a1 = A.(fg lightwhite ++ bg red)
      754: and a2 = A.(fg red)
      755: ]}
      756: 
      757:     ["Rad"] and [" stuff!"] in different colors:
      758: 
      759:     {[I.(string a1 "Rad" <|> string a2 " stuff!")]}
      760: 
      761:     The second word hanging on a line below:
      762: 
      763:     {[I.(string a1 "Rad" <|> (string a2 "stuff!" |> vpad 1 0))]}
      764: 
      765:     {2 More geometry}
      766: 
      767:     Sierpinski triangle:
      768: 
      769: {[
      770: let square = "\xe2\x96\xaa"
      771: 
      772: let rec sierp n =
      773:   if n > 1 then
      774:     let ss = sierp (pred n) in I.(ss <-> (ss <|> ss))
      775:   else I.(string A.(fg magenta) square |> hpad 1 0)
      776: ]}
      777: 
      778:     {[sierp 8]}
      779: 
      780:     A triangle overlaid over its shifted copy:
      781: 
      782:     {[let s = sierp 6 in I.(s </> vpad 1 0 s)]}
      783: 
      784:     Blinkenlights:
      785: 
      786: {[
      787: let rad n color =
      788:   let a1 = A.fg color in
      789:   let a2 = A.(st blink ++ a1) in
      790:   I.((string a2 "Rad" |> hpad n 0) <->
      791:      (string a1 "(⌐■_■)" |> hpad (n + 7) 0))
      792: 
      793: let colors = A.[red; green; yellow; blue; magenta; cyan]
      794: ]}
      795: 
      796: {[
      797: colors |> List.mapi I.(fun i c -> rad i c |> pad ~t:i ~l:(2 * i))
      798:        |> I.zcat
      799: ]}
      800: 
      801:     {b Note} Usage of {{!A.blink}[blink]} might be regulated by law in some
      802:     jurisdictions.
      803: 
      804:     {2 Pretty-printing}
      805: 
      806:     Images can be pretty-printed into:
      807: 
      808:     {[I.strf "(%d)" 42]}
      809: 
      810:     Attributes can be applied to the entire format string, or by decorating
      811:     {e user-defined printers} that are supplied with [%a] conversions:
      812: 
      813:     {[let pp = Format.pp_print_int]}
      814: 
      815:     {[I.strf ~attr:A.(fg lightwhite) "(%a)" (I.pp_attr A.(fg green) pp) 42]}
      816: 
      817:     {2 Now with output}
      818: 
      819:     The core module has no real IO. Examples above are simple [image]-valued
      820:     expressions, displayed by the pretty-printer that is installed by the
      821:     toplevel support. Self-contained programs need a separate IO module:
      822: 
      823:     {[#require "notty.unix"]}
      824: 
      825:     {[sierp 8 |> Notty_unix.output_image]}
      826: 
      827:     (Note the difference in cropping behavior.)
      828: 
      829:     Computations can be adapted to the current terminal size. A line can stretch
      830:     end-to-end:
      831: 
      832: {[
      833: Notty_unix.output_image_size @@ fun (w, _) ->
      834:   let i1 = I.string A.(fg green) "very"
      835:   and i2 = I.string A.(fg yellow) "melon" in
      836:   I.(i1 <|> void (w - width i1 - width i2) 1 <|> i2)
      837: ]}
      838: 
      839:     The largest triangle that horizontally fits into the terminal:
      840: 
      841: {[
      842: Notty_unix.output_image_size @@ fun (w, _) ->
      843:   let steps = int_of_float ((log (float w)) /. log 2.) in
      844:   sierp steps |> I.vpad 0 1
      845: ]}
      846: 
      847:     {2 Simple interaction}
      848: 
      849:     Interactive Sierpinski:
      850: 
      851:     {[open Notty_unix]}
      852: 
      853: {[
      854: let img (double, n) =
      855:   let s = sierp n in
      856:   if double then I.(s </> vpad 1 0 s) else s
      857: in
      858: let rec update t state = Term.image t (img state); loop t state
      859: and loop t (double, n as state) =
      860:   match Term.event t with
      861:   | `Key (`Enter,_)        -> ()
      862:   | `Key (`Arrow `Left,_)  -> update t (double, max 1 (n - 1))
      863:   | `Key (`Arrow `Right,_) -> update t (double, min 8 (n + 1))
      864:   | `Key (`ASCII ' ', _)   -> update t (not double, n)
      865:   | `Resize _              -> update t state
      866:   | _                      -> loop t state
      867: in
      868: let t = Term.create ()
      869: in
      870: update t (false, 1); Term.release t
      871: ]}
      872: 
      873:     The program uses a fullscreen {{!Notty_unix.Term}terminal} and loops reading
      874:     the {{!Notty_unix.Term.event}input}. LEFT and RIGHT control the iteration
      875:     count, and SPACE toggles double-drawing. Resizing the window causes a
      876:     redraw. When the loop exits on ENTER, the terminal is
      877:     {{!Notty_unix.Term.release}cleaned up}.
      878: 
      879:     {1:perf Performance model}
      880: 
      881:     This section is only relevant if using [Notty] becomes your bottleneck.
      882: 
      883:     {b TL;DR} Shared sub-expressions do not share work, so operators stick with
      884:     you.
      885: 
      886:     The main performance parameter is {e image complexity}. This roughly
      887:     corresponds to the number of image {{!I.imgcomp}composition} and
      888:     {{!I.imgcrop}cropping} operators in the fully expanded [image] term,
      889:     {b ignoring all sharing}.
      890: 
      891:     Outline numbers:
      892: 
      893:     {ul
      894:     {- Highly complex images can be rendered and pushed out to a full-screen
      895:        terminal more than 1000 times per second.}
      896:     {- With more realistic images, this number is closer to 30,000.}
      897:     {- Input processing is somewhere around 50MB/s.}}
      898: 
      899: 
      900:     Image complexity [cplx] of an image [i] is:
      901:     {ul
      902:     {- For a {{!I.imgprims}primitive} [i], [cplx i = 1].}
      903:     {- For a {{!I.imgcomp}composition} operator [op],
      904:        [cplx (op i1 i2) = 1 + cplx i1 + cplx i2].}
      905:     {- For a {{!I.imgcomp}crop} [cr],
      906:        [cplx (cr i1) = 1 + cplx i1 - k], where [k] is the combined complexity of
      907:        all the {e maximal} sub-terms that do not contribute to the output.}}
      908: 
      909:     For example (assuming an image [i]):
      910: 
      911: {[
      912:   let img1 = I.((i <|> i) <-> (i <|> i))
      913:   let img2 = I.(let x = i <|> i in x <-> x)
      914:   let img3 = I.(((i <|> i) <|> i) <|> i)
      915: ]}
      916: 
      917:     Complexity of each of these is [4 * cplx i + 3]. This might be surprising
      918:     for [img2].
      919: 
      920:     If [width i = 1], [cplx (hcrop 1 0 img1) = 3 + 2 * cplx i], and
      921:     [cplx (hcrop 2 0 img3) = 2 + 2 * cplx i].
      922: 
      923:     While [Notty] strives to be accommodating to all usage scenarios, these are
      924:     the things to keep in mind if the rendering becomes slow:
      925: 
      926:     {ol
      927:     {- Image composition is cheap.
      928: 
      929:        Combining images performs a negligible amount of computation.
      930: 
      931:        Constructing primitive images that contain scalar values outside of the
      932:        ASCII range does a little more work upfront and is worth holding onto.
      933: 
      934:        }
      935:     {- {{!Render}Rendering} depends on image complexity.
      936: 
      937:        As a consequence, this real-world example of wrapping renders in time
      938:        O(n{^ 2}) in the number of lines:
      939: 
      940: {[
      941: let wrap1 width img =
      942:   let rec go img = img ::
      943:     if I.width img > width then go (I.hcrop width 0 img) else []
      944:   in go img |> I.vcat |> I.hsnap ~align:`Left width
      945: ]}
      946: 
      947:        Although [crop] is applied only [lines] times, the image complexity of
      948:        each line depends on the number of preceding lines.
      949: 
      950:        An O(n) version does not iterate [crop]:
      951: 
      952: {[
      953: let wrap2 width img =
      954:   let rec go off = I.hcrop off 0 img ::
      955:     if I.width img - off > width then go (off + width) else []
      956:   in go 0 |> I.vcat |> I.hsnap ~align:`Left width
      957: ]}
      958:        }
      959:     {- Rendering depends on the {e output} dimensions, but not on the {e image}
      960:        dimensions.
      961: 
      962:        Rendering an image to [w * h] implicitly crops it to its leftmost [w]
      963:        columns and topmost [h] rows. While [w] and [h] will have an impact on
      964:        the rendering performance, the complexity of the (cropped) image tends to
      965:        be more important.}}
      966: 
      967: *)
Added regular file ../notty/src/notty_top.ml:
        1: (* Copyright (c) 2017 David Kaloper Meršinjak. All rights reserved.
        2:    See LICENSE.md. *)
        3: 
        4: (* Force linking with Notty for e.g. Omod. *)
        5: let _ = Sys.opaque_identity Notty.I.empty
        6: 
        7: #if OCAML_VERSION >= (4,14,0)
        8: let _ = Toploop.use_silently Format.err_formatter (Toploop.File "notty_top_init.ml")
        9: #else
       10: let _ = Toploop.use_silently Format.err_formatter "notty_top_init.ml"
       11: #endif
Added regular file ../notty/src/notty_top_init.ml:
        1: (* Copyright (c) 2017 David Kaloper Meršinjak. All rights reserved.
        2:    See LICENSE.md. *)
        3: 
        4: open Notty;;
        5: 
        6: #install_printer Notty.Render.pp_image;;
        7: #install_printer Notty.Render.pp_attr;;
Added regular file ../notty/src-lwt/dune:
        1: (library
        2:   (public_name notty.lwt)
        3:   (synopsis "Notty Lwt+Unix IO")
        4:   (name notty_lwt)
        5:   (wrapped false)
        6:   (optional)
        7:   (libraries notty notty.unix lwt lwt.unix))
Added regular file ../notty/src-lwt/notty_lwt.ml:
        1: (* Copyright (c) 2016-2017 David Kaloper Meršinjak. All rights reserved.
        2:    See LICENSE.md. *)
        3: 
        4: open Lwt.Infix
        5: 
        6: open Notty
        7: open Notty_unix
        8: open Private
        9: 
       10: 
       11: type ('a, 'b) either = Left of 'a | Right of 'b
       12: let left  x = Left x
       13: let right y = Right y
       14: 
       15: let (</>) a b = Lwt.pick [(a >|= left); (b >|= right)]
       16: let (<??>) a b = (a >|= left) <?> (b >|= right)
       17: 
       18: let whenopt f = function Some x -> f x | None -> ()
       19: 
       20: let rec write fd buf off = function
       21:   | 0 -> Lwt.return_unit
       22:   | n -> Lwt_unix.write fd buf off n >>= fun w -> write fd buf (off + w) (n - w)
       23: 
       24: module Lwt_condition = struct
       25: 
       26:   include Lwt_condition
       27: 
       28:   let map f c =
       29:     let d = create () in
       30:     let rec go () = wait c >>= fun x -> broadcast d (f x); go ()
       31:     in (Lwt.async go; d)
       32: 
       33:   let unburst ~t c =
       34:     let d = create () in
       35:     let rec delay x = Lwt_unix.sleep t </> wait c >>= function
       36:       | Left () -> broadcast d x; start ()
       37:       | Right x -> delay x
       38:     and start () = wait c >>= delay in
       39:     Lwt.async start; d
       40: end
       41: 
       42: module Term = struct
       43: 
       44:   let winches = lazy (
       45:     let c = Lwt_condition.create () in
       46:     let `Revert _ = set_winch_handler (Lwt_condition.broadcast c) in
       47:     c
       48:   )
       49: 
       50:   let winch () = Lazy.force winches |> Lwt_condition.wait
       51: 
       52:   let bsize = 1024
       53: 
       54:   let input_stream ~nosig fd stop =
       55:     let `Revert f = setup_tcattr ~nosig (Lwt_unix.unix_file_descr fd) in
       56:     let stream =
       57:       let flt  = Unescape.create ()
       58:       and ibuf = Bytes.create bsize in
       59:       let rec next () =
       60:         match Unescape.next flt with
       61:         | #Unescape.event as r -> Lwt.return_some r
       62:         | `End   -> Lwt.return_none
       63:         | `Await ->
       64:             (Lwt_unix.read fd ibuf 0 bsize <??> stop) >>= function
       65:               | Left n  -> Unescape.input flt ibuf 0 n; next ()
       66:               | Right _ -> Lwt.return_none
       67:       in Lwt_stream.from next in
       68:     Lwt.async (fun () -> Lwt_stream.closed stream >|= f);
       69:     stream
       70: 
       71:   type t = {
       72:     ochan  : Lwt_io.output_channel
       73:   ; trm    : Tmachine.t
       74:   ; buf    : Buffer.t
       75:   ; fds    : Lwt_unix.file_descr * Lwt_unix.file_descr
       76:   ; events : [ Unescape.event | `Resize of (int * int) ] Lwt_stream.t
       77:   ; stop   : (unit -> unit)
       78:   }
       79: 
       80:   let write t =
       81:     Tmachine.output t.trm t.buf;
       82:     let out = Buffer.contents t.buf in (* XXX There goes 0copy. :/ *)
       83:     Buffer.clear t.buf; Lwt_io.write t.ochan out
       84: 
       85:   let refresh t      = Tmachine.refresh t.trm; write t
       86:   let image t image  = Tmachine.image t.trm image; write t
       87:   let cursor t curs  = Tmachine.cursor t.trm curs; write t
       88:   let set_size t dim = Tmachine.set_size t.trm dim
       89:   let size t         = Tmachine.size t.trm
       90: 
       91:   let release t =
       92:     if Tmachine.release t.trm then
       93:       ( t.stop (); write t >>= fun () -> Lwt_io.flush t.ochan )
       94:     else Lwt.return_unit
       95: 
       96:   let resizef fd stop on_resize =
       97:     if Unix.isatty fd then
       98:       let rcond = Lwt_condition.(
       99:         Lazy.force winches |> unburst ~t:0.1 |> map (fun () -> winsize fd)) in
      100:       let rec monitor () =
      101:         (Lwt_condition.wait rcond <?> stop) >>= function
      102:           | Some dim -> on_resize dim; monitor ()
      103:           | None     -> Lwt.return_unit in
      104:       Lwt.async monitor;
      105:       Lwt_stream.from (fun () -> Lwt_condition.wait rcond <?> stop)
      106:         |> Lwt_stream.map (fun dim -> `Resize dim)
      107:     else Lwt_stream.of_list []
      108: 
      109:   let create ?(dispose=true) ?(nosig=true) ?(mouse=true) ?(bpaste=true)
      110:              ?(input=Lwt_unix.stdin) ?(output=Lwt_unix.stdout) () =
      111:     let fd = Lwt_unix.unix_file_descr output in
      112:     let (stop, stopw) = Lwt.wait () in
      113:     let rec t = lazy {
      114:         trm    = Tmachine.create ~mouse ~bpaste (cap_for_fd fd)
      115:       ; ochan  = Lwt_io.(of_fd ~mode:output) output
      116:       ; buf    = Buffer.create 4096
      117:       ; fds    = (input, output)
      118:       ; stop   = (fun () -> Lwt.wakeup stopw None)
      119:       ; events = Lwt_stream.choose
      120:           [ input_stream ~nosig input stop
      121:           ; resizef fd stop @@ fun dim ->
      122:               let t = Lazy.force t in Buffer.reset t.buf; set_size t dim ]
      123:       } in
      124:     let t = Lazy.force t in
      125:     winsize fd |> whenopt (set_size t);
      126:     Lwt.async (fun () -> write t); (* XXX async? *)
      127:     if dispose then Lwt_main.at_exit (fun () -> release t);
      128:     t
      129: 
      130:   let events t = t.events
      131:   let fds    t = t.fds
      132: end
      133: 
      134: let winsize fd = winsize (Lwt_unix.unix_file_descr fd)
      135: 
      136: include Gen_output (struct
      137:   type fd = Lwt_unix.file_descr and k = unit Lwt.t
      138:   let (def, to_fd) = Lwt_unix.(stdout, unix_file_descr)
      139:   and write fd buf = Buffer.(write fd (to_bytes buf) 0 (length buf))
      140: end)
Added regular file ../notty/src-lwt/notty_lwt.mli:
        1: (* Copyright (c) 2016-2017 David Kaloper Meršinjak. All rights reserved.
        2:    See LICENSE.md. *)
        3: 
        4: (** [Notty] IO [Lwt] on [Unix].
        5: 
        6:     This is an IO module for {!Notty}.
        7: 
        8:     It mirrors {!Notty_unix} and the corresponding operations behave
        9:     analogously. Consult its documentation for more info.
       10: 
       11:     {e %%VERSION%% — {{:%%PKG_HOMEPAGE%% }homepage}} *)
       12: 
       13: open Notty
       14: 
       15: (** {1:fullscreen Fullscreen input and output}. *)
       16: 
       17: (** Terminal IO with concurrency.
       18: 
       19:     For more info, see {!Notty_unix.Term}. *)
       20: module Term : sig
       21: 
       22:   type t
       23: 
       24:   (** {1 Construction and destruction} *)
       25: 
       26:   val create : ?dispose:bool ->
       27:                ?nosig:bool ->
       28:                ?mouse:bool ->
       29:                ?bpaste:bool ->
       30:                ?input:Lwt_unix.file_descr ->
       31:                ?output:Lwt_unix.file_descr ->
       32:                unit -> t
       33:   (** [create ~dispose ~nosig ~mouse ~input ~output ()] creates a new
       34:       {{!t}terminal}.
       35: 
       36:       {b Note} [~dispose] arranges for the terminal to be disposed of at the end
       37:       of the [Lwt] main loop, and not at process exit.
       38: 
       39:       See {!Notty_unix.Term.create}. *)
       40: 
       41:   val release : t -> unit Lwt.t
       42: 
       43:   (** {1 Commands} *)
       44: 
       45:   val image   : t -> image -> unit Lwt.t
       46:   val refresh : t -> unit Lwt.t
       47:   val cursor  : t -> (int * int) option -> unit Lwt.t
       48: 
       49:   (** {1 Events} *)
       50: 
       51:   val events : t -> [ Unescape.event | `Resize of (int * int) ] Lwt_stream.t
       52:   (** [events t] is the stream of incoming events.
       53: 
       54:       Invoking {{!release}release} will terminate this stream.
       55: 
       56:       Events are:
       57:       {ul
       58:       {- [#Unescape.event], an {{!Notty.Unescape.event}event} from the input
       59:          fd; or}
       60:       {- [`Resize (cols, rows)] whenever the terminal size changes.}}
       61: 
       62:       {b Note} This stream is unique; for the same [t], [events t] always
       63:       returns the same stream. *)
       64: 
       65:   (** {1 Properties} *)
       66: 
       67:   val size : t -> int * int
       68: 
       69:   val fds : t -> Lwt_unix.file_descr * Lwt_unix.file_descr
       70: 
       71:   (** {1 Window size change notifications}
       72: 
       73:       {{!create}Creating} a terminal will install a [SIGWINCH] handler.
       74:       The handler should not be replaced directly. This API allows the user to
       75:       monitor deliveries of the signal.
       76: 
       77:       See {!Notty_unix.Term.Winch}. *)
       78: 
       79:   val winch : unit -> unit Lwt.t
       80:   (** [winch ()] is a thread completing after the next [SIGWINCH]. A single
       81:       signal delivery will cause the completion of all waiting [winch] threads. *)
       82: end
       83: 
       84: (** {1:inline Inline output} *)
       85: 
       86: val winsize : Lwt_unix.file_descr -> (int * int) option
       87: 
       88: val eol : image -> image
       89: 
       90: val output_image :
       91:   ?cap:Cap.t -> ?fd:Lwt_unix.file_descr -> image -> unit Lwt.t
       92: 
       93: val output_image_size :
       94:   ?cap:Cap.t -> ?fd:Lwt_unix.file_descr -> (int * int -> image) -> unit Lwt.t
       95: 
       96: val show_cursor : ?cap:Cap.t -> ?fd:Lwt_unix.file_descr -> bool -> unit Lwt.t
       97: 
       98: val move_cursor :
       99:   ?cap:Cap.t -> ?fd:Lwt_unix.file_descr ->
      100:     [ `Home | `By of int * int | `To of int * int ] -> unit Lwt.t
Added regular file ../notty/src-unix/dune:
        1: (library
        2:   (public_name notty.unix)
        3:   (synopsis "Notty Unix IO")
        4:   (name notty_unix)
        5:   (wrapped false)
        6:   (c_names winsize)
        7:   (c_flags (-Wall -Wextra -O3))
        8:   (optional)
        9:   (libraries notty unix))
       10: 
       11: (include_subdirs unqualified)
Added regular file ../notty/src-unix/native/winsize.c:
        1: #include <sys/ioctl.h>
        2: #include <signal.h>
        3: #include <caml/mlvalues.h>
        4: 
        5: CAMLprim value caml_notty_winsize (value vfd) {
        6:   int fd = Int_val (vfd);
        7:   struct winsize w;
        8:   if (ioctl (fd, TIOCGWINSZ, &w) >= 0)
        9:     return Val_int ((w.ws_col << 16) + ((w.ws_row & 0x7fff) << 1));
       10:   return Val_int (0);
       11: }
       12: 
       13: #define __unit() value unit __attribute__((unused))
       14: 
       15: CAMLprim value caml_notty_winch_number (__unit()) {
       16:   return Val_int (SIGWINCH);
       17: }
Added regular file ../notty/src-unix/notty_unix.ml:
        1: (* Copyright (c) 2016-2017 David Kaloper Meršinjak. All rights reserved.
        2:    See LICENSE.md. *)
        3: 
        4: open Notty
        5: 
        6: external c_winsize : Unix.file_descr -> int = "caml_notty_winsize" [@@noalloc]
        7: external winch_number : unit -> int = "caml_notty_winch_number" [@@noalloc]
        8: 
        9: let iter f = function Some x -> f x | _ -> ()
       10: let value x = function Some a -> a | _ -> x
       11: 
       12: let winsize fd = match c_winsize fd with
       13:   | 0  -> None
       14:   | wh -> Some (wh lsr 16, wh lsr 1 land 0x7fff)
       15: 
       16: module Private = struct
       17: 
       18:   let once f = let v = lazy (f ()) in fun () -> Lazy.force v
       19: 
       20:   let cap_for_fd =
       21:     let open Cap in
       22:     match Sys.getenv "TERM" with
       23:     | exception Not_found -> fun _ -> dumb
       24:     | (""|"dumb")         -> fun _ -> dumb
       25:     | _                   -> fun fd -> if Unix.isatty fd then ansi else dumb
       26: 
       27:   let setup_tcattr ~nosig fd =
       28:     let open Unix in try
       29:       let tc = tcgetattr fd in
       30:       let tc1 = { tc with c_icanon = false; c_echo = false } in
       31:       tcsetattr fd TCSANOW
       32:         ( if nosig then { tc1 with c_isig = false; c_ixon = false } else tc1 );
       33:       `Revert (once @@ fun _ -> tcsetattr fd TCSANOW tc)
       34:     with Unix_error (ENOTTY, _, _) -> `Revert ignore
       35: 
       36:   let set_winch_handler f =
       37:     let signum = winch_number () in
       38:     let old_hdl = Sys.(signal signum (Signal_handle (fun _ -> f ()))) in
       39:     `Revert (once @@ fun () -> Sys.set_signal signum old_hdl)
       40: 
       41:   module Gen_output (O : sig
       42:     type fd
       43:     type k
       44:     val def   : fd
       45:     val to_fd : fd -> Unix.file_descr
       46:     val write : fd -> Buffer.t -> k
       47:   end) = struct
       48: 
       49:     let scratch = lazy (Buffer.create 4096)
       50: 
       51:     let output ?cap ?(fd = O.def) f =
       52:       let cap = cap |> value (cap_for_fd (O.to_fd fd)) in
       53:       let buf = Lazy.force scratch in
       54:       Buffer.reset buf; f buf cap fd; O.write fd buf
       55: 
       56:     let output_image_size ?cap ?fd f =
       57:       output ?cap ?fd @@ fun buf cap fd ->
       58:         let size = winsize (O.to_fd fd) in
       59:         let i = f (value (80, 24) size) in
       60:         let dim = match size with
       61:           | Some (w, _) -> I.(w, height i)
       62:           | None        -> I.(width i, height i) in
       63:         Render.to_buffer buf cap (0, 0) dim i
       64: 
       65:     let show_cursor ?cap ?fd x =
       66:       output ?cap ?fd @@ fun buf cap _ -> Direct.show_cursor buf cap x
       67: 
       68:     let move_cursor ?cap ?fd x =
       69:       output ?cap ?fd @@ fun buf cap _ -> Direct.move_cursor buf cap x
       70: 
       71:     let output_image ?cap ?fd i = output_image_size ?cap ?fd (fun _ -> i)
       72: 
       73:     let eol i = I.(i <-> void 0 1)
       74:   end
       75: end
       76: 
       77: open Private
       78: 
       79: module Term = struct
       80: 
       81:   module Winch = struct
       82: 
       83:     let h  = Hashtbl.create 3
       84:     and id = ref 0
       85: 
       86:     let add fd f =
       87:       let n = !id in
       88:       set_winch_handler (fun () -> Hashtbl.iter (fun _ f -> f ()) h) |> ignore;
       89:       Hashtbl.add h n (fun () -> winsize fd |> iter f); incr id;
       90:       `Revert (fun () -> Hashtbl.remove h n)
       91:   end
       92: 
       93:   module Input = struct
       94: 
       95:     type t = {
       96:       fd      : Unix.file_descr
       97:     ; flt     : Unescape.t
       98:     ; ibuf    : bytes
       99:     ; cleanup : unit -> unit
      100:     }
      101: 
      102:     let bsize = 1024
      103: 
      104:     let create ~nosig fd =
      105:       let flt  = Unescape.create ()
      106:       and ibuf = Bytes.create bsize
      107:       and `Revert cleanup = setup_tcattr ~nosig fd in
      108:       { fd; flt; ibuf; cleanup }
      109: 
      110:     let rec event t =
      111:       match Unescape.next t.flt with
      112:       | #Unescape.event | `End as r -> r
      113:       | `Await ->
      114:           let n = Unix.read t.fd t.ibuf 0 bsize in
      115:           Unescape.input t.flt t.ibuf 0 n; event t
      116:   end
      117: 
      118:   type t = {
      119:     output   : out_channel
      120:   ; trm      : Tmachine.t
      121:   ; buf      : Buffer.t
      122:   ; input    : Input.t
      123:   ; fds      : Unix.file_descr * Unix.file_descr
      124:   ; unwinch  : (unit -> unit) Lazy.t
      125:   ; mutable winched : bool
      126:   }
      127: 
      128:   let write t =
      129:     Buffer.clear t.buf;
      130:     Tmachine.output t.trm t.buf;
      131:     Buffer.output_buffer t.output t.buf; flush t.output
      132: 
      133:   let set_size t dim = Tmachine.set_size t.trm dim
      134:   let refresh t      = Tmachine.refresh t.trm; write t
      135:   let image t image  = Tmachine.image t.trm image; write t
      136:   let cursor t curs  = Tmachine.cursor t.trm curs; write t
      137:   let size t         = Tmachine.size t.trm
      138: 
      139:   let release t =
      140:     if Tmachine.release t.trm then
      141:       ( Lazy.force t.unwinch ();
      142:         t.input.Input.cleanup ();
      143:         write t )
      144: 
      145:   let create ?(dispose=true) ?(nosig=true) ?(mouse=true) ?(bpaste=true)
      146:              ?(input=Unix.stdin) ?(output=Unix.stdout) () =
      147:     let rec t = {
      148:         output  = Unix.out_channel_of_descr output
      149:       ; trm     = Tmachine.create ~mouse ~bpaste (cap_for_fd input)
      150:       ; buf     = Buffer.create 4096
      151:       ; input   = Input.create ~nosig input
      152:       ; fds     = (input, output)
      153:       ; winched = false
      154:       ; unwinch = lazy (
      155:           let `Revert f = Winch.add output @@ fun dim ->
      156:             Buffer.reset t.buf; t.winched <- true; set_size t dim in f)
      157:     } in
      158:     winsize output |> iter (set_size t);
      159:     (Lazy.force t.unwinch |> ignore) [@ocaml.warning "-5"];
      160:     if dispose then at_exit (fun () -> release t);
      161:     write t;
      162:     t
      163: 
      164:   let rec event = function
      165:     | t when Tmachine.dead t.trm -> `End
      166:     | t when t.winched -> t.winched <- false; `Resize (size t)
      167:     | t -> Unix.(try Input.event t.input with Unix_error (EINTR, _, _) -> event t)
      168: 
      169:   let pending t =
      170:     not (Tmachine.dead t.trm) &&
      171:     (t.winched || Unescape.pending t.input.Input.flt)
      172: 
      173:   let fds t = t.fds
      174: end
      175: 
      176: include Gen_output (struct
      177:   type fd = out_channel and k = unit
      178:   let def   = stdout
      179:   and to_fd = Unix.descr_of_out_channel
      180:   and write = Buffer.output_buffer
      181: end)
Added regular file ../notty/src-unix/notty_unix.mli:
        1: (* Copyright (c) 2016-2017 David Kaloper Meršinjak. All rights reserved.
        2:    See LICENSE.md. *)
        3: 
        4: (** [Notty] IO for pure [Unix].
        5: 
        6:     This is an IO module for {!Notty}.
        7: 
        8:     {e %%VERSION%% — {{:%%PKG_HOMEPAGE%% }homepage}} *)
        9: 
       10: open Notty
       11: 
       12: (** {1:fullscreen Fullscreen input and output}. *)
       13: 
       14: (** Terminal IO abstraction for fullscreen, interactive applications.
       15: 
       16:     This module provides both input and output. It assumes exclusive ownership of
       17:     the IO streams between {{!create}initialization} and {{!release}shutdown}. *)
       18: module Term : sig
       19: 
       20:   type t
       21:   (** Representation of the terminal, giving structured access to IO. *)
       22: 
       23:   (** {1 Construction and destruction} *)
       24: 
       25:   val create : ?dispose:bool ->
       26:                ?nosig:bool ->
       27:                ?mouse:bool ->
       28:                ?bpaste:bool ->
       29:                ?input:Unix.file_descr ->
       30:                ?output:Unix.file_descr ->
       31:                unit -> t
       32:   (** [create ~dispose ~nosig ~mouse ~input ~output ()] creates a fresh
       33:       {{!t}terminal}. It has the following side effects:
       34:       {ul
       35:       {- [Unix.tcsetattr] is applied to [input] to disable {e echo} and
       36:          {e canonical mode}.}
       37:       {- [output] is set to {e alternate screen mode}, and the cursor is
       38:          hidden. Mouse and {e bracketed paste} reporting are (optionally)
       39:          enabled.}
       40:       {- [SIGWINCH] signal, normally ignored, is handled.}}
       41: 
       42:       [~dispose] arranges for automatic {{!release}cleanup} of the terminal
       43:       before the process terminates. The downside is that a reference to this
       44:       terminal is retained until the program exits. Defaults to [true].
       45: 
       46:       [~nosig] additionally turns off signal delivery and flow control
       47:       ({e isig} and {e ixon}) on input. Inhibits automatic handling of
       48:       {e CTRL-\{C,Z,\,S,Q\}}. Defaults to [true].
       49: 
       50:       [~mouse] activates mouse reporting. Defaults to [true].
       51: 
       52:       [~bpaste] activates bracketed paste reporting. Defaults to [true].
       53: 
       54:       [~input] is the input file descriptor. Defaults to [stdin].
       55: 
       56:       [~output] is the output file descriptor. Defaults to [stdout]. *)
       57: 
       58:   val release : t -> unit
       59:   (** Dispose of this terminal. Original behavior of input fd is reinstated,
       60:       cursor is restored, mouse reporting disabled, and alternate mode is
       61:       terminated.
       62: 
       63:       It is an error to use the {{!cmds}commands} on a released terminal, and
       64:       will raise [Invalid_argument], while [release] itself is idempotent. *)
       65: 
       66:   (** {1:cmds Commands} *)
       67: 
       68:   val image : t -> image -> unit
       69:   (** [image t i] sets [i] as [t]'s current image and redraws the terminal. *)
       70: 
       71:   val refresh : t -> unit
       72:   (** [refresh t] redraws the terminal using the current image.
       73: 
       74:       Useful if the output might have become garbled. *)
       75: 
       76:   val cursor : t -> (int * int) option -> unit
       77:   (** [cursor t pos] sets and redraws the cursor.
       78: 
       79:       [None] hides it. [Some (x, y)] places it at column [x] and row [y], with
       80:       the origin at [(0, 0)], mapping to the upper-left corner. *)
       81: 
       82:   (** {1 Events} *)
       83: 
       84:   val event : t -> [ Unescape.event | `Resize of (int * int) | `End ]
       85:   (** Wait for a new event. [event t] can be:
       86:       {ul
       87:       {- [#Unescape.event], an {{!Notty.Unescape.event}[event]} from the input fd;}
       88:       {- [`End] if the input fd is closed, or the terminal was released; or}
       89:       {- [`Resize (cols, rows)] giving the current size of the output tty, if a
       90:          [SIGWINCH] was delivered before or during this call to [event].}}
       91: 
       92:       {b Note} [event] is buffered. Calls can either block or immediately
       93:       return. Use {{!pending}[pending]} to detect when the next call would not
       94:       block. *)
       95: 
       96:   val pending : t -> bool
       97:   (** [pending t] is [true] if the next call to {{!event}[event]} would not
       98:       block and the terminal has not yet been released. *)
       99: 
      100:   (** {1 Properties} *)
      101: 
      102:   val size : t -> int * int
      103:   (** [size t] is the current size of the terminal's output tty. *)
      104: 
      105:   val fds : t -> Unix.file_descr * Unix.file_descr
      106:   (** [fds t] are [t]'s input and output file descriptors. *)
      107: 
      108:   (** {1 Window size change notifications} *)
      109: 
      110:   (** Manual [SIGWINCH] handling.
      111: 
      112:       Unix delivers notifications about tty size changes through the [SIGWINCH]
      113:       signal. A handler for this signal is installed as soon as a new terminal
      114:       is {{!create}created}. Replacing the global [SIGWINCH] handler using
      115:       the [Sys] module will cause this module to malfunction, as the size change
      116:       notifications will no longer be delivered.
      117: 
      118:       You might still want to ignore resizes reported by {{!event}[event]} and
      119:       directly listen to [SIGWINCH]. This module allows installing such
      120:       listeners without conflicting with the rest of the machinery. *)
      121:   module Winch : sig
      122: 
      123:     val add : Unix.file_descr -> ((int * int) -> unit) -> [`Revert of unit -> unit]
      124:     (** [add fd f] registers a [SIGWINCH] handler. Every time the signal is
      125:         delivered, [f] is called with the current size of the tty backing [fd].
      126:         If [fd] is not a tty, [f] is never called.
      127: 
      128:         Return value is a function that removes the handler [f].
      129: 
      130:         Handlers are called in an unspecified order. *)
      131: 
      132:   end
      133: end
      134: 
      135: (** {1:inline Inline output}
      136: 
      137:     These operations do not assume exclusive access to the output. This means
      138:     that they can be combined with other means of producing output. At the same
      139:     time, it means that they are affected by the current terminal state, and
      140:     that this state is not tracked. *)
      141: 
      142: val winsize : Unix.file_descr -> (int * int) option
      143: (** [winsize fd] is [Some (columns, rows)], the current dimensions of [fd]'s
      144:     backing tty, or [None], when [fd] is not backed by a tty. *)
      145: 
      146: val eol : image -> image
      147: (** [eol image] is [image], producing an extra newline when printed. *)
      148: 
      149: val output_image :
      150:   ?cap:Cap.t -> ?fd:out_channel -> image -> unit
      151: (** [output_image ?cap ?fd image] writes [image] to [fd].
      152: 
      153:     The image is displayed in its full height. If the output is a tty, image
      154:     width is clipped to the output width. Otherwise, full width is used.
      155: 
      156:     [~cap] is the {{!caps}optional} terminal capability set.
      157: 
      158:     [~fd] defaults to [stdout]. *)
      159: 
      160: val output_image_size : ?cap:Cap.t -> ?fd:out_channel -> (int * int -> image) -> unit
      161: (** [output_image_size ?cap ?fd f] is
      162:     [output_image ?cap ?fd (f size)] where [size] are [fd]'s current
      163:     {{!winsize}output dimensions}.
      164: 
      165:     If [fd] is not backed by a tty, as a matter of convenience, [f] is applied
      166:     to [(80, 24)]. Use {!Unix.isatty} or {{!winsize}[winsize]} to detect whether
      167:     the output has a well-defined size. *)
      168: 
      169: val show_cursor : ?cap:Cap.t -> ?fd:out_channel -> bool -> unit
      170: (** [show_cursor ?cap ?fd visible] toggles the cursor visibility on [fd]. *)
      171: 
      172: val move_cursor :
      173:   ?cap:Cap.t -> ?fd:out_channel ->
      174:     [ `Home | `By of int * int | `To of int * int ] -> unit
      175: (** [move_cursor ?cap ?fd motion] moves the cursor on [fd].
      176: 
      177:     [motion] is one of:
      178:     {ul
      179:     {- [`To (column, line)], positioning the cursor to [(column, line)]. Origin
      180:        is [(0, 0)], the upper-left corner of the screen.}
      181:     {- [`Home], moving the cursor the beginning of line.}
      182:     {- [`By (columns, lines)], moving the cursor [columns] to the right (left if
      183:        negative) and [lines] down (up if negative).
      184: 
      185:        {b Note} Behavior is terminal dependent if the movement overshoots the
      186:        output size.}} *)
      187: 
      188: (** {1:caps Capability detection}
      189: 
      190:     All [image] output requires {{!Notty.Cap.t}terminal capabilities}.
      191: 
      192:     When not provided, capabilities are auto-detected, by checking that the
      193:     output is a tty, that the environment variable [$TERM] is set, and that it
      194:     is not set to either [""] or ["dumb"]. If these conditions hold,
      195:     {{!Notty.Cap.ansi}ANSI} escapes are used. Otherwise, {{!Notty.Cap.dumb}no}
      196:     escapes are used. *)
      197: 
      198: (**/**)
      199: (** {1 Private}
      200: 
      201:     These are private interfaces, prone to breakage. Don't use them. *)
      202: module Private : sig
      203: 
      204:   val cap_for_fd        : Unix.file_descr -> Cap.t
      205:   val setup_tcattr      : nosig:bool -> Unix.file_descr -> [ `Revert of (unit -> unit) ]
      206:   val set_winch_handler : (unit -> unit) -> [ `Revert of (unit -> unit) ]
      207: 
      208:   module Gen_output (O : sig
      209:     type fd
      210:     type k
      211:     val def   : fd
      212:     val to_fd : fd -> Unix.file_descr
      213:     val write : fd -> Buffer.t -> k
      214:   end ) : sig
      215:     val output_image : ?cap:Cap.t -> ?fd:O.fd -> image -> O.k
      216:     val output_image_size : ?cap:Cap.t -> ?fd:O.fd -> (int * int -> image) -> O.k
      217:     val show_cursor : ?cap:Cap.t -> ?fd:O.fd -> bool -> O.k
      218:     val move_cursor : ?cap:Cap.t -> ?fd:O.fd -> [ `Home | `By of int * int | `To of int * int ] -> O.k
      219:     val eol : image -> image
      220:   end
      221: end
      222: (**/**)
Added executable file ../notty/support/gen_unicode_props.ml:
        1: #!/usr/bin/env ocaml
        2: (* Copyright (c) 2020 David Kaloper Meršinjak. All rights reserved.
        3:    See LICENSE.md. *)
        4: 
        5: #use "topfind"
        6: #require "uucp"
        7: 
        8: let filter p seq i = seq (fun x -> if p x then i x)
        9: let map f seq i = seq (fun x -> i (f x))
       10: let uchars it =
       11:   let rec go it u = it u; go it (Uchar.succ u) in
       12:   try go it Uchar.min with Invalid_argument _ -> ()
       13: let to_list seq =
       14:   let xs = ref [] in
       15:   seq (fun x -> xs := x :: !xs);
       16:   List.rev !xs
       17: 
       18: let intervals_kv seq i =
       19:   let s = ref None in
       20:   let f (x, v) = match !s with
       21:   | None -> s := Some (x, x, v)
       22:   | Some (a, b, v0) when v = v0 && x = Uchar.succ b -> s := Some (a, x, v0)
       23:   | Some e -> i e; s := Some (x, x, v) in
       24:   seq f;
       25:   match !s with Some e -> i e | _ -> ()
       26: 
       27: let intervals_p seq =
       28:   map (fun x -> x, ()) seq |> intervals_kv |> map (fun (a, b, _) -> a, b)
       29: 
       30: (* Condenses code points into continuous range. *)
       31: let pack_u u = let i = Uchar.to_int u in if i > 0xd7ff then i - 0x800 else i
       32: let unpack_u i = Uchar.of_int (if i < 0xd800 then i else i + 0x800)
       33: 
       34: (* 12-6-6-bit (0xfff-0x3f-0x3f) trie, 3 levels, array-array-string.
       35:    Root is variable; lower levels are either empty or complete.
       36: 
       37:    At the moment, packed Uchar.max is 0x10f7ff; this can map up to 0xffffff
       38:    distinct code points.  *)
       39: let trie ~default f =
       40:   let xs = List.init ((pack_u Uchar.max lsr 12) + 1) @@ fun b0 ->
       41:     let mask = b0 lsl 12 in
       42:     let arr = Array.init 0x40 @@ fun b1 ->
       43:       let mask = mask lor (b1 lsl 6) in
       44:       let v b2 = match unpack_u (mask lor b2) with
       45:       | x -> f x
       46:       | exception Invalid_argument _ -> default in
       47:       match (for b2 = 0 to 0x3f do if v b2 <> default then raise Exit done) with
       48:       | exception Exit -> String.init 0x40 (fun b2 -> Char.chr (v b2))
       49:       | () -> ""
       50:     in
       51:     if Array.for_all ((=) "") arr then [||] else arr
       52:   in
       53:   let rec trim = function [||]::xs -> trim xs | xs -> xs in
       54:   List.rev (trim (List.rev xs)) |> Array.of_list
       55: 
       56: let pf = Format.fprintf
       57: let strf = Format.sprintf
       58: let pp_iter ?(sep = fun _ _ -> ()) iter pp ppf x =
       59:   let fst = ref true in
       60:   let f x = (if !fst then fst := false else sep ppf ()); pp ppf x in
       61:   iter f x
       62: let pp_u ppf u = pf ppf "0x%04x" (Uchar.to_int u)
       63: let pp_as_array iter pp ppf x =
       64:   let sep ppf () = pf ppf ";@ " in
       65:   pf ppf "@[<2>[|%a|]@]" (pp_iter ~sep iter pp) x
       66: 
       67: let intern ppf_ml iter =
       68:   let t = Hashtbl.create 16 in
       69:   let n = ref 0 in
       70:   iter (fun s -> if not (Hashtbl.mem t s) then begin
       71:     let name = strf "s%03d" !n in
       72:     Hashtbl.add t s name; incr n;
       73:     pf ppf_ml "let %s = %S@." name s
       74:   end);
       75:   pf ppf_ml "@.";
       76:   (fun ppf s -> match Hashtbl.find_opt t s with
       77:    | Some name -> pf ppf "%s" name
       78:    | None -> pf ppf "%S" s)
       79: 
       80: let dump_interval_map (ppf_mli, ppf_ml) ~name ~desc seq =
       81:   pf ppf_mli "(* %s *)@.val %s: int array * int array * int array@.@." desc name;
       82:   let xs = to_list (intervals_kv seq) in
       83:   let aa = List.map (fun (a, _, _) -> a) xs
       84:   and bb = List.map (fun (_, b, _) -> b) xs
       85:   and cc = List.map (fun (_, _, c) -> c) xs in
       86:   let pp_arr pp = pp_as_array List.iter pp in
       87:   let pp_arr_u = pp_arr pp_u and pp_arr_i = pp_arr Format.pp_print_int in
       88:   pf ppf_ml "@[<2>let %s =@ @[<1>(%a,@ %a,@ %a)@]@]@.@."
       89:      name pp_arr_u aa pp_arr_u bb pp_arr_i cc
       90: 
       91: let dump_trie_map (ppf_mli, ppf_ml) ~name ~desc ~default f =
       92:   pf ppf_mli "(* %s *)@.val %s: string array array@.@." desc name;
       93:   let xs = trie ~default f in
       94:   let pp_s = intern ppf_ml Array.(fun i -> i ""; iter (iter i) xs) in
       95:   pf ppf_ml "@[<2>let %s =@ %a@]" name
       96:     Array.(pp_as_array iter (pp_as_array iter pp_s)) xs
       97: 
       98: let pp_header ppf = Format.fprintf ppf
       99: "(* Do not edit.
      100:  *
      101:  * This module contains select unicode properties extracted from Uucp,
      102:  * using `%s`.
      103:  *
      104:  * Unicode version %s.
      105:  *)
      106: 
      107: " Sys.argv.(0) Uucp.unicode_version
      108: 
      109: let extract (ppmli, ppml as ppfs) =
      110: 
      111:   pp_header ppmli; pp_header ppml;
      112: 
      113:   dump_interval_map ppfs
      114:     ~name:"tty_width_hint"
      115:     ~desc:"Uucp.Break.tty_width_hint"
      116:     (* w = -1 is easy to detect.
      117:        w = 1 covers the most intervals, so we default it. *)
      118:     (uchars |> map (fun u -> u, Uucp.Break.tty_width_hint u)
      119:             |> filter (fun (_, w) -> w <> -1 && w <> 1));
      120: 
      121:   (* dump_interval_map ppfs *)
      122:   (*   ~name:"grapheme_cluster_boundary" *)
      123:   (*   ~desc:"Uucp.Break.Low.grapheme_cluster." *)
      124:   (*   (1* No single value dominates the histogram. *1) *)
      125:   (*   (uchars |> map (fun u -> u, Uucp.Break.Low.grapheme_cluster u)); *)
      126: 
      127:   dump_trie_map ppfs
      128:     ~name:"grapheme_cluster_boundary"
      129:     ~desc:"Uucp.Break.Low.grapheme_cluster."
      130:     ~default:16 (* 16 - `XX - is by far the most prevalent value *)
      131:     Uucp.Break.Low.grapheme_cluster;
      132: 
      133:   ()
      134: 
      135: let file = "src/no-uucp/notty_uucp_data"
      136: 
      137: let with_new name f =
      138:   let o = open_out_gen [Open_trunc; Open_creat; Open_wronly] 0o664 name in
      139:   let ppf = Format.formatter_of_out_channel o in
      140:   f ppf; Format.pp_print_flush ppf (); close_out o
      141: 
      142: let () =
      143:   Format.printf "Dumping Unicode v%s data to %s.@." Uucp.unicode_version file;
      144:   with_new (file ^ ".mli") @@ fun ppmli ->
      145:     with_new (file ^ ".ml") @@ fun ppml ->
      146:       extract (ppmli, ppml)
Removed regular file ../test/dune:
   1     : (test
   2     :  (name jj_tui))
Removed regular file ../test/jj_tui.ml:
    (empty)
Commit ID: 0ec773d56287bb2e110a67e496feec0ad1ecde27
Change ID: kszkuqqsvpknsnosxyxmnunnqvrzmpvq
Author: Eli Dowling <eli.jambu@gmail.com> (2024-05-08 01:20:28)
Committer: Eli Dowling <eli.jambu@gmail.com> (2024-05-09 00:02:25)

    coloured output is working

Added regular file ../.ocamlformat:
        1: version=0.24.1
        2: profile=conventional
Removed regular file ../bin/dune:
   1     : (executable
   2     :  (public_name jj_tui)
   3     :  (name main)
   4     :  (libraries jj_tui feather lwd nottui base core stdio core_unix.command_unix )
   5     :  )
Removed regular file ../bin/main.ml:
   1     : open Nottui;;
   2     : open Feather;;
   3     : open Lwd_infix;;
   4     : module W = Nottui_widgets;;
   5     : 
   6     : 
   7     : (* Ui_loop.run (Lwd.pure (W.printf "Hello world"));; *)
   8     : 
   9     : let cmdArgs cmd args=
  10     :   let (stdout,stderr)=Feather.process cmd args|>Feather.collect stdout_and_stderr in
  11     :   stdout^stderr
  12     : ;;
  13     : let cmd cmd =
  14     :   let (stdout,stderr)=Feather.process cmd []|>Feather.collect stdout_and_stderr in
  15     :   stdout^stderr
  16     : 
  17     : ;;
  18     : 
  19     : 
  20     : let vcount = Lwd.var "";;
  21     : 
  22     : let button = 
  23     :   W.button (Printf.sprintf "run jj" )
  24     :            (fun () ->  vcount $= (cmd"jj"))
  25     :   |>Lwd.pure
  26     :          ;;
  27     : let vQuit=Lwd.var false;;
  28     : 
  29     : let quitButton  = 
  30     :   W.button (Printf.sprintf "quit " )
  31     :            (fun () ->  vQuit $= true)
  32     :   |>Lwd.pure
  33     :          ;;
  34     : 
  35     : 
  36     : let (<-$) f v=Lwd.map ~f (Lwd.get v);; 
  37     : let vShowStatus= Lwd.var "";;
  38     : let inputs ui=
  39     :   Ui.event_filter (fun event->
  40     :     match event with
  41     :     |`Key (`ASCII 'l',_)-> 
  42     :         let res=cmd "jj"in
  43     :         vcount$=res;
  44     : 
  45     :         `Handled
  46     :     |`Key (`ASCII 's',_)-> 
  47     :         let res=cmdArgs "jj" ["show"]in
  48     :         vShowStatus$=res;
  49     : 
  50     :         `Handled
  51     :     |`Key (`ASCII 'p',_)-> 
  52     :         let _=cmdArgs "jj"["prev"]in
  53     : 
  54     :         `Handled
  55     :     |`Key (`ASCII 'n',_)-> 
  56     :         let _=cmdArgs "jj"["next"]in
  57     : 
  58     :         `Handled
  59     :     |_->`Unhandled
  60     :       ) ui
  61     :   ;;
  62     : let mainUi= 
  63     :   Lwd.map ~f:inputs @@
  64     :   W.h_pane
  65     :   (Nottui_widgets.vbox [
  66     :     button;
  67     :     W.string <-$ vcount;
  68     :     quitButton])
  69     :   (W.string <-$ vShowStatus)
  70     : ;;
  71     :       
  72     : 
  73     : Ui_loop.run ~quit:vQuit (mainUi);;
  74     : 
  75     : (*
  76     : type tree = Tree of string * (unit -> tree list)
  77     : 
  78     : let rec tree_ui (Tree (label, child)) =
  79     :   let opened = Lwd.var false in
  80     :   let render is_opened =
  81     :     let btn_text = if is_opened then "[-] " else "[+] " in
  82     :     let btn_action () = Lwd.set opened (not is_opened) in
  83     :     let btn = W.button (btn_text ^ label) btn_action in
  84     :     let layout node forest =
  85     :       Ui.join_y node (Ui.join_x (Ui.space 2 0) forest) 
  86     :     in
  87     :     if is_opened 
  88     :     then Lwd.map ~f:(layout btn) (forest_ui (child ()))
  89     :     else Lwd.pure btn
  90     :   in
  91     :   Lwd.join (Lwd.map ~f:render (Lwd.get opened))
  92     :   
  93     : and forest_ui nodes = 
  94     :   Lwd_utils.pack Ui.pack_y 
  95     :     (List.map tree_ui nodes)
  96     : ;;
  97     : 
  98     : let rec fake_fs () = [
  99     :   Tree ("bin", fake_fs);
 100     :   Tree ("home", fake_fs);
 101     :   Tree ("usr", fake_fs);
 102     : ] in
 103     : 
 104     : Ui_loop.run (forest_ui (fake_fs ()));;
 105     : *)
Removed regular file ../dune-project:
   1     : (lang dune 3.9)
   2     : 
   3     : (name jj_tui)
   4     : 
   5     : (generate_opam_files true)
   6     : 
   7     : (source
   8     :  (github username/reponame))
   9     : 
  10     : (authors "Author Name")
  11     : 
  12     : (maintainers "Maintainer Name")
  13     : 
  14     : (license LICENSE)
  15     : 
  16     : (documentation https://url/to/documentation)
  17     : 
  18     : (package
  19     :  (name jj_tui)
  20     :  (synopsis "A short synopsis")
  21     :  (description "A longer description")
  22     :  (depends ocaml dune)
  23     :  (tags
  24     :   (topics "to describe" your project)))
  25     : 
  26     : ; See the complete stanza docs at https://dune.readthedocs.io/en/stable/dune-files.html#dune-project
Removed regular file ../flake.lock:
   1     : {
   2     :   "nodes": {
   3     :     "nixpkgs": {
   4     :       "locked": {
   5     :         "lastModified": 1713344939,
   6     :         "narHash": "sha256-jpHkAt0sG2/J7ueKnG7VvLLkBYUMQbXQ2L8OBpVG53s=",
   7     :         "path": "/nix/store/ngm8a5avsnfk266jha4j5xy93xfhjasf-source",
   8     :         "rev": "e402c3eb6d88384ca6c52ef1c53e61bdc9b84ddd",
   9     :         "type": "path"
  10     :       },
  11     :       "original": {
  12     :         "id": "nixpkgs",
  13     :         "type": "indirect"
  14     :       }
  15     :     },
  16     :     "root": {
  17     :       "inputs": {
  18     :         "nixpkgs": "nixpkgs"
  19     :       }
  20     :     }
  21     :   },
  22     :   "root": "root",
  23     :   "version": 7
  24     : }
Removed regular file ../flake.nix:
   1     : {
   2     :   description = "Example JavaScript development environment for Zero to Nix";
   3     : 
   4     :   # Flake inputs
   5     :   inputs = {
   6     : 
   7     :     # nixpkgs.url = "github:NixOS/nixpkgs/nixos-unstable";
   8     :     nixpkgs.url = "nixpkgs"; # also valid: "nixpkgs"
   9     : 
  10     :     # roc={
  11     :     #   url="github:roc-lang/roc";
  12     :     # inputs.nixpkgs.follows="nixpkgs";
  13     : 
  14     :     # };
  15     : 
  16     :   };
  17     :   # Flake outputs
  18     :   outputs = { self, nixpkgs, ... }@inputs:
  19     :     let
  20     :       # Systems supported
  21     :       allSystems = [
  22     :         "x86_64-linux" # 64-bit Intel/AMD Linux
  23     :       ];
  24     : 
  25     :       # Helper to provide system-specific attributes
  26     :       forAllSystems = f:
  27     :         nixpkgs.lib.genAttrs allSystems (system:
  28     :           f {
  29     :             pkgs = import nixpkgs { inherit system; };
  30     : 
  31     :           });
  32     :     in {
  33     :       # Development environment output
  34     :       devShells = forAllSystems ({ pkgs }: {
  35     :         default =
  36     : 
  37     :           pkgs.mkShell {
  38     :             packages = with pkgs; [ pkgs.pkg-config gmp stdenv.cc.cc.lib ];
  39     :             shellHook = let
  40     :               libPath =
  41     :                 pkgs.lib.makeLibraryPath [ pkgs.stdenv.cc.cc.lib pkgs.gmp ];
  42     :             in ''
  43     :               # yolo
  44     :               export CFLAGS="$CFLAGS -I${pkgs.stdenv.cc.cc.lib}/include -I${pkgs.gmp}/include"
  45     :               export LIBS="$LIBS -L${pkgs.stdenv.cc.cc.lib}/lib -L${pkgs.gmp}/lib"
  46     :             '';
  47     :           };
  48     : 
  49     :       });
  50     : 
  51     :     };
  52     : }
Added regular file .ocamlformat:
        1: 
        2: profile=conventional
Added regular file .ocmalformat:
        1: version=0.24.1
        2: profile=conventional
Added regular file bin/dune:
        1: (executable
        2:  (public_name jj_tui)
        3:  (name main)
        4:  (libraries jj_tui feather lwd nottui base core stdio core_unix.command_unix )
        5:  )
Added regular file bin/main.ml:
        1: open Nottui
        2: open Feather
        3: open Lwd_infix
        4: open Notty
        5: module W = Nottui_widgets
        6: 
        7: let colored_string = Jj_tui.AnsiReverse.colored_string
        8: 
        9: (* Ui_loop.run (Lwd.pure (W.printf "Hello world"));; *)
       10: let cmdArgs cmd args =
       11:   let stdout, stderr =
       12:     Feather.process cmd args |> Feather.collect stdout_and_stderr
       13:   in
       14:   stdout ^ stderr
       15: 
       16: let jj args = cmdArgs "jj" (List.concat [ args; [ "--color"; "always" ] ])
       17: let vcount = Lwd.var I.empty
       18: 
       19: let _button =
       20:   W.button (Printf.sprintf "run jj") (fun () ->
       21:       vcount $= (cmdArgs "jj" [ "log"; "--color"; "always" ] |> colored_string))
       22:   |> Lwd.pure
       23: 
       24: let vQuit = Lwd.var false
       25: 
       26: let _quitButton =
       27:   W.button (Printf.sprintf "quit ") (fun () -> vQuit $= true) |> Lwd.pure
       28: 
       29: let ( <-$ ) f v = Lwd.map ~f (Lwd.get v)
       30: 
       31: (* let ( let<- ) v f = Lwd.map ~f (Lwd.get v) *)
       32: let vShowStatus = Lwd.var I.empty
       33: let vother = Lwd.var ""
       34: 
       35: let onChange () =
       36:   let res = jj [ "show" ] |> colored_string in
       37:   vShowStatus $= res;
       38:   let res = jj [] in
       39:   vcount $= colored_string res
       40: 
       41: let changeInputs key =
       42:   let noOut args =
       43:     let _ = jj args in
       44:     `Handled
       45:   in
       46:   match key with
       47:   | 'P' -> noOut [ "prev" ]
       48:   | 'p' -> noOut [ "prev"; "--edit" ]
       49:   | 'N' -> noOut [ "next" ]
       50:   | 'n' -> noOut [ "next"; "--edit" ]
       51:   | 'S' -> noOut [ "unsquash"; "-i"; "--tool"; "sublime_merge" ]
       52:   | _ -> `Unhandled
       53: 
       54: let inputs ui =
       55:   Ui.event_filter
       56:     (fun event ->
       57:       match event with
       58:       | `Key (`ASCII 's', _) ->
       59:           let res = jj [ "show" ] in
       60:           vShowStatus $= (res |> colored_string);
       61: 
       62:           `Handled
       63:       | `Key (`ASCII 'l', _) ->
       64:           let res = jj [] in
       65:           vcount $= colored_string res;
       66:           vother $= res;
       67: 
       68:           `Handled
       69:       | `Key (`ASCII 'q', _) ->
       70:           vQuit $= true;
       71: 
       72:           `Handled
       73:       | `Key (`ASCII key, _) -> (
       74:           match changeInputs key with
       75:           | `Handled ->
       76:               onChange ();
       77:               `Handled
       78:           | `Unhandled -> `Unhandled)
       79:       | _ -> `Unhandled)
       80:     ui
       81: 
       82: let mainUi =
       83:   let$ pane =
       84:     W.h_pane
       85:       (Nottui_widgets.vbox
       86:          [ (* button;  *) Ui.atom <-$ vcount (* quitButton  *) ])
       87:       (Ui.atom <-$ vShowStatus)
       88:   in
       89:   inputs pane
       90: ;;
       91: 
       92: (*TODO:For hosting a subprocess i should look into using EIO and Ui_loop.step like some of the other libraries built with nottui*)
       93: Ui_loop.run ~quit:vQuit mainUi
       94: (* let my_image=(Notty.I.string Notty.A.empty "\027[32mThis is in green %s\027[0m" ) in *)
       95: (* let my_image =
       96:      Jj_tui.AnsiReverse.Cap.parse_ansi_escape_codes
       97:        "\027[32mThis is in green %s\027[0m "
       98:      |> List.map (fun (x, str) -> Notty.I.string x str)
       99:    ;;
      100: 
      101:    Notty_unix.output_image (my_image |> List.hd) *)
      102: 
      103: (*
      104: type tree = Tree of string * (unit -> tree list)
      105: 
      106: let rec tree_ui (Tree (label, child)) =
      107:   let opened = Lwd.var false in
      108:   let render is_opened =
      109:     let btn_text = if is_opened then "[-] " else "[+] " in
      110:     let btn_action () = Lwd.set opened (not is_opened) in
      111:     let btn = W.button (btn_text ^ label) btn_action in
      112:     let layout node forest =
      113:       Ui.join_y node (Ui.join_x (Ui.space 2 0) forest) 
      114:     in
      115:     if is_opened 
      116:     then Lwd.map ~f:(layout btn) (forest_ui (child ()))
      117:     else Lwd.pure btn
      118:   in
      119:   Lwd.join (Lwd.map ~f:render (Lwd.get opened))
      120:   
      121: and forest_ui nodes = 
      122:   Lwd_utils.pack Ui.pack_y 
      123:     (List.map tree_ui nodes)
      124: ;;
      125: 
      126: let rec fake_fs () = [
      127:   Tree ("bin", fake_fs);
      128:   Tree ("home", fake_fs);
      129:   Tree ("usr", fake_fs);
      130: ] in
      131: 
      132: Ui_loop.run (forest_ui (fake_fs ()));;
      133: *)
Added regular file dune-project:
        1: (lang dune 3.9)
        2: 
        3: (name jj_tui)
        4: 
        5: (generate_opam_files true)
        6: 
        7: (source
        8:  (github username/reponame))
        9: 
       10: (authors "Author Name")
       11: 
       12: (maintainers "Maintainer Name")
       13: 
       14: (license LICENSE)
       15: 
       16: (documentation https://url/to/documentation)
       17: 
       18: (package
       19:  (name jj_tui)
       20:  (synopsis "A short synopsis")
       21:  (description "A longer description")
       22:  (depends ocaml dune)
       23:  (tags
       24:   (topics "to describe" your project)))
       25: 
       26: ; See the complete stanza docs at https://dune.readthedocs.io/en/stable/dune-files.html#dune-project
Added regular file flake.lock:
        1: {
        2:   "nodes": {
        3:     "nixpkgs": {
        4:       "locked": {
        5:         "lastModified": 1713344939,
        6:         "narHash": "sha256-jpHkAt0sG2/J7ueKnG7VvLLkBYUMQbXQ2L8OBpVG53s=",
        7:         "path": "/nix/store/ngm8a5avsnfk266jha4j5xy93xfhjasf-source",
        8:         "rev": "e402c3eb6d88384ca6c52ef1c53e61bdc9b84ddd",
        9:         "type": "path"
       10:       },
       11:       "original": {
       12:         "id": "nixpkgs",
       13:         "type": "indirect"
       14:       }
       15:     },
       16:     "root": {
       17:       "inputs": {
       18:         "nixpkgs": "nixpkgs"
       19:       }
       20:     }
       21:   },
       22:   "root": "root",
       23:   "version": 7
       24: }
Added regular file flake.nix:
        1: {
        2:   description = "Example JavaScript development environment for Zero to Nix";
        3: 
        4:   # Flake inputs
        5:   inputs = {
        6: 
        7:     # nixpkgs.url = "github:NixOS/nixpkgs/nixos-unstable";
        8:     nixpkgs.url = "nixpkgs"; # also valid: "nixpkgs"
        9: 
       10:     # roc={
       11:     #   url="github:roc-lang/roc";
       12:     # inputs.nixpkgs.follows="nixpkgs";
       13: 
       14:     # };
       15: 
       16:   };
       17:   # Flake outputs
       18:   outputs = { self, nixpkgs, ... }@inputs:
       19:     let
       20:       # Systems supported
       21:       allSystems = [
       22:         "x86_64-linux" # 64-bit Intel/AMD Linux
       23:       ];
       24: 
       25:       # Helper to provide system-specific attributes
       26:       forAllSystems = f:
       27:         nixpkgs.lib.genAttrs allSystems (system:
       28:           f {
       29:             pkgs = import nixpkgs { inherit system; };
       30: 
       31:           });
       32:     in {
       33:       # Development environment output
       34:       devShells = forAllSystems ({ pkgs }: {
       35:         default =
       36: 
       37:           pkgs.mkShell {
       38:             packages = with pkgs; [ pkgs.pkg-config gmp stdenv.cc.cc.lib ];
       39:             shellHook = let
       40:               libPath =
       41:                 pkgs.lib.makeLibraryPath [ pkgs.stdenv.cc.cc.lib pkgs.gmp ];
       42:             in ''
       43:               # yolo
       44:               export CFLAGS="$CFLAGS -I${pkgs.stdenv.cc.cc.lib}/include -I${pkgs.gmp}/include"
       45:               export LIBS="$LIBS -L${pkgs.stdenv.cc.cc.lib}/lib -L${pkgs.gmp}/lib"
       46:             '';
       47:           };
       48: 
       49:       });
       50: 
       51:     };
       52: }
Added regular file jj_tui.opam:
        1: # This file is generated by dune, edit dune-project instead
        2: opam-version: "2.0"
        3: synopsis: "A short synopsis"
        4: description: "A longer description"
        5: maintainer: ["Maintainer Name"]
        6: authors: ["Author Name"]
        7: license: "LICENSE"
        8: tags: ["topics" "to describe" "your" "project"]
        9: homepage: "https://github.com/username/reponame"
       10: doc: "https://url/to/documentation"
       11: bug-reports: "https://github.com/username/reponame/issues"
       12: depends: [
       13:   "ocaml"
       14:   "dune" {>= "3.9"}
       15:   "odoc" {with-doc}
       16: ]
       17: build: [
       18:   ["dune" "subst"] {dev}
       19:   [
       20:     "dune"
       21:     "build"
       22:     "-p"
       23:     name
       24:     "-j"
       25:     jobs
       26:     "@install"
       27:     "@runtest" {with-test}
       28:     "@doc" {with-doc}
       29:   ]
       30: ]
       31: dev-repo: "git+https://github.com/username/reponame.git"
Added regular file lib/ansiReverse.ml:
        1: open Notty
        2: 
        3: type op = Buffer.t -> unit
        4: 
        5: (* let ( & ) op1 op2 buf =
        6:      op1 buf;
        7:      op2 buf
        8: 
        9: 
       10:    let ( <| ), ( <. ), ( <! ) = Buffer.(add_string, add_char, add_decimal) *)
       11: let invalid_arg fmt = Format.kasprintf invalid_arg fmt
       12: 
       13: let rgb ~r ~g ~b =
       14:   if r < 0 || g < 0 || b < 0 || r > 5 || g > 5 || b > 5 then
       15:     invalid_arg "Notty.A.rgb %d %d %d: channel out of range" r g b
       16:   else 0x01000000 lor ((r * 36) + (g * 6) + b + 16)
       17: 
       18: let gray level =
       19:   if level < 0 || level > 23 then
       20:     invalid_arg "Notty.A.gray %d: level out of range" level
       21:   else 0x01000000 lor (level + 232)
       22: 
       23: let rgb_888 ~r ~g ~b =
       24:   if r < 0 || g < 0 || b < 0 || r > 255 || g > 255 || b > 255 then
       25:     invalid_arg "Notty.A.rgb_888 %d %d %d: channel out of range" r g b
       26:   else 0x02000000 lor ((r lsl 16) lor (g lsl 8) lor b)
       27: 
       28: let sts = [ ";1"; ";3"; ";4"; ";5"; ";7" ]
       29: 
       30: let attr_of_ints fg bg st =
       31:   A.fg @@ A.unsafe_color_of_int fg
       32:   |> A.( ++ ) (A.bg @@ A.unsafe_color_of_int bg)
       33:   |> A.( ++ ) (A.st @@ A.unsafe_style_of_int st)
       34: 
       35: let fg_int i = A.fg @@ A.unsafe_color_of_int i
       36: let bg_int i = A.bg @@ A.unsafe_color_of_int i
       37: 
       38: let print_image img =
       39:   print_endline "image:";
       40:   img |> Notty.Render.pp_image @@ Format.str_formatter;
       41:   print_endline (Format.flush_str_formatter () |> String.escaped)
       42: 
       43: let parse_ansi_escape_codes (input : string) : (A.t * string) list =
       44:   let len = String.length input in
       45:   let rec parse_codes acc i =
       46:     if i >= len then List.rev acc
       47:     else
       48:       let attr, j =
       49:         if i + 1 < len && input.[i] = '\027' && input.[i + 1] = '[' then (
       50:           let params = ref [] in
       51:           let j = ref (i + 2) in
       52:           while !j < len && input.[!j] <> 'm' do
       53:             let start = !j in
       54:             while !j < len && input.[!j] <> ';' && input.[!j] <> 'm' do
       55:               incr j
       56:             done;
       57:             let param = String.sub input start (!j - start) in
       58:             params := int_of_string param :: !params;
       59:             if !j < len && input.[!j] = ';' then incr j
       60:           done;
       61:           if !j < len && input.[!j] = 'm' then
       62:             let params = List.rev !params in
       63:             let attr =
       64:               match params with
       65:               | [] -> A.empty
       66:               | 0 :: _ -> A.empty
       67:               | 1 :: _ -> A.st A.bold
       68:               | 2 :: _ -> A.st A.italic
       69:               | 4 :: _ -> A.st A.underline
       70:               | 5 :: _ -> A.st A.blink
       71:               | 7 :: _ -> A.st A.reverse
       72:               | 30 :: _ -> A.fg A.black
       73:               | 31 :: _ -> A.fg A.red
       74:               | 32 :: _ -> A.fg A.green
       75:               | 33 :: _ -> A.fg A.yellow
       76:               | 34 :: _ -> A.fg A.blue
       77:               | 35 :: _ -> A.fg A.magenta
       78:               | 36 :: _ -> A.fg A.cyan
       79:               | 37 :: _ -> A.fg A.white
       80:               | 38 :: 5 :: color :: _ ->
       81:                   A.fg (A.unsafe_color_of_int (0x01000000 lor color))
       82:               | 40 :: _ -> A.bg A.black
       83:               | 41 :: _ -> A.bg A.red
       84:               | 42 :: _ -> A.bg A.green
       85:               | 43 :: _ -> A.bg A.yellow
       86:               | 44 :: _ -> A.bg A.blue
       87:               | 45 :: _ -> A.bg A.magenta
       88:               | 46 :: _ -> A.bg A.cyan
       89:               | 47 :: _ -> A.bg A.white
       90:               | 48 :: 5 :: color :: _ ->
       91:                   A.bg (A.unsafe_color_of_int (0x02000000 lor color))
       92:               | _ -> A.empty
       93:             in
       94:             (attr, !j + 1)
       95:           else (A.empty, i))
       96:         else (A.empty, i)
       97:       in
       98:       let k = ref j in
       99:       while !k < len && input.[!k] <> '\027' do
      100:         incr k
      101:       done;
      102:       let substring = String.sub input j (!k - j) in
      103:       parse_codes ((attr, substring) :: acc) !k
      104:   in
      105:   parse_codes [] 0
      106: 
      107: (** Like fold left except we run the first element through init to get the state*)
      108: let fold_left_pre (f : 'acc -> 'a -> 'acc) (init : 'a -> 'acc) (input : 'a list)
      109:     =
      110:   match input with
      111:   | [] -> invalid_arg "empty list"
      112:   | x :: xs ->
      113:       let state = init x in
      114:       xs |> List.fold_left f state
      115: 
      116: let string_to_image str =
      117:   let coded_strs = parse_ansi_escape_codes str in
      118:   let locate_newlines codes =
      119:     codes
      120:     |> List.concat_map (fun (attr, str) ->
      121:            str |> String.split_on_char '\n'
      122:            |> List.map (fun x -> `Image (I.string attr x))
      123:            |> Base.List.intersperse ~sep:`Newline)
      124:   in
      125:   let newline_seperated = locate_newlines coded_strs in
      126:   (* Printf.printf "len:%d" (List.length newline_seperated); *)
      127:   let lines =
      128:     let open I in
      129:     (* newline_seperated
      130:        |> List.iter (fun x -> match x with `Imarge i -> print_image i | _ -> ()); *)
      131:     newline_seperated
      132:     |> Base.List.fold ~init:([], I.empty) ~f:(fun (images, image) x ->
      133:            match x with
      134:            | `Newline -> (image :: images, I.empty)
      135:            | `Image nextImage -> (images, image <|> nextImage))
      136:     |> fst
      137:     (* |> List.map (fun x ->
      138:            x |> print_image;
      139:            x) *)
      140:     |> Base.List.reduce_exn ~f:(fun bottom top -> top <-> bottom)
      141:   in
      142:   let image =
      143:     lines
      144:     (* |> fold_left_pre
      145:          (fun image (attr, str) ->
      146:            let parts = str |> String.split_on_char '\n' in
      147:            let nextImage =
      148:              parts
      149:              |> fold_left_pre
      150:                   (fun image str -> I.( <-> ) image (I.string attr str))
      151:                   (I.string attr)
      152:            in
      153:            I.( <|> ) image nextImage)
      154:          (fun (attr, str) -> I.string attr str) *)
      155:   in
      156:   image
      157: 
      158: let escaped_string ?(attr = A.empty) str =
      159:   let control_character_index str i =
      160:     let len = String.length str in
      161:     let i = ref i in
      162:     while
      163:       let i = !i in
      164:       i < len && str.[i] >= ' '
      165:     do
      166:       incr i
      167:     done;
      168:     if !i = len then raise Not_found;
      169:     !i
      170:   in
      171:   let rec split str i =
      172:     match control_character_index str i with
      173:     | j ->
      174:         let img = I.string attr (String.sub str i (j - i)) in
      175:         img :: split str (j + 1)
      176:     | exception Not_found ->
      177:         [
      178:           I.string attr
      179:             (if i = 0 then str else String.sub str i (String.length str - i));
      180:         ]
      181:   in
      182:   I.vcat (split str 0)
      183: 
      184: (* let colored_string s =
      185:    s |> parse_ansi_escape_codes
      186:    |> List.map (fun (x, str) -> escaped_string ~attr:x str)
      187:    |> I.vcat *)
      188: let colored_string s = s |> string_to_image
      189: 
      190: let%expect_test "string_to_image" =
      191:   string_to_image
      192:     "\027[32mThis is in green %s\027[0m \027[30mThisisnotGreen\027[0m"
      193:   |> print_image;
      194:   [%expect.unreachable]
      195: [@@expect.uncaught_exn
      196:   {|
      197:   (* CR expect_test_collector: This test expectation appears to contain a backtrace.
      198:      This is strongly discouraged as backtraces are fragile.
      199:      Please change this test to not include a backtrace. *)
      200: 
      201:   (Invalid_argument List.reduce_exn)
      202:   Raised at Stdlib.invalid_arg in file "stdlib.ml", line 30, characters 20-45
      203:   Called from Jj_tui__AnsiReverse.(fun) in file "lib/ansiReverse.ml", line 197, characters 2-88
      204:   Called from Expect_test_collector.Make.Instance_io.exec in file "collector/expect_test_collector.ml", line 234, characters 12-19
      205: 
      206:   Trailing output
      207:   ---------------
      208:   params 32
      209:   params 0
      210:   params 30
      211:   params 0
      212:   len:4 |}]
      213: 
      214: let%expect_test "hello" =
      215:   let outBuf = Buffer.create 100 in
      216:   let _fmt = Format.formatter_of_buffer outBuf in
      217:   let res =
      218:     parse_ansi_escape_codes
      219:       "\027[32mThis is in green %s\027[0m \027[30mThisisnotGreen\027[0m"
      220:   in
      221:   res
      222:   |> List.iter (fun (x, str) ->
      223:          Notty.I.string x str |> Notty.Render.pp_image @@ Format.str_formatter);
      224:   print_endline (Format.flush_str_formatter () |> String.escaped);
      225:   print_endline (Buffer.contents outBuf);
      226:   [%expect
      227:     {|
      228:       params 32
      229:       params 0
      230:       params 30
      231:       params 0
      232:       \027[0m\027[K\027[0;32mThis is in green %s\027[0m\027[0m\027[K\027[0m \027[0m\027[0m\027[K\027[0;30mThisisnotGreen\027[0m\027[0m\027[K\027[0m|}]
      233: 
      234: let jjtest =
      235:   {|
      236:   @  [1m[38;5;13mm[38;5;8mtxzlotn[39m [38;5;3meli.jambu@gmail.com[39m [38;5;14m2024-05-08 12:19:37[39m [38;5;12mb[38;5;8mb87f772[39m[0m
      237:   │  [1m[38;5;3m(no description set)[39m[0m
      238: |}
      239: 
      240: let%expect_test "jj_test" =
      241:   jjtest |> string_to_image |> Notty.Render.pp_image @@ Format.str_formatter;
      242:   let res = Format.flush_str_formatter () in
      243:   print_endline "====== input=====";
      244:   print_endline (jjtest |> String.escaped);
      245:   print_endline "====== output escaped=====";
      246:   print_endline (res |> String.escaped);
      247:   print_endline "=====output====";
      248:   print_endline res;
      249:   [%expect
      250:     {|
      251:       params 1
      252:       params 38;5;13
      253:       nfg [0m<[0;95mATTR[0m[K[0m>[0m
      254:       params 38;5;8
      255:       nfg [0m<[0;90mATTR[0m[K[0m>[0m
      256:       params 39
      257:       params 38;5;3
      258:       nfg [0m<[0;33mATTR[0m[K[0m>[0m
      259:       params 39
      260:       params 38;5;14
      261:       nfg [0m<[0;96mATTR[0m[K[0m>[0m
      262:       params 39
      263:       params 38;5;12
      264:       nfg [0m<[0;94mATTR[0m[K[0m>[0m
      265:       params 38;5;8
      266:       nfg [0m<[0;90mATTR[0m[K[0m>[0m
      267:       params 39
      268:       params 0
      269:       params 1
      270:       params 38;5;3
      271:       nfg [0m<[0;33mATTR[0m[K[0m>[0m
      272:       params 39
      273:       params 0
      274:       len:23image:
      275:       \027[0m  \226\148\130  \027[0m\027[K\027[0;33m(no description set)\027[0m
      276:       image:
      277:       \027[0m  @  \027[0;95mm\027[0;90mtxzlotn\027[0m \027[0;33meli.jambu@gmail.com\027[0m \027[0;96m2024-05-08 12:19:37\027[0m \027[0;94mb\027[0m\027[K\027[0;90mb87f772\027[0m
      278:       image:
      279:       \027[0m\027[K\027[0m
      280:       ====== input=====
      281:       \n  @  \027[1m\027[38;5;13mm\027[38;5;8mtxzlotn\027[39m \027[38;5;3meli.jambu@gmail.com\027[39m \027[38;5;14m2024-05-08 12:19:37\027[39m \027[38;5;12mb\027[38;5;8mb87f772\027[39m\027[0m\n  \226\148\130  \027[1m\027[38;5;3m(no description set)\027[39m\027[0m\n
      282:       ====== output escaped=====
      283:       \027[0m\027[K\027[0m\n\027[0m  @  \027[0;95mm\027[0;90mtxzlotn\027[0m \027[0;33meli.jambu@gmail.com\027[0m \027[0;96m2024-05-08 12:19:37\027[0m \027[0;94mb\027[0m\027[K\027[0;90mb87f772\027[0m\n\027[0m  \226\148\130  \027[0;33m(no description set)\027[0m\027[K\027[0m                                     \027[0m
      284:       =====output====
      285:       [0m[K[0m
      286:       [0m  @  [0;95mm[0;90mtxzlotn[0m [0;33meli.jambu@gmail.com[0m [0;96m2024-05-08 12:19:37[0m [0;94mb[0m[K[0;90mb87f772[0m
      287:       [0m  │  [0;33m(no description set)[0m[K[0m                                     [0m|}]
      288: 
      289: (* let ansi =
      290:    {
      291:      skip =
      292:        (fun (b : Buffer.t) ->
      293:          let n = int_of_string (Buffer.contents b) in
      294:          Buffer.clear b;
      295:          n);
      296:      newline = (fun _ -> ());
      297:      altscr =
      298:        (fun b ->
      299:          Buffer.clear b;
      300:          String.equal (Buffer.contents b) "\x1b[?1049h");
      301:      cursat =
      302:        (fun b ->
      303:          let h = int_of_string (Buffer.contents b) in
      304:          Buffer.clear b;
      305:          Buffer.clear b;
      306:          (* skip ';' *)
      307:          let w = int_of_string (Buffer.contents b) in
      308:          Buffer.clear b;
      309:          (w - 1, h - 1));
      310:      cubcuf =
      311:        (fun b ->
      312:          let x = int_of_string (Buffer.contents b) in
      313:          Buffer.clear b;
      314:          if Buffer.nth b 0 = 'D' then -x else x);
      315:      cuucud =
      316:        (fun b ->
      317:          let y = int_of_string (Buffer.contents b) in
      318:          Buffer.clear b;
      319:          if Buffer.nth b 0 = 'A' then -y else y);
      320:      cr = (fun _ -> ());
      321:      clreol = (fun _ -> ());
      322:      cursvis =
      323:        (fun b ->
      324:          Buffer.clear b;
      325:          String.equal (Buffer.contents b) "\x1b[34h\x1b[?25h");
      326:      mouse =
      327:        (fun b ->
      328:          Buffer.clear b;
      329:          String.equal (Buffer.contents b) "\x1b[?1000;1002;1005;1015;1006h");
      330:      bpaste =
      331:        (fun b ->
      332:          Buffer.clear b;
      333:          String.equal (Buffer.contents b) "\x1b[?2004h");
      334:      sgr;
      335:    } *)
      336: (*
      337:      let no0 _ = ()
      338:      and no1 _ _ = ()
      339:      and no2 _ _ _ = ()
      340: 
      341:      let dumb =
      342:        {
      343:          skip = (fun b -> String.length (Buffer.contents b));
      344:          newline = (fun _ -> ());
      345:          altscr = no1;
      346:          cursat = (fun _ -> (0, 0));
      347:          cubcuf = (fun _ -> 0);
      348:          cuucud = (fun _ -> 0);
      349:          cr = no0;
      350:          clreol = no0;
      351:          cursvis = (fun _ -> false);
      352:          sgr = (fun _ -> A.empty);
      353:          mouse = (fun _ -> false);
      354:          bpaste = (fun _ -> false);
      355:        } *)
      356: (*
      357:      let erase cap buf = Buffer.clear buf (* KEEP ETA-LONG. *)
      358: 
      359:      let cursat0 cap b =
      360:        let w, h = cap.cursat b in
      361:        (max 0 (w - 1), max 0 (h - 1)) *)
Added regular file lib/dune:
        1: (library
        2:  (name jj_tui)
        3:  (inline_tests)
        4:  (libraries core stdio core_unix.command_unix notty nottui angstrom)
        5:  (preprocess
        6:   (pps ppx_expect)))
Added regular file lib/process.ml:
        1: 
        2: let mk_home_cmd cmd =
        3:   let home_dir = Unix.getenv "HOME" in
        4:   Printf.sprintf "HOME=%s %s" home_dir cmd
        5: 
        6: let proc_silent cmd =
        7:   let _exit_code = Unix.system (mk_home_cmd cmd) in
        8:   ()
        9: 
       10: let proc cmd =
       11:   Printf.eprintf "🐚  %s\n%!" cmd;
       12:   proc_silent cmd
       13: 
       14: let collect_chan (channel : in_channel) : string =
       15:   let rec loop acc =
       16:     match input_line channel with
       17:     | exception End_of_file -> acc
       18:     | line -> loop (acc ^ line ^ "\n")
       19:   in
       20:   loop ""
       21: 
       22: let proc_stdout cmd =
       23:   let ((proc_stdout, _proc_stdin, _proc_stderr) as process) =
       24:     Unix.open_process_full (mk_home_cmd cmd) [||]
       25:   in
       26:   let stdout_result = collect_chan proc_stdout in
       27:   let _ = Unix.close_process_full process in
       28:   String.trim stdout_result
       29: 
       30: let proc_stdOutAndErr cmd =
       31:   let ((proc_stdout, _proc_stdin, proc_stderr) as process) =
       32:     Unix.open_process_full (mk_home_cmd cmd) [||]
       33:   in
       34:   let stdout_result = collect_chan proc_stdout in
       35:   let stderr_result = collect_chan proc_stderr in
       36:   let _ = Unix.close_process_full process in
       37:   String.trim (stdout_result^stderr_result)
Added regular file log:
        1: ◉  [1m[38;5;5mv[0m[38;5;8myzuqwnl[39m [38;5;3meli.jambu@gmail.com[39m [38;5;6m2024-05-08 23:57:08[39m [1m[38;5;4m7[0m[38;5;8maf062fc[39m
        2: │  [38;5;3m(no description set)[39m
        3: ◉  [1m[38;5;5mxn[0m[38;5;8mvoukwm[39m [38;5;3meli.jambu@gmail.com[39m [38;5;6m2024-05-08 23:57:08[39m [1m[38;5;4m9[0m[38;5;8m50e51d4[39m
        4: │  using angstrom parser
        5: ◉  [1m[38;5;5mu[0m[38;5;8mwwzzulo[39m [38;5;3meli.jambu@gmail.com[39m [38;5;6m2024-05-08 23:57:08[39m [1m[38;5;4m4a[0m[38;5;8md3ac96[39m
        6: │  progress on ui, added boxes
        7: @  [1m[38;5;13mkszk[38;5;8muqqs[39m [38;5;3meli.jambu@gmail.com[39m [38;5;14m2024-05-08 23:57:08[39m [38;5;12mf[38;5;8mc74c4ed[39m[0m
        8: │  [1mcoloured output is working[0m
        9: ◉  [1m[38;5;5my[0m[38;5;8msrpqsvq[39m [38;5;3meli.jambu@gmail.com[39m [38;5;6m2024-05-08 01:18:11[39m [38;5;2mHEAD@git[39m [1m[38;5;4me[0m[38;5;8mc72cc90[39m
       10: │  [38;5;3m(no description set)[39m
       11: ◉  [1m[38;5;5mn[0m[38;5;8mulnswsm[39m [38;5;3meli.jambu@gmail.com[39m [38;5;6m2024-05-08 01:17:05[39m [1m[38;5;4mb[0m[38;5;8mfaef69b[39m
       12: │  [38;5;3m(no description set)[39m
       13: ◉  [1m[38;5;5mxw[0m[38;5;8msmkxpt[39m [38;5;3meli.jambu@gmail.com[39m [38;5;6m2024-05-08 01:08:13[39m [1m[38;5;4m2[0m[38;5;8m12a26e4[39m
       14: │  [38;5;3m(no description set)[39m
       15: ◉  [1m[38;5;5mkszy[0m[38;5;8mtrtu[39m [38;5;3meli.jambu@gmail.com[39m [38;5;6m2024-05-08 01:08:13[39m [1m[38;5;4m8[0m[38;5;8m754ef74[39m
       16: │  [38;5;3m(no description set)[39m
       17: ◉  [1m[38;5;5mp[0m[38;5;8msnrvlsv[39m [38;5;3meli.jambu@gmail.com[39m [38;5;6m2024-05-08 01:02:28[39m [1m[38;5;4md[0m[38;5;8m09f7fd4[39m
       18: │  [38;5;3m(no description set)[39m
       19: │ ◉  [1m[38;5;5mt[0m[38;5;8mooppyyl[39m [38;5;3meli.jambu@gmail.com[39m [38;5;6m2024-05-08 01:19:58[39m [1m[38;5;4m49[0m[38;5;8m125832[39m
       20: ├─╯  [38;5;3m(no description set)[39m
       21: ◉  [1m[38;5;5mz[0m[38;5;8mzzzzzzz[39m [38;5;2mroot()[39m [1m[38;5;4m0[0m[38;5;8m0000000[39m
Added regular file log2:
        1: Commit ID: 0dff1f977d48f4537fa8c357b8fe08c1910e4ac4
        2: Change ID: kszkuqqsvpknsnosxyxmnunnqvrzmpvq
        3: Author: Eli Dowling <eli.jambu@gmail.com> (2024-05-08 01:20:28)
        4: Committer: Eli Dowling <eli.jambu@gmail.com> (2024-05-09 00:02:20)
        5: 
        6:     coloured output is working
        7: 
        8: Added regular file ../.ocamlformat:
        9:         1: version=0.24.1
       10:         2: profile=conventional
       11: Removed regular file ../bin/dune:
       12:    1     : (executable
       13:    2     :  (public_name jj_tui)
       14:    3     :  (name main)
       15:    4     :  (libraries jj_tui feather lwd nottui base core stdio core_unix.command_unix )
       16:    5     :  )
       17: Removed regular file ../bin/main.ml:
       18:    1     : open Nottui;;
       19:    2     : open Feather;;
       20:    3     : open Lwd_infix;;
       21:    4     : module W = Nottui_widgets;;
       22:    5     : 
       23:    6     : 
       24:    7     : (* Ui_loop.run (Lwd.pure (W.printf "Hello world"));; *)
       25:    8     : 
       26:    9     : let cmdArgs cmd args=
       27:   10     :   let (stdout,stderr)=Feather.process cmd args|>Feather.collect stdout_and_stderr in
       28:   11     :   stdout^stderr
       29:   12     : ;;
       30:   13     : let cmd cmd =
       31:   14     :   let (stdout,stderr)=Feather.process cmd []|>Feather.collect stdout_and_stderr in
       32:   15     :   stdout^stderr
       33:   16     : 
       34:   17     : ;;
       35:   18     : 
       36:   19     : 
       37:   20     : let vcount = Lwd.var "";;
       38:   21     : 
       39:   22     : let button = 
       40:   23     :   W.button (Printf.sprintf "run jj" )
       41:   24     :            (fun () ->  vcount $= (cmd"jj"))
       42:   25     :   |>Lwd.pure
       43:   26     :          ;;
       44:   27     : let vQuit=Lwd.var false;;
       45:   28     : 
       46:   29     : let quitButton  = 
       47:   30     :   W.button (Printf.sprintf "quit " )
       48:   31     :            (fun () ->  vQuit $= true)
       49:   32     :   |>Lwd.pure
       50:   33     :          ;;
       51:   34     : 
       52:   35     : 
       53:   36     : let (<-$) f v=Lwd.map ~f (Lwd.get v);; 
       54:   37     : let vShowStatus= Lwd.var "";;
       55:   38     : let inputs ui=
       56:   39     :   Ui.event_filter (fun event->
       57:   40     :     match event with
       58:   41     :     |`Key (`ASCII 'l',_)-> 
       59:   42     :         let res=cmd "jj"in
       60:   43     :         vcount$=res;
       61:   44     : 
       62:   45     :         `Handled
       63:   46     :     |`Key (`ASCII 's',_)-> 
       64:   47     :         let res=cmdArgs "jj" ["show"]in
       65:   48     :         vShowStatus$=res;
       66:   49     : 
       67:   50     :         `Handled
       68:   51     :     |`Key (`ASCII 'p',_)-> 
       69:   52     :         let _=cmdArgs "jj"["prev"]in
       70:   53     : 
       71:   54     :         `Handled
       72:   55     :     |`Key (`ASCII 'n',_)-> 
       73:   56     :         let _=cmdArgs "jj"["next"]in
       74:   57     : 
       75:   58     :         `Handled
       76:   59     :     |_->`Unhandled
       77:   60     :       ) ui
       78:   61     :   ;;
       79:   62     : let mainUi= 
       80:   63     :   Lwd.map ~f:inputs @@
       81:   64     :   W.h_pane
       82:   65     :   (Nottui_widgets.vbox [
       83:   66     :     button;
       84:   67     :     W.string <-$ vcount;
       85:   68     :     quitButton])
       86:   69     :   (W.string <-$ vShowStatus)
       87:   70     : ;;
       88:   71     :       
       89:   72     : 
       90:   73     : Ui_loop.run ~quit:vQuit (mainUi);;
       91:   74     : 
       92:   75     : (*
       93:   76     : type tree = Tree of string * (unit -> tree list)
       94:   77     : 
       95:   78     : let rec tree_ui (Tree (label, child)) =
       96:   79     :   let opened = Lwd.var false in
       97:   80     :   let render is_opened =
       98:   81     :     let btn_text = if is_opened then "[-] " else "[+] " in
       99:   82     :     let btn_action () = Lwd.set opened (not is_opened) in
      100:   83     :     let btn = W.button (btn_text ^ label) btn_action in
      101:   84     :     let layout node forest =
      102:   85     :       Ui.join_y node (Ui.join_x (Ui.space 2 0) forest) 
      103:   86     :     in
      104:   87     :     if is_opened 
      105:   88     :     then Lwd.map ~f:(layout btn) (forest_ui (child ()))
      106:   89     :     else Lwd.pure btn
      107:   90     :   in
      108:   91     :   Lwd.join (Lwd.map ~f:render (Lwd.get opened))
      109:   92     :   
      110:   93     : and forest_ui nodes = 
      111:   94     :   Lwd_utils.pack Ui.pack_y 
      112:   95     :     (List.map tree_ui nodes)
      113:   96     : ;;
      114:   97     : 
      115:   98     : let rec fake_fs () = [
      116:   99     :   Tree ("bin", fake_fs);
      117:  100     :   Tree ("home", fake_fs);
      118:  101     :   Tree ("usr", fake_fs);
      119:  102     : ] in
      120:  103     : 
      121:  104     : Ui_loop.run (forest_ui (fake_fs ()));;
      122:  105     : *)
      123: Removed regular file ../dune-project:
      124:    1     : (lang dune 3.9)
      125:    2     : 
      126:    3     : (name jj_tui)
      127:    4     : 
      128:    5     : (generate_opam_files true)
      129:    6     : 
      130:    7     : (source
      131:    8     :  (github username/reponame))
      132:    9     : 
      133:   10     : (authors "Author Name")
      134:   11     : 
      135:   12     : (maintainers "Maintainer Name")
      136:   13     : 
      137:   14     : (license LICENSE)
      138:   15     : 
      139:   16     : (documentation https://url/to/documentation)
      140:   17     : 
      141:   18     : (package
      142:   19     :  (name jj_tui)
      143:   20     :  (synopsis "A short synopsis")
      144:   21     :  (description "A longer description")
      145:   22     :  (depends ocaml dune)
      146:   23     :  (tags
      147:   24     :   (topics "to describe" your project)))
      148:   25     : 
      149:   26     : ; See the complete stanza docs at https://dune.readthedocs.io/en/stable/dune-files.html#dune-project
      150: Removed regular file ../flake.lock:
      151:    1     : {
      152:    2     :   "nodes": {
      153:    3     :     "nixpkgs": {
      154:    4     :       "locked": {
      155:    5     :         "lastModified": 1713344939,
      156:    6     :         "narHash": "sha256-jpHkAt0sG2/J7ueKnG7VvLLkBYUMQbXQ2L8OBpVG53s=",
      157:    7     :         "path": "/nix/store/ngm8a5avsnfk266jha4j5xy93xfhjasf-source",
      158:    8     :         "rev": "e402c3eb6d88384ca6c52ef1c53e61bdc9b84ddd",
      159:    9     :         "type": "path"
      160:   10     :       },
      161:   11     :       "original": {
      162:   12     :         "id": "nixpkgs",
      163:   13     :         "type": "indirect"
      164:   14     :       }
      165:   15     :     },
      166:   16     :     "root": {
      167:   17     :       "inputs": {
      168:   18     :         "nixpkgs": "nixpkgs"
      169:   19     :       }
      170:   20     :     }
      171:   21     :   },
      172:   22     :   "root": "root",
      173:   23     :   "version": 7
      174:   24     : }
      175: Removed regular file ../flake.nix:
      176:    1     : {
      177:    2     :   description = "Example JavaScript development environment for Zero to Nix";
      178:    3     : 
      179:    4     :   # Flake inputs
      180:    5     :   inputs = {
      181:    6     : 
      182:    7     :     # nixpkgs.url = "github:NixOS/nixpkgs/nixos-unstable";
      183:    8     :     nixpkgs.url = "nixpkgs"; # also valid: "nixpkgs"
      184:    9     : 
      185:   10     :     # roc={
      186:   11     :     #   url="github:roc-lang/roc";
      187:   12     :     # inputs.nixpkgs.follows="nixpkgs";
      188:   13     : 
      189:   14     :     # };
      190:   15     : 
      191:   16     :   };
      192:   17     :   # Flake outputs
      193:   18     :   outputs = { self, nixpkgs, ... }@inputs:
      194:   19     :     let
      195:   20     :       # Systems supported
      196:   21     :       allSystems = [
      197:   22     :         "x86_64-linux" # 64-bit Intel/AMD Linux
      198:   23     :       ];
      199:   24     : 
      200:   25     :       # Helper to provide system-specific attributes
      201:   26     :       forAllSystems = f:
      202:   27     :         nixpkgs.lib.genAttrs allSystems (system:
      203:   28     :           f {
      204:   29     :             pkgs = import nixpkgs { inherit system; };
      205:   30     : 
      206:   31     :           });
      207:   32     :     in {
      208:   33     :       # Development environment output
      209:   34     :       devShells = forAllSystems ({ pkgs }: {
      210:   35     :         default =
      211:   36     : 
      212:   37     :           pkgs.mkShell {
      213:   38     :             packages = with pkgs; [ pkgs.pkg-config gmp stdenv.cc.cc.lib ];
      214:   39     :             shellHook = let
      215:   40     :               libPath =
      216:   41     :                 pkgs.lib.makeLibraryPath [ pkgs.stdenv.cc.cc.lib pkgs.gmp ];
      217:   42     :             in ''
      218:   43     :               # yolo
      219:   44     :               export CFLAGS="$CFLAGS -I${pkgs.stdenv.cc.cc.lib}/include -I${pkgs.gmp}/include"
      220:   45     :               export LIBS="$LIBS -L${pkgs.stdenv.cc.cc.lib}/lib -L${pkgs.gmp}/lib"
      221:   46     :             '';
      222:   47     :           };
      223:   48     : 
      224:   49     :       });
      225:   50     : 
      226:   51     :     };
      227:   52     : }
      228: Added regular file .ocamlformat:
      229:         1: 
      230:         2: profile=conventional
      231: Added regular file .ocmalformat:
      232:         1: version=0.24.1
      233:         2: profile=conventional
      234: Added regular file bin/dune:
      235:         1: (executable
      236:         2:  (public_name jj_tui)
      237:         3:  (name main)
      238:         4:  (libraries jj_tui feather lwd nottui base core stdio core_unix.command_unix )
      239:         5:  )
      240: Added regular file bin/main.ml:
      241:         1: open Nottui
      242:         2: open Feather
      243:         3: open Lwd_infix
      244:         4: open Notty
      245:         5: module W = Nottui_widgets
      246:         6: 
      247:         7: let colored_string = Jj_tui.AnsiReverse.colored_string
      248:         8: 
      249:         9: (* Ui_loop.run (Lwd.pure (W.printf "Hello world"));; *)
      250:        10: let cmdArgs cmd args =
      251:        11:   let stdout, stderr =
      252:        12:     Feather.process cmd args |> Feather.collect stdout_and_stderr
      253:        13:   in
      254:        14:   stdout ^ stderr
      255:        15: 
      256:        16: let jj args = cmdArgs "jj" (List.concat [ args; [ "--color"; "always" ] ])
      257:        17: let vcount = Lwd.var I.empty
      258:        18: 
      259:        19: let _button =
      260:        20:   W.button (Printf.sprintf "run jj") (fun () ->
      261:        21:       vcount $= (cmdArgs "jj" [ "log"; "--color"; "always" ] |> colored_string))
      262:        22:   |> Lwd.pure
      263:        23: 
      264:        24: let vQuit = Lwd.var false
      265:        25: 
      266:        26: let _quitButton =
      267:        27:   W.button (Printf.sprintf "quit ") (fun () -> vQuit $= true) |> Lwd.pure
      268:        28: 
      269:        29: let ( <-$ ) f v = Lwd.map ~f (Lwd.get v)
      270:        30: 
      271:        31: (* let ( let<- ) v f = Lwd.map ~f (Lwd.get v) *)
      272:        32: let vShowStatus = Lwd.var I.empty
      273:        33: let vother = Lwd.var ""
      274:        34: 
      275:        35: let onChange () =
      276:        36:   let res = jj [ "show" ] |> colored_string in
      277:        37:   vShowStatus $= res;
      278:        38:   let res = jj [] in
      279:        39:   vcount $= colored_string res
      280:        40: 
      281:        41: let changeInputs key =
      282:        42:   let noOut args =
      283:        43:     let _ = jj args in
      284:        44:     `Handled
      285:        45:   in
      286:        46:   match key with
      287:        47:   | 'P' -> noOut [ "prev" ]
      288:        48:   | 'p' -> noOut [ "prev"; "--edit" ]
      289:        49:   | 'N' -> noOut [ "next" ]
      290:        50:   | 'n' -> noOut [ "next"; "--edit" ]
      291:        51:   | 'S' -> noOut [ "unsquash"; "-i"; "--tool"; "sublime_merge" ]
      292:        52:   | _ -> `Unhandled
      293:        53: 
      294:        54: let inputs ui =
      295:        55:   Ui.event_filter
      296:        56:     (fun event ->
      297:        57:       match event with
      298:        58:       | `Key (`ASCII 's', _) ->
      299:        59:           let res = jj [ "show" ] in
      300:        60:           vShowStatus $= (res |> colored_string);
      301:        61: 
      302:        62:           `Handled
      303:        63:       | `Key (`ASCII 'l', _) ->
      304:        64:           let res = jj [] in
      305:        65:           vcount $= colored_string res;
      306:        66:           vother $= res;
      307:        67: 
      308:        68:           `Handled
      309:        69:       | `Key (`ASCII 'q', _) ->
      310:        70:           vQuit $= true;
      311:        71: 
      312:        72:           `Handled
      313:        73:       | `Key (`ASCII key, _) -> (
      314:        74:           match changeInputs key with
      315:        75:           | `Handled ->
      316:        76:               onChange ();
      317:        77:               `Handled
      318:        78:           | `Unhandled -> `Unhandled)
      319:        79:       | _ -> `Unhandled)
      320:        80:     ui
      321:        81: 
      322:        82: let mainUi =
      323:        83:   let$ pane =
      324:        84:     W.h_pane
      325:        85:       (Nottui_widgets.vbox
      326:        86:          [ (* button;  *) Ui.atom <-$ vcount (* quitButton  *) ])
      327:        87:       (Ui.atom <-$ vShowStatus)
      328:        88:   in
      329:        89:   inputs pane
      330:        90: ;;
      331:        91: 
      332:        92: (*TODO:For hosting a subprocess i should look into using EIO and Ui_loop.step like some of the other libraries built with nottui*)
      333:        93: Ui_loop.run ~quit:vQuit mainUi
      334:        94: (* let my_image=(Notty.I.string Notty.A.empty "\027[32mThis is in green %s\027[0m" ) in *)
      335:        95: (* let my_image =
      336:        96:      Jj_tui.AnsiReverse.Cap.parse_ansi_escape_codes
      337:        97:        "\027[32mThis is in green %s\027[0m "
      338:        98:      |> List.map (fun (x, str) -> Notty.I.string x str)
      339:        99:    ;;
      340:       100: 
      341:       101:    Notty_unix.output_image (my_image |> List.hd) *)
      342:       102: 
      343:       103: (*
      344:       104: type tree = Tree of string * (unit -> tree list)
      345:       105: 
      346:       106: let rec tree_ui (Tree (label, child)) =
      347:       107:   let opened = Lwd.var false in
      348:       108:   let render is_opened =
      349:       109:     let btn_text = if is_opened then "[-] " else "[+] " in
      350:       110:     let btn_action () = Lwd.set opened (not is_opened) in
      351:       111:     let btn = W.button (btn_text ^ label) btn_action in
      352:       112:     let layout node forest =
      353:       113:       Ui.join_y node (Ui.join_x (Ui.space 2 0) forest) 
      354:       114:     in
      355:       115:     if is_opened 
      356:       116:     then Lwd.map ~f:(layout btn) (forest_ui (child ()))
      357:       117:     else Lwd.pure btn
      358:       118:   in
      359:       119:   Lwd.join (Lwd.map ~f:render (Lwd.get opened))
      360:       120:   
      361:       121: and forest_ui nodes = 
      362:       122:   Lwd_utils.pack Ui.pack_y 
      363:       123:     (List.map tree_ui nodes)
      364:       124: ;;
      365:       125: 
      366:       126: let rec fake_fs () = [
      367:       127:   Tree ("bin", fake_fs);
      368:       128:   Tree ("home", fake_fs);
      369:       129:   Tree ("usr", fake_fs);
      370:       130: ] in
      371:       131: 
      372:       132: Ui_loop.run (forest_ui (fake_fs ()));;
      373:       133: *)
      374: Added regular file dune-project:
      375:         1: (lang dune 3.9)
      376:         2: 
      377:         3: (name jj_tui)
      378:         4: 
      379:         5: (generate_opam_files true)
      380:         6: 
      381:         7: (source
      382:         8:  (github username/reponame))
      383:         9: 
      384:        10: (authors "Author Name")
      385:        11: 
      386:        12: (maintainers "Maintainer Name")
      387:        13: 
      388:        14: (license LICENSE)
      389:        15: 
      390:        16: (documentation https://url/to/documentation)
      391:        17: 
      392:        18: (package
      393:        19:  (name jj_tui)
      394:        20:  (synopsis "A short synopsis")
      395:        21:  (description "A longer description")
      396:        22:  (depends ocaml dune)
      397:        23:  (tags
      398:        24:   (topics "to describe" your project)))
      399:        25: 
      400:        26: ; See the complete stanza docs at https://dune.readthedocs.io/en/stable/dune-files.html#dune-project
      401: Added regular file flake.lock:
      402:         1: {
      403:         2:   "nodes": {
      404:         3:     "nixpkgs": {
      405:         4:       "locked": {
      406:         5:         "lastModified": 1713344939,
      407:         6:         "narHash": "sha256-jpHkAt0sG2/J7ueKnG7VvLLkBYUMQbXQ2L8OBpVG53s=",
      408:         7:         "path": "/nix/store/ngm8a5avsnfk266jha4j5xy93xfhjasf-source",
      409:         8:         "rev": "e402c3eb6d88384ca6c52ef1c53e61bdc9b84ddd",
      410:         9:         "type": "path"
      411:        10:       },
      412:        11:       "original": {
      413:        12:         "id": "nixpkgs",
      414:        13:         "type": "indirect"
      415:        14:       }
      416:        15:     },
      417:        16:     "root": {
      418:        17:       "inputs": {
      419:        18:         "nixpkgs": "nixpkgs"
      420:        19:       }
      421:        20:     }
      422:        21:   },
      423:        22:   "root": "root",
      424:        23:   "version": 7
      425:        24: }
      426: Added regular file flake.nix:
      427:         1: {
      428:         2:   description = "Example JavaScript development environment for Zero to Nix";
      429:         3: 
      430:         4:   # Flake inputs
      431:         5:   inputs = {
      432:         6: 
      433:         7:     # nixpkgs.url = "github:NixOS/nixpkgs/nixos-unstable";
      434:         8:     nixpkgs.url = "nixpkgs"; # also valid: "nixpkgs"
      435:         9: 
      436:        10:     # roc={
      437:        11:     #   url="github:roc-lang/roc";
      438:        12:     # inputs.nixpkgs.follows="nixpkgs";
      439:        13: 
      440:        14:     # };
      441:        15: 
      442:        16:   };
      443:        17:   # Flake outputs
      444:        18:   outputs = { self, nixpkgs, ... }@inputs:
      445:        19:     let
      446:        20:       # Systems supported
      447:        21:       allSystems = [
      448:        22:         "x86_64-linux" # 64-bit Intel/AMD Linux
      449:        23:       ];
      450:        24: 
      451:        25:       # Helper to provide system-specific attributes
      452:        26:       forAllSystems = f:
      453:        27:         nixpkgs.lib.genAttrs allSystems (system:
      454:        28:           f {
      455:        29:             pkgs = import nixpkgs { inherit system; };
      456:        30: 
      457:        31:           });
      458:        32:     in {
      459:        33:       # Development environment output
      460:        34:       devShells = forAllSystems ({ pkgs }: {
      461:        35:         default =
      462:        36: 
      463:        37:           pkgs.mkShell {
      464:        38:             packages = with pkgs; [ pkgs.pkg-config gmp stdenv.cc.cc.lib ];
      465:        39:             shellHook = let
      466:        40:               libPath =
      467:        41:                 pkgs.lib.makeLibraryPath [ pkgs.stdenv.cc.cc.lib pkgs.gmp ];
      468:        42:             in ''
      469:        43:               # yolo
      470:        44:               export CFLAGS="$CFLAGS -I${pkgs.stdenv.cc.cc.lib}/include -I${pkgs.gmp}/include"
      471:        45:               export LIBS="$LIBS -L${pkgs.stdenv.cc.cc.lib}/lib -L${pkgs.gmp}/lib"
      472:        46:             '';
      473:        47:           };
      474:        48: 
      475:        49:       });
      476:        50: 
      477:        51:     };
      478:        52: }
      479: Added regular file jj_tui.opam:
      480:         1: # This file is generated by dune, edit dune-project instead
      481:         2: opam-version: "2.0"
      482:         3: synopsis: "A short synopsis"
      483:         4: description: "A longer description"
      484:         5: maintainer: ["Maintainer Name"]
      485:         6: authors: ["Author Name"]
      486:         7: license: "LICENSE"
      487:         8: tags: ["topics" "to describe" "your" "project"]
      488:         9: homepage: "https://github.com/username/reponame"
      489:        10: doc: "https://url/to/documentation"
      490:        11: bug-reports: "https://github.com/username/reponame/issues"
      491:        12: depends: [
      492:        13:   "ocaml"
      493:        14:   "dune" {>= "3.9"}
      494:        15:   "odoc" {with-doc}
      495:        16: ]
      496:        17: build: [
      497:        18:   ["dune" "subst"] {dev}
      498:        19:   [
      499:        20:     "dune"
      500:        21:     "build"
      501:        22:     "-p"
      502:        23:     name
      503:        24:     "-j"
      504:        25:     jobs
      505:        26:     "@install"
      506:        27:     "@runtest" {with-test}
      507:        28:     "@doc" {with-doc}
      508:        29:   ]
      509:        30: ]
      510:        31: dev-repo: "git+https://github.com/username/reponame.git"
      511: Added regular file lib/ansiReverse.ml:
      512:         1: open Notty
      513:         2: 
      514:         3: type op = Buffer.t -> unit
      515:         4: 
      516:         5: (* let ( & ) op1 op2 buf =
      517:         6:      op1 buf;
      518:         7:      op2 buf
      519:         8: 
      520:         9: 
      521:        10:    let ( <| ), ( <. ), ( <! ) = Buffer.(add_string, add_char, add_decimal) *)
      522:        11: let invalid_arg fmt = Format.kasprintf invalid_arg fmt
      523:        12: 
      524:        13: let rgb ~r ~g ~b =
      525:        14:   if r < 0 || g < 0 || b < 0 || r > 5 || g > 5 || b > 5 then
      526:        15:     invalid_arg "Notty.A.rgb %d %d %d: channel out of range" r g b
      527:        16:   else 0x01000000 lor ((r * 36) + (g * 6) + b + 16)
      528:        17: 
      529:        18: let gray level =
      530:        19:   if level < 0 || level > 23 then
      531:        20:     invalid_arg "Notty.A.gray %d: level out of range" level
      532:        21:   else 0x01000000 lor (level + 232)
      533:        22: 
      534:        23: let rgb_888 ~r ~g ~b =
      535:        24:   if r < 0 || g < 0 || b < 0 || r > 255 || g > 255 || b > 255 then
      536:        25:     invalid_arg "Notty.A.rgb_888 %d %d %d: channel out of range" r g b
      537:        26:   else 0x02000000 lor ((r lsl 16) lor (g lsl 8) lor b)
      538:        27: 
      539:        28: let sts = [ ";1"; ";3"; ";4"; ";5"; ";7" ]
      540:        29: 
      541:        30: let attr_of_ints fg bg st =
      542:        31:   A.fg @@ A.unsafe_color_of_int fg
      543:        32:   |> A.( ++ ) (A.bg @@ A.unsafe_color_of_int bg)
      544:        33:   |> A.( ++ ) (A.st @@ A.unsafe_style_of_int st)
      545:        34: 
      546:        35: let fg_int i = A.fg @@ A.unsafe_color_of_int i
      547:        36: let bg_int i = A.bg @@ A.unsafe_color_of_int i
      548:        37: 
      549:        38: let print_image img =
      550:        39:   print_endline "image:";
      551:        40:   img |> Notty.Render.pp_image @@ Format.str_formatter;
      552:        41:   print_endline (Format.flush_str_formatter () |> String.escaped)
      553:        42: 
      554:        43: let parse_ansi_escape_codes (input : string) : (A.t * string) list =
      555:        44:   let len = String.length input in
      556:        45:   let rec parse_codes acc i =
      557:        46:     if i >= len then List.rev acc
      558:        47:     else
      559:        48:       let attr, j =
      560:        49:         if i + 1 < len && input.[i] = '\027' && input.[i + 1] = '[' then (
      561:        50:           let params = ref [] in
      562:        51:           let j = ref (i + 2) in
      563:        52:           while !j < len && input.[!j] <> 'm' do
      564:        53:             let start = !j in
      565:        54:             while !j < len && input.[!j] <> ';' && input.[!j] <> 'm' do
      566:        55:               incr j
      567:        56:             done;
      568:        57:             let param = String.sub input start (!j - start) in
      569:        58:             params := int_of_string param :: !params;
      570:        59:             if !j < len && input.[!j] = ';' then incr j
      571:        60:           done;
      572:        61:           if !j < len && input.[!j] = 'm' then
      573:        62:             let params = List.rev !params in
      574:        63:             let attr =
      575:        64:               match params with
      576:        65:               | [] -> A.empty
      577:        66:               | 0 :: _ -> A.empty
      578:        67:               | 1 :: _ -> A.st A.bold
      579:        68:               | 2 :: _ -> A.st A.italic
      580:        69:               | 4 :: _ -> A.st A.underline
      581:        70:               | 5 :: _ -> A.st A.blink
      582:        71:               | 7 :: _ -> A.st A.reverse
      583:        72:               | 30 :: _ -> A.fg A.black
      584:        73:               | 31 :: _ -> A.fg A.red
      585:        74:               | 32 :: _ -> A.fg A.green
      586:        75:               | 33 :: _ -> A.fg A.yellow
      587:        76:               | 34 :: _ -> A.fg A.blue
      588:        77:               | 35 :: _ -> A.fg A.magenta
      589:        78:               | 36 :: _ -> A.fg A.cyan
      590:        79:               | 37 :: _ -> A.fg A.white
      591:        80:               | 38 :: 5 :: color :: _ ->
      592:        81:                   A.fg (A.unsafe_color_of_int (0x01000000 lor color))
      593:        82:               | 40 :: _ -> A.bg A.black
      594:        83:               | 41 :: _ -> A.bg A.red
      595:        84:               | 42 :: _ -> A.bg A.green
      596:        85:               | 43 :: _ -> A.bg A.yellow
      597:        86:               | 44 :: _ -> A.bg A.blue
      598:        87:               | 45 :: _ -> A.bg A.magenta
      599:        88:               | 46 :: _ -> A.bg A.cyan
      600:        89:               | 47 :: _ -> A.bg A.white
      601:        90:               | 48 :: 5 :: color :: _ ->
      602:        91:                   A.bg (A.unsafe_color_of_int (0x02000000 lor color))
      603:        92:               | _ -> A.empty
      604:        93:             in
      605:        94:             (attr, !j + 1)
      606:        95:           else (A.empty, i))
      607:        96:         else (A.empty, i)
      608:        97:       in
      609:        98:       let k = ref j in
      610:        99:       while !k < len && input.[!k] <> '\027' do
      611:       100:         incr k
      612:       101:       done;
      613:       102:       let substring = String.sub input j (!k - j) in
      614:       103:       parse_codes ((attr, substring) :: acc) !k
      615:       104:   in
      616:       105:   parse_codes [] 0
      617:       106: 
      618:       107: (** Like fold left except we run the first element through init to get the state*)
      619:       108: let fold_left_pre (f : 'acc -> 'a -> 'acc) (init : 'a -> 'acc) (input : 'a list)
      620:       109:     =
      621:       110:   match input with
      622:       111:   | [] -> invalid_arg "empty list"
      623:       112:   | x :: xs ->
      624:       113:       let state = init x in
      625:       114:       xs |> List.fold_left f state
      626:       115: 
      627:       116: let string_to_image str =
      628:       117:   let coded_strs = parse_ansi_escape_codes str in
      629:       118:   let locate_newlines codes =
      630:       119:     codes
      631:       120:     |> List.concat_map (fun (attr, str) ->
      632:       121:            str |> String.split_on_char '\n'
      633:       122:            |> List.map (fun x -> `Image (I.string attr x))
      634:       123:            |> Base.List.intersperse ~sep:`Newline)
      635:       124:   in
      636:       125:   let newline_seperated = locate_newlines coded_strs in
      637:       126:   (* Printf.printf "len:%d" (List.length newline_seperated); *)
      638:       127:   let lines =
      639:       128:     let open I in
      640:       129:     (* newline_seperated
      641:       130:        |> List.iter (fun x -> match x with `Imarge i -> print_image i | _ -> ()); *)
      642:       131:     newline_seperated
      643:       132:     |> Base.List.fold ~init:([], I.empty) ~f:(fun (images, image) x ->
      644:       133:            match x with
      645:       134:            | `Newline -> (image :: images, I.empty)
      646:       135:            | `Image nextImage -> (images, image <|> nextImage))
      647:       136:     |> fst
      648:       137:     (* |> List.map (fun x ->
      649:       138:            x |> print_image;
      650:       139:            x) *)
      651:       140:     |> Base.List.reduce_exn ~f:(fun bottom top -> top <-> bottom)
      652:       141:   in
      653:       142:   let image =
      654:       143:     lines
      655:       144:     (* |> fold_left_pre
      656:       145:          (fun image (attr, str) ->
      657:       146:            let parts = str |> String.split_on_char '\n' in
      658:       147:            let nextImage =
      659:       148:              parts
      660:       149:              |> fold_left_pre
      661:       150:                   (fun image str -> I.( <-> ) image (I.string attr str))
      662:       151:                   (I.string attr)
      663:       152:            in
      664:       153:            I.( <|> ) image nextImage)
      665:       154:          (fun (attr, str) -> I.string attr str) *)
      666:       155:   in
      667:       156:   image
      668:       157: 
      669:       158: let escaped_string ?(attr = A.empty) str =
      670:       159:   let control_character_index str i =
      671:       160:     let len = String.length str in
      672:       161:     let i = ref i in
      673:       162:     while
      674:       163:       let i = !i in
      675:       164:       i < len && str.[i] >= ' '
      676:       165:     do
      677:       166:       incr i
      678:       167:     done;
      679:       168:     if !i = len then raise Not_found;
      680:       169:     !i
      681:       170:   in
      682:       171:   let rec split str i =
      683:       172:     match control_character_index str i with
      684:       173:     | j ->
      685:       174:         let img = I.string attr (String.sub str i (j - i)) in
      686:       175:         img :: split str (j + 1)
      687:       176:     | exception Not_found ->
      688:       177:         [
      689:       178:           I.string attr
      690:       179:             (if i = 0 then str else String.sub str i (String.length str - i));
      691:       180:         ]
      692:       181:   in
      693:       182:   I.vcat (split str 0)
      694:       183: 
      695:       184: (* let colored_string s =
      696:       185:    s |> parse_ansi_escape_codes
      697:       186:    |> List.map (fun (x, str) -> escaped_string ~attr:x str)
      698:       187:    |> I.vcat *)
      699:       188: let colored_string s = s |> string_to_image
      700:       189: 
      701:       190: let%expect_test "string_to_image" =
      702:       191:   string_to_image
      703:       192:     "\027[32mThis is in green %s\027[0m \027[30mThisisnotGreen\027[0m"
      704:       193:   |> print_image;
      705:       194:   [%expect.unreachable]
      706:       195: [@@expect.uncaught_exn
      707:       196:   {|
      708:       197:   (* CR expect_test_collector: This test expectation appears to contain a backtrace.
      709:       198:      This is strongly discouraged as backtraces are fragile.
      710:       199:      Please change this test to not include a backtrace. *)
      711:       200: 
      712:       201:   (Invalid_argument List.reduce_exn)
      713:       202:   Raised at Stdlib.invalid_arg in file "stdlib.ml", line 30, characters 20-45
      714:       203:   Called from Jj_tui__AnsiReverse.(fun) in file "lib/ansiReverse.ml", line 197, characters 2-88
      715:       204:   Called from Expect_test_collector.Make.Instance_io.exec in file "collector/expect_test_collector.ml", line 234, characters 12-19
      716:       205: 
      717:       206:   Trailing output
      718:       207:   ---------------
      719:       208:   params 32
      720:       209:   params 0
      721:       210:   params 30
      722:       211:   params 0
      723:       212:   len:4 |}]
      724:       213: 
      725:       214: let%expect_test "hello" =
      726:       215:   let outBuf = Buffer.create 100 in
      727:       216:   let _fmt = Format.formatter_of_buffer outBuf in
      728:       217:   let res =
      729:       218:     parse_ansi_escape_codes
      730:       219:       "\027[32mThis is in green %s\027[0m \027[30mThisisnotGreen\027[0m"
      731:       220:   in
      732:       221:   res
      733:       222:   |> List.iter (fun (x, str) ->
      734:       223:          Notty.I.string x str |> Notty.Render.pp_image @@ Format.str_formatter);
      735:       224:   print_endline (Format.flush_str_formatter () |> String.escaped);
      736:       225:   print_endline (Buffer.contents outBuf);
      737:       226:   [%expect
      738:       227:     {|
      739:       228:       params 32
      740:       229:       params 0
      741:       230:       params 30
      742:       231:       params 0
      743:       232:       \027[0m\027[K\027[0;32mThis is in green %s\027[0m\027[0m\027[K\027[0m \027[0m\027[0m\027[K\027[0;30mThisisnotGreen\027[0m\027[0m\027[K\027[0m|}]
      744:       233: 
      745:       234: let jjtest =
      746:       235:   {|
      747:       236:   @  [1m[38;5;13mm[38;5;8mtxzlotn[39m [38;5;3meli.jambu@gmail.com[39m [38;5;14m2024-05-08 12:19:37[39m [38;5;12mb[38;5;8mb87f772[39m[0m
      748:       237:   │  [1m[38;5;3m(no description set)[39m[0m
      749:       238: |}
      750:       239: 
      751:       240: let%expect_test "jj_test" =
      752:       241:   jjtest |> string_to_image |> Notty.Render.pp_image @@ Format.str_formatter;
      753:       242:   let res = Format.flush_str_formatter () in
      754:       243:   print_endline "====== input=====";
      755:       244:   print_endline (jjtest |> String.escaped);
      756:       245:   print_endline "====== output escaped=====";
      757:       246:   print_endline (res |> String.escaped);
      758:       247:   print_endline "=====output====";
      759:       248:   print_endline res;
      760:       249:   [%expect
      761:       250:     {|
      762:       251:       params 1
      763:       252:       params 38;5;13
      764:       253:       nfg [0m<[0;95mATTR[0m[K[0m>[0m
      765:       254:       params 38;5;8
      766:       255:       nfg [0m<[0;90mATTR[0m[K[0m>[0m
      767:       256:       params 39
      768:       257:       params 38;5;3
      769:       258:       nfg [0m<[0;33mATTR[0m[K[0m>[0m
      770:       259:       params 39
      771:       260:       params 38;5;14
      772:       261:       nfg [0m<[0;96mATTR[0m[K[0m>[0m
      773:       262:       params 39
      774:       263:       params 38;5;12
      775:       264:       nfg [0m<[0;94mATTR[0m[K[0m>[0m
      776:       265:       params 38;5;8
      777:       266:       nfg [0m<[0;90mATTR[0m[K[0m>[0m
      778:       267:       params 39
      779:       268:       params 0
      780:       269:       params 1
      781:       270:       params 38;5;3
      782:       271:       nfg [0m<[0;33mATTR[0m[K[0m>[0m
      783:       272:       params 39
      784:       273:       params 0
      785:       274:       len:23image:
      786:       275:       \027[0m  \226\148\130  \027[0m\027[K\027[0;33m(no description set)\027[0m
      787:       276:       image:
      788:       277:       \027[0m  @  \027[0;95mm\027[0;90mtxzlotn\027[0m \027[0;33meli.jambu@gmail.com\027[0m \027[0;96m2024-05-08 12:19:37\027[0m \027[0;94mb\027[0m\027[K\027[0;90mb87f772\027[0m
      789:       278:       image:
      790:       279:       \027[0m\027[K\027[0m
      791:       280:       ====== input=====
      792:       281:       \n  @  \027[1m\027[38;5;13mm\027[38;5;8mtxzlotn\027[39m \027[38;5;3meli.jambu@gmail.com\027[39m \027[38;5;14m2024-05-08 12:19:37\027[39m \027[38;5;12mb\027[38;5;8mb87f772\027[39m\027[0m\n  \226\148\130  \027[1m\027[38;5;3m(no description set)\027[39m\027[0m\n
      793:       282:       ====== output escaped=====
      794:       283:       \027[0m\027[K\027[0m\n\027[0m  @  \027[0;95mm\027[0;90mtxzlotn\027[0m \027[0;33meli.jambu@gmail.com\027[0m \027[0;96m2024-05-08 12:19:37\027[0m \027[0;94mb\027[0m\027[K\027[0;90mb87f772\027[0m\n\027[0m  \226\148\130  \027[0;33m(no description set)\027[0m\027[K\027[0m                                     \027[0m
      795:       284:       =====output====
      796:       285:       [0m[K[0m
      797:       286:       [0m  @  [0;95mm[0;90mtxzlotn[0m [0;33meli.jambu@gmail.com[0m [0;96m2024-05-08 12:19:37[0m [0;94mb[0m[K[0;90mb87f772[0m
      798:       287:       [0m  │  [0;33m(no description set)[0m[K[0m                                     [0m|}]
      799:       288: 
      800:       289: (* let ansi =
      801:       290:    {
      802:       291:      skip =
      803:       292:        (fun (b : Buffer.t) ->
      804:       293:          let n = int_of_string (Buffer.contents b) in
      805:       294:          Buffer.clear b;
      806:       295:          n);
      807:       296:      newline = (fun _ -> ());
      808:       297:      altscr =
      809:       298:        (fun b ->
      810:       299:          Buffer.clear b;
      811:       300:          String.equal (Buffer.contents b) "\x1b[?1049h");
      812:       301:      cursat =
      813:       302:        (fun b ->
      814:       303:          let h = int_of_string (Buffer.contents b) in
      815:       304:          Buffer.clear b;
      816:       305:          Buffer.clear b;
      817:       306:          (* skip ';' *)
      818:       307:          let w = int_of_string (Buffer.contents b) in
      819:       308:          Buffer.clear b;
      820:       309:          (w - 1, h - 1));
      821:       310:      cubcuf =
      822:       311:        (fun b ->
      823:       312:          let x = int_of_string (Buffer.contents b) in
      824:       313:          Buffer.clear b;
      825:       314:          if Buffer.nth b 0 = 'D' then -x else x);
      826:       315:      cuucud =
      827:       316:        (fun b ->
      828:       317:          let y = int_of_string (Buffer.contents b) in
      829:       318:          Buffer.clear b;
      830:       319:          if Buffer.nth b 0 = 'A' then -y else y);
      831:       320:      cr = (fun _ -> ());
      832:       321:      clreol = (fun _ -> ());
      833:       322:      cursvis =
      834:       323:        (fun b ->
      835:       324:          Buffer.clear b;
      836:       325:          String.equal (Buffer.contents b) "\x1b[34h\x1b[?25h");
      837:       326:      mouse =
      838:       327:        (fun b ->
      839:       328:          Buffer.clear b;
      840:       329:          String.equal (Buffer.contents b) "\x1b[?1000;1002;1005;1015;1006h");
      841:       330:      bpaste =
      842:       331:        (fun b ->
      843:       332:          Buffer.clear b;
      844:       333:          String.equal (Buffer.contents b) "\x1b[?2004h");
      845:       334:      sgr;
      846:       335:    } *)
      847:       336: (*
      848:       337:      let no0 _ = ()
      849:       338:      and no1 _ _ = ()
      850:       339:      and no2 _ _ _ = ()
      851:       340: 
      852:       341:      let dumb =
      853:       342:        {
      854:       343:          skip = (fun b -> String.length (Buffer.contents b));
      855:       344:          newline = (fun _ -> ());
      856:       345:          altscr = no1;
      857:       346:          cursat = (fun _ -> (0, 0));
      858:       347:          cubcuf = (fun _ -> 0);
      859:       348:          cuucud = (fun _ -> 0);
      860:       349:          cr = no0;
      861:       350:          clreol = no0;
      862:       351:          cursvis = (fun _ -> false);
      863:       352:          sgr = (fun _ -> A.empty);
      864:       353:          mouse = (fun _ -> false);
      865:       354:          bpaste = (fun _ -> false);
      866:       355:        } *)
      867:       356: (*
      868:       357:      let erase cap buf = Buffer.clear buf (* KEEP ETA-LONG. *)
      869:       358: 
      870:       359:      let cursat0 cap b =
      871:       360:        let w, h = cap.cursat b in
      872:       361:        (max 0 (w - 1), max 0 (h - 1)) *)
      873: Added regular file lib/dune:
      874:         1: (library
      875:         2:  (name jj_tui)
      876:         3:  (inline_tests)
      877:         4:  (libraries core stdio core_unix.command_unix notty nottui angstrom)
      878:         5:  (preprocess
      879:         6:   (pps ppx_expect)))
      880: Added regular file lib/process.ml:
      881:         1: 
      882:         2: let mk_home_cmd cmd =
      883:         3:   let home_dir = Unix.getenv "HOME" in
      884:         4:   Printf.sprintf "HOME=%s %s" home_dir cmd
      885:         5: 
      886:         6: let proc_silent cmd =
      887:         7:   let _exit_code = Unix.system (mk_home_cmd cmd) in
      888:         8:   ()
      889:         9: 
      890:        10: let proc cmd =
      891:        11:   Printf.eprintf "🐚  %s\n%!" cmd;
      892:        12:   proc_silent cmd
      893:        13: 
      894:        14: let collect_chan (channel : in_channel) : string =
      895:        15:   let rec loop acc =
      896:        16:     match input_line channel with
      897:        17:     | exception End_of_file -> acc
      898:        18:     | line -> loop (acc ^ line ^ "\n")
      899:        19:   in
      900:        20:   loop ""
      901:        21: 
      902:        22: let proc_stdout cmd =
      903:        23:   let ((proc_stdout, _proc_stdin, _proc_stderr) as process) =
      904:        24:     Unix.open_process_full (mk_home_cmd cmd) [||]
      905:        25:   in
      906:        26:   let stdout_result = collect_chan proc_stdout in
      907:        27:   let _ = Unix.close_process_full process in
      908:        28:   String.trim stdout_result
      909:        29: 
      910:        30: let proc_stdOutAndErr cmd =
      911:        31:   let ((proc_stdout, _proc_stdin, proc_stderr) as process) =
      912:        32:     Unix.open_process_full (mk_home_cmd cmd) [||]
      913:        33:   in
      914:        34:   let stdout_result = collect_chan proc_stdout in
      915:        35:   let stderr_result = collect_chan proc_stderr in
      916:        36:   let _ = Unix.close_process_full process in
      917:        37:   String.trim (stdout_result^stderr_result)
      918: Added regular file log:
      919:         1: ◉  [1m[38;5;5mv[0m[38;5;8myzuqwnl[39m [38;5;3meli.jambu@gmail.com[39m [38;5;6m2024-05-08 23:57:08[39m [1m[38;5;4m7[0m[38;5;8maf062fc[39m
      920:         2: │  [38;5;3m(no description set)[39m
      921:         3: ◉  [1m[38;5;5mxn[0m[38;5;8mvoukwm[39m [38;5;3meli.jambu@gmail.com[39m [38;5;6m2024-05-08 23:57:08[39m [1m[38;5;4m9[0m[38;5;8m50e51d4[39m
      922:         4: │  using angstrom parser
      923:         5: ◉  [1m[38;5;5mu[0m[38;5;8mwwzzulo[39m [38;5;3meli.jambu@gmail.com[39m [38;5;6m2024-05-08 23:57:08[39m [1m[38;5;4m4a[0m[38;5;8md3ac96[39m
      924:         6: │  progress on ui, added boxes
      925:         7: @  [1m[38;5;13mkszk[38;5;8muqqs[39m [38;5;3meli.jambu@gmail.com[39m [38;5;14m2024-05-08 23:57:08[39m [38;5;12mf[38;5;8mc74c4ed[39m[0m
      926:         8: │  [1mcoloured output is working[0m
      927:         9: ◉  [1m[38;5;5my[0m[38;5;8msrpqsvq[39m [38;5;3meli.jambu@gmail.com[39m [38;5;6m2024-05-08 01:18:11[39m [38;5;2mHEAD@git[39m [1m[38;5;4me[0m[38;5;8mc72cc90[39m
      928:        10: │  [38;5;3m(no description set)[39m
      929:        11: ◉  [1m[38;5;5mn[0m[38;5;8mulnswsm[39m [38;5;3meli.jambu@gmail.com[39m [38;5;6m2024-05-08 01:17:05[39m [1m[38;5;4mb[0m[38;5;8mfaef69b[39m
      930:        12: │  [38;5;3m(no description set)[39m
      931:        13: ◉  [1m[38;5;5mxw[0m[38;5;8msmkxpt[39m [38;5;3meli.jambu@gmail.com[39m [38;5;6m2024-05-08 01:08:13[39m [1m[38;5;4m2[0m[38;5;8m12a26e4[39m
      932:        14: │  [38;5;3m(no description set)[39m
      933:        15: ◉  [1m[38;5;5mkszy[0m[38;5;8mtrtu[39m [38;5;3meli.jambu@gmail.com[39m [38;5;6m2024-05-08 01:08:13[39m [1m[38;5;4m8[0m[38;5;8m754ef74[39m
      934:        16: │  [38;5;3m(no description set)[39m
      935:        17: ◉  [1m[38;5;5mp[0m[38;5;8msnrvlsv[39m [38;5;3meli.jambu@gmail.com[39m [38;5;6m2024-05-08 01:02:28[39m [1m[38;5;4md[0m[38;5;8m09f7fd4[39m
      936:        18: │  [38;5;3m(no description set)[39m
      937:        19: │ ◉  [1m[38;5;5mt[0m[38;5;8mooppyyl[39m [38;5;3meli.jambu@gmail.com[39m [38;5;6m2024-05-08 01:19:58[39m [1m[38;5;4m49[0m[38;5;8m125832[39m
      938:        20: ├─╯  [38;5;3m(no description set)[39m
      939:        21: ◉  [1m[38;5;5mz[0m[38;5;8mzzzzzzz[39m [38;5;2mroot()[39m [1m[38;5;4m0[0m[38;5;8m0000000[39m
      940: Added regular file log2:
      941:     (empty)
      942: Added regular file test/dune:
      943:         1: (test
      944:         2:  (name jj_tui)
      945:         3:  (libraries jj_tui)
      946:         4:  (preprocess
      947:         5:   (pps ppx_jane ppx_expect)))
      948: Added regular file test/jj_tui.ml:
      949:     (empty)
      950: Added regular file testing/hi:
      951:         1: hiiiiiii
      952:         2: hiiiiiiiiiiii
      953:         3: hiiiiiiiiiiii
      954: Added regular file testing/other/file:
      955:         1: hello Im other
      956: Removed regular file ../jj_tui.install:
      957:    1     : lib: [
      958:    2     :   "_build/install/default/lib/jj_tui/META"
      959:    3     :   "_build/install/default/lib/jj_tui/dune-package"
      960:    4     :   "_build/install/default/lib/jj_tui/opam"
      961:    5     : ]
      962:    6     : bin: [
      963:    7     :   "_build/install/default/bin/jj_tui"
      964:    8     : ]
      965: Removed regular file ../jj_tui.opam:
      966:    1     : # This file is generated by dune, edit dune-project instead
      967:    2     : opam-version: "2.0"
      968:    3     : synopsis: "A short synopsis"
      969:    4     : description: "A longer description"
      970:    5     : maintainer: ["Maintainer Name"]
      971:    6     : authors: ["Author Name"]
      972:    7     : license: "LICENSE"
      973:    8     : tags: ["topics" "to describe" "your" "project"]
      974:    9     : homepage: "https://github.com/username/reponame"
      975:   10     : doc: "https://url/to/documentation"
      976:   11     : bug-reports: "https://github.com/username/reponame/issues"
      977:   12     : depends: [
      978:   13     :   "ocaml"
      979:   14     :   "dune" {>= "3.9"}
      980:   15     :   "odoc" {with-doc}
      981:   16     : ]
      982:   17     : build: [
      983:   18     :   ["dune" "subst"] {dev}
      984:   19     :   [
      985:   20     :     "dune"
      986:   21     :     "build"
      987:   22     :     "-p"
      988:   23     :     name
      989:   24     :     "-j"
      990:   25     :     jobs
      991:   26     :     "@install"
      992:   27     :     "@runtest" {with-test}
      993:   28     :     "@doc" {with-doc}
      994:   29     :   ]
      995:   30     : ]
      996:   31     : dev-repo: "git+https://github.com/username/reponame.git"
      997: Removed regular file ../lib/dune:
      998:    1     : (library
      999:    2     :  (name jj_tui)
     1000:    3     :  (libraries core stdio core_unix.command_unix )
     1001:    4     :  )
     1002:    5     : 
     1003: Removed regular file ../lib/process.ml:
     1004:    1     : 
     1005:    2     : let mk_home_cmd cmd =
     1006:    3     :   let home_dir = Unix.getenv "HOME" in
     1007:    4     :   Printf.sprintf "HOME=%s %s" home_dir cmd
     1008:    5     : 
     1009:    6     : let proc_silent cmd =
     1010:    7     :   let _exit_code = Unix.system (mk_home_cmd cmd) in
     1011:    8     :   ()
     1012:    9     : 
     1013:   10     : let proc cmd =
     1014:   11     :   Printf.eprintf "🐚  %s\n%!" cmd;
     1015:   12     :   proc_silent cmd
     1016:   13     : 
     1017:   14     : let collect_chan (channel : in_channel) : string =
     1018:   15     :   let rec loop acc =
     1019:   16     :     match input_line channel with
     1020:   17     :     | exception End_of_file -> acc
     1021:   18     :     | line -> loop (acc ^ line ^ "\n")
     1022:   19     :   in
     1023:   20     :   loop ""
     1024:   21     : 
     1025:   22     : let proc_stdout cmd =
     1026:   23     :   let ((proc_stdout, _proc_stdin, _proc_stderr) as process) =
     1027:   24     :     Unix.open_process_full (mk_home_cmd cmd) [||]
     1028:   25     :   in
     1029:   26     :   let stdout_result = collect_chan proc_stdout in
     1030:   27     :   let _ = Unix.close_process_full process in
     1031:   28     :   String.trim stdout_result
     1032:   29     : 
     1033:   30     : let proc_stdOutAndErr cmd =
     1034:   31     :   let ((proc_stdout, _proc_stdin, proc_stderr) as process) =
     1035:   32     :     Unix.open_process_full (mk_home_cmd cmd) [||]
     1036:   33     :   in
     1037:   34     :   let stdout_result = collect_chan proc_stdout in
     1038:   35     :   let stderr_result = collect_chan proc_stderr in
     1039:   36     :   let _ = Unix.close_process_full process in
     1040:   37     :   String.trim (stdout_result^stderr_result)
     1041: Removed regular file ../minttea/leaves.install:
     1042:    1     : lib: [
     1043:    2     :   "_build/install/default/lib/leaves/META"
     1044:    3     :   "_build/install/default/lib/leaves/cursor.ml"
     1045:    4     :   "_build/install/default/lib/leaves/cursor.mli"
     1046:    5     :   "_build/install/default/lib/leaves/dune-package"
     1047:    6     :   "_build/install/default/lib/leaves/filtered_list.ml"
     1048:    7     :   "_build/install/default/lib/leaves/filtered_list.mli"
     1049:    8     :   "_build/install/default/lib/leaves/forms.ml"
     1050:    9     :   "_build/install/default/lib/leaves/fps.ml"
     1051:   10     :   "_build/install/default/lib/leaves/fps.mli"
     1052:   11     :   "_build/install/default/lib/leaves/leaves.a"
     1053:   12     :   "_build/install/default/lib/leaves/leaves.cma"
     1054:   13     :   "_build/install/default/lib/leaves/leaves.cmi"
     1055:   14     :   "_build/install/default/lib/leaves/leaves.cmt"
     1056:   15     :   "_build/install/default/lib/leaves/leaves.cmx"
     1057:   16     :   "_build/install/default/lib/leaves/leaves.cmxa"
     1058:   17     :   "_build/install/default/lib/leaves/leaves.ml"
     1059:   18     :   "_build/install/default/lib/leaves/leaves__Cursor.cmi"
     1060:   19     :   "_build/install/default/lib/leaves/leaves__Cursor.cmt"
     1061:   20     :   "_build/install/default/lib/leaves/leaves__Cursor.cmti"
     1062:   21     :   "_build/install/default/lib/leaves/leaves__Cursor.cmx"
     1063:   22     :   "_build/install/default/lib/leaves/leaves__Filtered_list.cmi"
     1064:   23     :   "_build/install/default/lib/leaves/leaves__Filtered_list.cmt"
     1065:   24     :   "_build/install/default/lib/leaves/leaves__Filtered_list.cmti"
     1066:   25     :   "_build/install/default/lib/leaves/leaves__Filtered_list.cmx"
     1067:   26     :   "_build/install/default/lib/leaves/leaves__Forms.cmi"
     1068:   27     :   "_build/install/default/lib/leaves/leaves__Forms.cmt"
     1069:   28     :   "_build/install/default/lib/leaves/leaves__Forms.cmx"
     1070:   29     :   "_build/install/default/lib/leaves/leaves__Fps.cmi"
     1071:   30     :   "_build/install/default/lib/leaves/leaves__Fps.cmt"
     1072:   31     :   "_build/install/default/lib/leaves/leaves__Fps.cmti"
     1073:   32     :   "_build/install/default/lib/leaves/leaves__Fps.cmx"
     1074:   33     :   "_build/install/default/lib/leaves/leaves__Paginator.cmi"
     1075:   34     :   "_build/install/default/lib/leaves/leaves__Paginator.cmt"
     1076:   35     :   "_build/install/default/lib/leaves/leaves__Paginator.cmti"
     1077:   36     :   "_build/install/default/lib/leaves/leaves__Paginator.cmx"
     1078:   37     :   "_build/install/default/lib/leaves/leaves__Progress.cmi"
     1079:   38     :   "_build/install/default/lib/leaves/leaves__Progress.cmt"
     1080:   39     :   "_build/install/default/lib/leaves/leaves__Progress.cmti"
     1081:   40     :   "_build/install/default/lib/leaves/leaves__Progress.cmx"
     1082:   41     :   "_build/install/default/lib/leaves/leaves__Spinner.cmi"
     1083:   42     :   "_build/install/default/lib/leaves/leaves__Spinner.cmt"
     1084:   43     :   "_build/install/default/lib/leaves/leaves__Spinner.cmti"
     1085:   44     :   "_build/install/default/lib/leaves/leaves__Spinner.cmx"
     1086:   45     :   "_build/install/default/lib/leaves/leaves__Sprite.cmi"
     1087:   46     :   "_build/install/default/lib/leaves/leaves__Sprite.cmt"
     1088:   47     :   "_build/install/default/lib/leaves/leaves__Sprite.cmti"
     1089:   48     :   "_build/install/default/lib/leaves/leaves__Sprite.cmx"
     1090:   49     :   "_build/install/default/lib/leaves/leaves__Table.cmi"
     1091:   50     :   "_build/install/default/lib/leaves/leaves__Table.cmt"
     1092:   51     :   "_build/install/default/lib/leaves/leaves__Table.cmx"
     1093:   52     :   "_build/install/default/lib/leaves/leaves__Text_input.cmi"
     1094:   53     :   "_build/install/default/lib/leaves/leaves__Text_input.cmt"
     1095:   54     :   "_build/install/default/lib/leaves/leaves__Text_input.cmti"
     1096:   55     :   "_build/install/default/lib/leaves/leaves__Text_input.cmx"
     1097:   56     :   "_build/install/default/lib/leaves/opam"
     1098:   57     :   "_build/install/default/lib/leaves/paginator.ml"
     1099:   58     :   "_build/install/default/lib/leaves/paginator.mli"
     1100:   59     :   "_build/install/default/lib/leaves/progress.ml"
     1101:   60     :   "_build/install/default/lib/leaves/progress.mli"
     1102:   61     :   "_build/install/default/lib/leaves/spinner.ml"
     1103:   62     :   "_build/install/default/lib/leaves/spinner.mli"
     1104:   63     :   "_build/install/default/lib/leaves/sprite.ml"
     1105:   64     :   "_build/install/default/lib/leaves/sprite.mli"
     1106:   65     :   "_build/install/default/lib/leaves/table.ml"
     1107:   66     :   "_build/install/default/lib/leaves/text_input.ml"
     1108:   67     :   "_build/install/default/lib/leaves/text_input.mli"
     1109:   68     : ]
     1110:   69     : libexec: [
     1111:   70     :   "_build/install/default/lib/leaves/leaves.cmxs"
     1112:   71     : ]
     1113:   72     : doc: [
     1114:   73     :   "_build/install/default/doc/leaves/CHANGES.md"
     1115:   74     :   "_build/install/default/doc/leaves/LICENSE.md"
     1116:   75     :   "_build/install/default/doc/leaves/README.md"
     1117:   76     : ]
     1118: Removed regular file ../minttea/minttea.install:
     1119:    1     : lib: [
     1120:    2     :   "_build/install/default/lib/minttea/META"
     1121:    3     :   "_build/install/default/lib/minttea/app.ml"
     1122:    4     :   "_build/install/default/lib/minttea/command.ml"
     1123:    5     :   "_build/install/default/lib/minttea/dune-package"
     1124:    6     :   "_build/install/default/lib/minttea/event.ml"
     1125:    7     :   "_build/install/default/lib/minttea/io_loop.ml"
     1126:    8     :   "_build/install/default/lib/minttea/minttea.a"
     1127:    9     :   "_build/install/default/lib/minttea/minttea.cma"
     1128:   10     :   "_build/install/default/lib/minttea/minttea.cmi"
     1129:   11     :   "_build/install/default/lib/minttea/minttea.cmt"
     1130:   12     :   "_build/install/default/lib/minttea/minttea.cmti"
     1131:   13     :   "_build/install/default/lib/minttea/minttea.cmx"
     1132:   14     :   "_build/install/default/lib/minttea/minttea.cmxa"
     1133:   15     :   "_build/install/default/lib/minttea/minttea.ml"
     1134:   16     :   "_build/install/default/lib/minttea/minttea.mli"
     1135:   17     :   "_build/install/default/lib/minttea/minttea__.cmi"
     1136:   18     :   "_build/install/default/lib/minttea/minttea__.cmt"
     1137:   19     :   "_build/install/default/lib/minttea/minttea__.cmx"
     1138:   20     :   "_build/install/default/lib/minttea/minttea__.ml"
     1139:   21     :   "_build/install/default/lib/minttea/minttea__App.cmi"
     1140:   22     :   "_build/install/default/lib/minttea/minttea__App.cmt"
     1141:   23     :   "_build/install/default/lib/minttea/minttea__App.cmx"
     1142:   24     :   "_build/install/default/lib/minttea/minttea__Command.cmi"
     1143:   25     :   "_build/install/default/lib/minttea/minttea__Command.cmt"
     1144:   26     :   "_build/install/default/lib/minttea/minttea__Command.cmx"
     1145:   27     :   "_build/install/default/lib/minttea/minttea__Event.cmi"
     1146:   28     :   "_build/install/default/lib/minttea/minttea__Event.cmt"
     1147:   29     :   "_build/install/default/lib/minttea/minttea__Event.cmx"
     1148:   30     :   "_build/install/default/lib/minttea/minttea__Io_loop.cmi"
     1149:   31     :   "_build/install/default/lib/minttea/minttea__Io_loop.cmt"
     1150:   32     :   "_build/install/default/lib/minttea/minttea__Io_loop.cmx"
     1151:   33     :   "_build/install/default/lib/minttea/minttea__Program.cmi"
     1152:   34     :   "_build/install/default/lib/minttea/minttea__Program.cmt"
     1153:   35     :   "_build/install/default/lib/minttea/minttea__Program.cmx"
     1154:   36     :   "_build/install/default/lib/minttea/minttea__Renderer.cmi"
     1155:   37     :   "_build/install/default/lib/minttea/minttea__Renderer.cmt"
     1156:   38     :   "_build/install/default/lib/minttea/minttea__Renderer.cmti"
     1157:   39     :   "_build/install/default/lib/minttea/minttea__Renderer.cmx"
     1158:   40     :   "_build/install/default/lib/minttea/opam"
     1159:   41     :   "_build/install/default/lib/minttea/program.ml"
     1160:   42     :   "_build/install/default/lib/minttea/renderer.ml"
     1161:   43     :   "_build/install/default/lib/minttea/renderer.mli"
     1162:   44     : ]
     1163:   45     : libexec: [
     1164:   46     :   "_build/install/default/lib/minttea/minttea.cmxs"
     1165:   47     : ]
     1166:   48     : doc: [
     1167:   49     :   "_build/install/default/doc/minttea/CHANGES.md"
     1168:   50     :   "_build/install/default/doc/minttea/LICENSE.md"
     1169:   51     :   "_build/install/default/doc/minttea/README.md"
     1170:   52     : ]
     1171: Removed regular file ../minttea/spices.install:
     1172:    1     : lib: [
     1173:    2     :   "_build/install/default/lib/spices/META"
     1174:    3     :   "_build/install/default/lib/spices/border.ml"
     1175:    4     :   "_build/install/default/lib/spices/dune-package"
     1176:    5     :   "_build/install/default/lib/spices/formatter.ml"
     1177:    6     :   "_build/install/default/lib/spices/gradient.ml"
     1178:    7     :   "_build/install/default/lib/spices/opam"
     1179:    8     :   "_build/install/default/lib/spices/spices.a"
     1180:    9     :   "_build/install/default/lib/spices/spices.cma"
     1181:   10     :   "_build/install/default/lib/spices/spices.cmi"
     1182:   11     :   "_build/install/default/lib/spices/spices.cmt"
     1183:   12     :   "_build/install/default/lib/spices/spices.cmti"
     1184:   13     :   "_build/install/default/lib/spices/spices.cmx"
     1185:   14     :   "_build/install/default/lib/spices/spices.cmxa"
     1186:   15     :   "_build/install/default/lib/spices/spices.ml"
     1187:   16     :   "_build/install/default/lib/spices/spices.mli"
     1188:   17     :   "_build/install/default/lib/spices/spices__.cmi"
     1189:   18     :   "_build/install/default/lib/spices/spices__.cmt"
     1190:   19     :   "_build/install/default/lib/spices/spices__.cmx"
     1191:   20     :   "_build/install/default/lib/spices/spices__.ml"
     1192:   21     :   "_build/install/default/lib/spices/spices__Border.cmi"
     1193:   22     :   "_build/install/default/lib/spices/spices__Border.cmt"
     1194:   23     :   "_build/install/default/lib/spices/spices__Border.cmx"
     1195:   24     :   "_build/install/default/lib/spices/spices__Formatter.cmi"
     1196:   25     :   "_build/install/default/lib/spices/spices__Formatter.cmt"
     1197:   26     :   "_build/install/default/lib/spices/spices__Formatter.cmx"
     1198:   27     :   "_build/install/default/lib/spices/spices__Gradient.cmi"
     1199:   28     :   "_build/install/default/lib/spices/spices__Gradient.cmt"
     1200:   29     :   "_build/install/default/lib/spices/spices__Gradient.cmx"
     1201:   30     : ]
     1202:   31     : libexec: [
     1203:   32     :   "_build/install/default/lib/spices/spices.cmxs"
     1204:   33     : ]
     1205:   34     : doc: [
     1206:   35     :   "_build/install/default/doc/spices/CHANGES.md"
     1207:   36     :   "_build/install/default/doc/spices/LICENSE.md"
     1208:   37     :   "_build/install/default/doc/spices/README.md"
     1209:   38     : ]
     1210: Added regular file ../notty/.gitignore:
     1211:         1: _build
     1212:         2: *.install
     1213:         3: *.native
     1214:         4: *.byte
     1215:         5: .merlin
     1216:         6: 
     1217:         7: tmp
     1218:         8: *~
     1219:         9: \.\#*
     1220:        10: \#*#
     1221:        11: 
     1222:        12: *.json
     1223:        13: gmon.out
     1224:        14: rondom
     1225: Added regular file ../notty/.ocamlinit:
     1226:         1: #require "uucp,uuseg,uutf"
     1227:         2: 
     1228:         3: #directory "_build/default/src"
     1229:         4: #directory "_build/default/src/.notty.objs/byte"
     1230:         5: #directory "_build/default/src-unix"
     1231:         6: #directory "_build/default/src-unix/.notty_unix.objs/byte"
     1232:         7: #directory "_build/default/src-lwt"
     1233:         8: #directory "_build/default/src-lwt/.notty_lwt.objs/byte"
     1234:         9: 
     1235:        10: #load "notty.cma"
     1236:        11: #load "notty_unix.cma"
     1237:        12: #load "notty_lwt.cma"
     1238:        13: 
     1239:        14: #use "src/notty_top_init.ml"
     1240: Added regular file ../notty/CHANGES.md:
     1241:         1: ## v0.2.3 (2022-09-02)
     1242:         2: 
     1243:         3: * Moved to Dune.
     1244:         4: * Renders faster, uses less memory.
     1245:         5: * Nested uses of `I.pp_attr` within `I.strf` now stack, instead of replacing.
     1246:         6: * Removed dependency on Uucp. Uses internal data instead (Unicode 13).
     1247:         7: * Support OCaml 4.08 - 4.14. Thanks to @kit-ty-kate for the 4.14 fixes.
     1248:         8: 
     1249:         9: ## v0.2.2 (2019-02-19)
     1250:        10: 
     1251:        11: * Fix a long-standing terminal cleanup bug. Reported by @ttamttam, fix by @cfcs.
     1252:        12: 
     1253:        13: ## v0.2.1 (2017-11-06)
     1254:        14: 
     1255:        15: * OCaml 4.06 compatible.
     1256:        16: * Cache the internal representation of Unicode strings.
     1257:        17: * Remove `I.ichar`. **breaking**
     1258:        18: 
     1259:        19: ## v0.2.0 (2017-10-31)
     1260:        20: 
     1261:        21: * All-around speed and memory improvements.
     1262:        22: * Draw over lines cell-by-cell instead of using erase-and-skip.
     1263:        23:   Slower, but flicker-free drawing.
     1264:        24: * `Term.create`: optionally inhibit synthetic TTY signals.
     1265:        25: * Cursor origin moved from `(1, 1)` to `(0, 0)`. **breaking**
     1266:        26: * `#key` renamed to `#special`. **breaking**
     1267:        27: * Added `Term.fds` to get connected file descriptors.
     1268:        28: * Added `A.equal` and `I.equal`.
     1269:        29: * Switched over to `Uchar.t`. **breaking**
     1270:        30: * Separated ASCII from the rest of Unicode input. **breaking**
     1271:        31: * Added image pretty-printer `I.pp`.
     1272:        32: * Added `notty.top` for use in the toplevel.
     1273:        33: * Removed `I.tile`. **breaking**
     1274:        34: * Added `I.tabulate`, generalizing `I.tile`.
     1275:        35: * Added support for 24-bit color.
     1276:        36: * Added `Notty_*.show_cursor` and `Notty_*.move_cursor` for manual cursor
     1277:        37:   positioning in inline mode.
     1278:        38: * Removed `output_image_endline`. Can be replaced by `eol`. **breaking**
     1279:        39: * `Notty_*.output_image` lost the `~clear` parameter. Can be replaced in various
     1280:        40:   ways by cursor positioning.
     1281:        41: * `Notty_unix.output_image ~chan` renamed to `~fd`. **breaking**
     1282:        42: * Added support for bracketed paste.
     1283:        43: * More example programs.
     1284:        44: 
     1285:        45: ## v0.1.1 (2016-02-09)
     1286:        46: * `Term.input` -> `Term.event`
     1287:        47: * Option to redraw the line
     1288:        48: 
     1289:        49: ## v0.1.0 (2016-02-09)
     1290:        50: * Initial release
     1291: Added regular file ../notty/LICENSE.md:
     1292:         1: Copyright (c) 2016-2017 David Kaloper Meršinjak
     1293:         2: 
     1294:         3: Permission to use, copy, modify, and/or distribute this software for any
     1295:         4: purpose with or without fee is hereby granted, provided that the above
     1296:         5: copyright notice and this permission notice appear in all copies.
     1297:         6: 
     1298:         7: THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
     1299:         8: WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
     1300:         9: MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
     1301:        10: ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
     1302:        11: WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
     1303:        12: ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
     1304:        13: OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
     1305: Added regular file ../notty/README.md:
     1306:         1: # Notty — Declaring terminals
     1307:         2: 
     1308:         3: <a href="https://asciinema.org/a/ZIXzn2ZmIxK39qoT3eJla5OyO" alt="dumper"><img src="https://asciinema.org/a/ZIXzn2ZmIxK39qoT3eJla5OyO.png" width="400"/></a>
     1309:         4: <a href="https://asciinema.org/a/TsIhDJv5S00AB2biVmhHRzZ8I" alt="input"><img src="https://asciinema.org/a/TsIhDJv5S00AB2biVmhHRzZ8I.png" width="400"/></a>
     1310:         5: <a href="https://asciinema.org/a/z1Pc0Mppg2JFzteZzdeigLwYc" alt="microdots"><img src="https://asciinema.org/a/z1Pc0Mppg2JFzteZzdeigLwYc.png" width="400"/></a>
     1311:         6: <a href="https://asciinema.org/a/NgpF9Im8qfUICC39GDDAe9Ede" alt="rain"><img src="https://asciinema.org/a/R94gnHTQhCFJAsWpRfVlZWcUB.png" width="400"/></a>
     1312:         7: 
     1313:         8: Notty is a declarative terminal library for OCaml structured around a notion
     1314:         9: of composable images. It tries to abstract away the basic terminal programming
     1315:        10: model, providing something simpler and more expressive.
     1316:        11: 
     1317:        12: The core layout engine and IO codecs are pure platform-independent OCaml.
     1318:        13: Distribution includes modules with input and output facilities for Unix, and Lwt
     1319:        14: on Unix.
     1320:        15: 
     1321:        16: As an attempt to redefine terminal programming, Notty has to be
     1322:        17: _opinionated_. It assumes Unicode throughout, does not have universal support
     1323:        18: for various terminals out there, and has a peculiar programming and rendering
     1324:        19: model.
     1325:        20: 
     1326:        21: Notty's core API was heavily influenced by Haskell's [Vty][vty].
     1327:        22: 
     1328:        23: ## Where to start
     1329:        24: 
     1330:        25: Check out the [documentation], [examples], or peek directly into the [interface]
     1331:        26: file.
     1332:        27: 
     1333:        28: Building with `dune build @ex` will produce several little example programs that
     1334:        29: also double as tests.
     1335:        30: 
     1336:        31: ```OCaml
     1337:        32: (* Game of Life with ZX Spectrum kitsch. *)
     1338:        33: 
     1339:        34: let dot : image = I.uchar A.(fg lightred) (Uchar.of_int 0x25cf) 1 1
     1340:        35: 
     1341:        36: let background step (n, m) =
     1342:        37:   let k = 24. *. sin (float (step + m + n) /. 10.) |> truncate in
     1343:        38:   if k > 0 then I.char A.(fg (gray k)) '.' 1 1 else I.void 1 1
     1344:        39: 
     1345:        40: let render (w, h) step life : image =
     1346:        41:   I.tabulate w (h - 1) @@ fun x y ->
     1347:        42:     let pt = (x, y) in
     1348:        43:     if CSet.mem pt life then dot else background step pt
     1349:        44: ```
     1350:        45: 
     1351:        46: [documentation]: https://pqwy.github.io/notty/doc
     1352:        47: [examples]: http://pqwy.github.io/notty/doc/Notty.html#examples
     1353:        48: [interface]: https://github.com/pqwy/notty/blob/master/src/notty.mli
     1354:        49: [vty]: https://hackage.haskell.org/package/vty
     1355:        50: 
     1356:        51: ## What?
     1357:        52: 
     1358:        53: - _Notty?_
     1359:        54:   
     1360:        55:   Terminals are tedious to program for. Notty tries to abstract the tedium away,
     1361:        56:   leaving you with a more pleasant programming surface that's quite unlike a TTY.
     1362:        57:   Hence, _No-TTY_.
     1363:        58: 
     1364:        59: - A new kind of Rust terminal?
     1365:        60: 
     1366:        61:   This Notty has no connection to any other body of code named Notty.
     1367:        62: 
     1368:        63: - Why make yet another terminal output library?
     1369:        64:   
     1370:        65:   Because:
     1371:        66:   * It allows one to *describe* what should be seen, as opposed to *commanding*
     1372:        67:     a terminal.
     1373:        68:   * It's pretty compact. Both bells and whistles can be implemented separately.
     1374:        69:   * Core is easy to glue onto various IO backends.
     1375:        70:   * Pure platform-independent OCaml.
     1376: Added regular file ../notty/benchmarks/dune:
     1377:         1: (executable
     1378:         2:   (name speed)
     1379:         3:   (libraries notty notty.unix common unmark unmark.cli))
     1380: Added regular file ../notty/benchmarks/speed.ml:
     1381:         1: (* Copyright (c) 2016-2019 David Kaloper Meršinjak. All rights reserved.
     1382:         2:    See LICENSE.md. *)
     1383:         3: 
     1384:         4: open Notty
     1385:         5: open Common
     1386:         6: open Common.Images
     1387:         7: 
     1388:         8: 
     1389:         9: let decode ?(n=1) str =
     1390:        10:   let f cs _ = function `Uchar c -> c::cs | _ -> cs in
     1391:        11:   let us = str |> Uutf.String.fold_utf_8 f [] |> List.rev in
     1392:        12:   for _ = 1 to n do Unescape.decode us |> ignore done
     1393:        13: 
     1394:        14: let input ?(n=1) str =
     1395:        15:   let buf = Bytes.unsafe_of_string str in
     1396:        16:   let rec go f n = match Unescape.next f with
     1397:        17:     | #Unescape.event -> go f n
     1398:        18:     | `Await when n > 0 ->
     1399:        19:         Unescape.input f buf 0 (Bytes.length buf); go f (pred n)
     1400:        20:     | `Await -> ()
     1401:        21:     | `End   -> assert false in
     1402:        22:   go (Unescape.create ()) n
     1403:        23: 
     1404:        24: let escapes =
     1405:        25:   "\027[5~\027[6~\027[1~\027[4~\027OP\027OQ\027OR\027OS\027[15~\027[17~" ^
     1406:        26:   "\027[18~\027[19~\027[20~\027[21~\027[23~\027[24~"
     1407:        27: 
     1408:        28: let escapes_m =
     1409:        29:   "\027[<0;59;7M\027[<32;58;7M\027[<32;57;7M\027[<32;56;7M\027[<32;54;7M" ^
     1410:        30:   "\027[<32;53;8M\027[<32;52;8M\027[<32;51;8M\027[<32;50;8M\027[<32;49;8M" ^
     1411:        31:   "\027[<32;47;9M\027[<32;46;9M\027[<32;44;9M\027[<32;42;10M\027[<32;41;10M" ^
     1412:        32:   "\027[<32;41;11M\027[<32;40;11M\027[<32;41;12M\027[<32;42;12M" ^
     1413:        33:   "\027[<32;42;13M\027[<32;43;13M\027[<32;44;13M\027[<0;44;13m"
     1414:        34: 
     1415:        35: let chars = String.(make (length escapes) 'x')
     1416:        36: 
     1417:        37: let buf = Buffer.create 1024
     1418:        38: let buf_render off dim image =
     1419:        39:   Buffer.clear buf; Render.to_buffer buf Cap.ansi off dim image
     1420:        40: 
     1421:        41: 
     1422:        42: open Unmark
     1423:        43: 
     1424:        44: let strf = Format.asprintf
     1425:        45: let group_of name xs f = group name (List.map f xs)
     1426:        46: let bench_fmt fmt = Format.kasprintf bench fmt
     1427:        47: let group_fmt fmt = Format.kasprintf group fmt
     1428:        48: 
     1429:        49: let render =
     1430:        50: 
     1431:        51:   let clip i = I.(width i |> min 200, height i |> min 200) in
     1432:        52:   let ops i = Operation.of_image (0, 0) (clip i) i
     1433:        53:   and render i = buf_render (0, 0) (clip i) i in
     1434:        54: 
     1435:        55:   group "render" [
     1436:        56:     group "rasterize" [
     1437:        57:       bench "i2" (fun () -> ops i2)
     1438:        58:     ; bench "i3" (fun () -> ops i3)
     1439:        59:     ; bench "i4" (fun () -> ops i4)
     1440:        60:     ; bench "i5" (fun () -> ops i5)
     1441:        61:     ];
     1442:        62:     group "render" [
     1443:        63:       bench "i2" (fun () -> render i2)
     1444:        64:     ; bench "i3" (fun () -> render i3)
     1445:        65:     ; bench "i4" (fun () -> render i4)
     1446:        66:     ; bench "i5" (fun () -> render i5)
     1447:        67:     ];
     1448:        68:     group_f "draw" (fun t -> [
     1449:        69:       bench "i3" (fun () -> Term.image t i3)
     1450:        70:     ; bench "i5" (fun () -> Term.image t i5)
     1451:        71:     ]) ~init:Term.create ~fini:Term.release
     1452:        72: ]
     1453:        73: 
     1454:        74: let input = group "input" [
     1455:        75:   group "decode" [
     1456:        76:     bench "escapes"     (fun () -> decode ~n:100 escapes);
     1457:        77:     bench "CSI escapes" (fun () -> decode ~n:100 escapes_m);
     1458:        78:     bench "chars"       (fun () -> decode ~n:100 chars);
     1459:        79:   ];
     1460:        80:   group "input" [
     1461:        81:     bench "escapes"     (fun () -> input ~n:100 escapes);
     1462:        82:     bench "CSI escapes" (fun () -> input ~n:100 escapes_m);
     1463:        83:     bench "chars"       (fun () -> input ~n:100 chars);
     1464:        84:   ]
     1465:        85: ]
     1466:        86: 
     1467:        87: let construct =
     1468:        88: 
     1469:        89:   let strings = [
     1470:        90:       "s1", "a"
     1471:        91:     ; "s2", "abcdefghij"
     1472:        92:     ; "s3", String.repeat 10 "abcdefghij"
     1473:        93:     ; "s4", String.repeat 100 "abcdefghij"
     1474:        94:     ; "u1", "☭"
     1475:        95:     ; "u2", String.repeat 10 "☭"
     1476:        96:     ; "u3", String.repeat 100 "☭"
     1477:        97:     ; "u4", String.repeat 1000 "☭" ] in
     1478:        98: 
     1479:        99:   group "construct" [
     1480:       100: 
     1481:       101:     group "make" (strings |> List.map @@ fun (n, s) ->
     1482:       102:       bench n (fun () -> I.string A.empty s))
     1483:       103: 
     1484:       104:   ; group "repeat" ([0x40; 0x262d] |> List.map @@ fun x ->
     1485:       105:       let u = Uchar.of_int x in
     1486:       106:       group_fmt "U+%04x" x ([1; 10; 100] |> List.map @@ fun n ->
     1487:       107:         bench_fmt "%dx" n (fun () -> I.uchar A.empty u n 1)))
     1488:       108: 
     1489:       109:   ; bench "pxmatrix" (fun () -> pxmatrix 200 200 @@ fun _ _ -> A.black)
     1490:       110:   ]
     1491:       111: 
     1492:       112: 
     1493:       113: let _ = Unmark_cli.main "Notty" [ render; input; construct ]
     1494: Added regular file ../notty/dune-project:
     1495:         1: (lang dune 1.7)
     1496:         2: (name notty)
     1497:         3: (version %%VERSION_NUM%%)
     1498: Added regular file ../notty/examples/almondbread.ml:
     1499:         1: open Notty
     1500:         2: open Common
     1501:         3: 
     1502:         4: let iter = 200
     1503:         5: 
     1504:         6: let member x y =
     1505:         7:   let rec go cx cy x y n =
     1506:         8:     let xx = x *. x and yy = y *. y in
     1507:         9:     if n = 0 || xx +. yy > 4. then n else
     1508:        10:       go cx cy (xx -. yy +. cx) (2. *. x *. y +. cy) (n - 1) in
     1509:        11:   float (iter - go x y 0. 0. iter) /. float iter
     1510:        12: 
     1511:        13: let pi2   = 2. *. 3.14159
     1512:        14: let pi2_3 = pi2 /. 3.
     1513:        15: 
     1514:        16: let mandelbrot x y =
     1515:        17:   (* let esc = 1. -. member x y in *)
     1516:        18:   (* 23. *. esc *. esc |> truncate |> A.gray *)
     1517:        19:   match member x y with
     1518:        20:   | 1.  -> A.gray 0
     1519:        21:   | esc ->
     1520:        22:       let t = esc *. pi2 in
     1521:        23:       let f d = (sin (t +. d) *. 128. +. 128.) |> truncate in
     1522:        24:       A.rgb_888 ~b:(f (-.pi2_3)) ~g:(f 0.) ~r:(f pi2_3)
     1523:        25: 
     1524:        26: let xlate dx dy f x y = f (x -. dx) (y -. dy)
     1525:        27: let scale k f = let k1 = 1./.k in fun x y -> f (x *. k1) (y *. k1)
     1526:        28: let rot a f =
     1527:        29:   let sina = sin a and cosa = cos a in fun x y ->
     1528:        30:     f (x *. cosa -. y *. sina) (x *. sina +. cosa *. y)
     1529:        31: 
     1530:        32: let render_unit f (w, h) =
     1531:        33:   let sw = 1. /. float w
     1532:        34:   and sh = 1. /. float (2 * h) in
     1533:        35:   pxmatrix w h (fun x y -> f (float x *. sw) (float y *. sh))
     1534:        36: 
     1535:        37: let () =
     1536:        38:   let pix =
     1537:        39:     render_unit @@
     1538:        40:     rot (-1.570795) @@ xlate (1.6) (-0.5) @@
     1539:        41:     mandelbrot in
     1540:        42:   Notty_unix.(output_image_size @@ fun (w, h) -> pix (w, h - 1) |> eol)
     1541: Added regular file ../notty/examples/colors.ml:
     1542:         1: (* Copyright (c) 2016-2017 David Kaloper Meršinjak. All rights reserved.
     1543:         2:    See LICENSE.md. *)
     1544:         3: 
     1545:         4: (**
     1546:         5:  * Demonstrates text attributes.
     1547:         6:  *)
     1548:         7: open Notty
     1549:         8: open Common
     1550:         9: 
     1551:        10: let colors = A.[
     1552:        11:   "black"        , black
     1553:        12: ; "red"          , red
     1554:        13: ; "green"        , green
     1555:        14: ; "yellow"       , yellow
     1556:        15: ; "blue"         , blue
     1557:        16: ; "magenta"      , magenta
     1558:        17: ; "cyan"         , cyan
     1559:        18: ; "white"        , white
     1560:        19: ; "lightblack"   , lightblack
     1561:        20: ; "lightred"     , lightred
     1562:        21: ; "lightgreen"   , lightgreen
     1563:        22: ; "lightyellow"  , lightyellow
     1564:        23: ; "lightblue"    , lightblue
     1565:        24: ; "lightmagenta" , lightmagenta
     1566:        25: ; "lightcyan"    , lightcyan
     1567:        26: ; "lightwhite"   , lightwhite
     1568:        27: ]
     1569:        28: 
     1570:        29: let styles = A.[
     1571:        30:   "empty"      , empty
     1572:        31: ; "bold"       , st bold
     1573:        32: ; "italic"     , st italic
     1574:        33: ; "underline"  , st underline
     1575:        34: ; "blink"      , st blink
     1576:        35: ; "reverse"    , st reverse
     1577:        36: ; "bold/italic", st bold ++ st italic
     1578:        37: ; "rev/underln", st underline ++ st reverse
     1579:        38: ; "bold/rev"   , st reverse ++ st bold
     1580:        39: ]
     1581:        40: 
     1582:        41: let image w =
     1583:        42:   let open List in
     1584:        43:   let core16 =
     1585:        44:     let c1  = map (fun (n, c) -> I.string A.(fg c) n) colors
     1586:        45:     and c2  = map (fun (n, c) -> I.string A.(fg black ++ bg c) n) colors
     1587:        46:     in I.(vcat c1 <|> void 1 0 <|> vcat c2)
     1588:        47:   and attr =
     1589:        48:     I.( styles |> map (fun (n, s) -> hpad 0 1 (string s n)) |> hcat) in
     1590:        49:   let combine imgs =
     1591:        50:     List.map I.(fun (n, i) -> string A.empty n <-> i <-> void 0 1) imgs
     1592:        51:     |> I.vcat |> I.pad ~l:1 ~t:1 in
     1593:        52:   combine [
     1594:        53:     "System colors:",     core16;
     1595:        54:     "Color cube, 6x6x6:", Images.c_cube_ix;
     1596:        55:     "Grayscale ramp:",    Images.c_gray_ramp;
     1597:        56:     "24bit:",             Images.c_rainbow (w - 2) 1;
     1598:        57:     "Text styles:",       attr
     1599:        58:   ]
     1600:        59: 
     1601:        60: let () = Notty_unix.output_image_size @@ fun (w, _) -> image w
     1602: Added regular file ../notty/examples/common.ml:
     1603:         1: (* Copyright (c) 2016-2017 David Kaloper Meršinjak. All rights reserved.
     1604:         2:    See LICENSE.md. *)
     1605:         3: 
     1606:         4: open Notty
     1607:         5: open Notty.Infix
     1608:         6: 
     1609:         7: let pow n e = int_of_float (float n ** float e)
     1610:         8: 
     1611:         9: module List = struct
     1612:        10: 
     1613:        11:   include List
     1614:        12: 
     1615:        13:   let rec replicate n a = if n < 1 then [] else a :: replicate (n - 1) a
     1616:        14: 
     1617:        15:   let rec range a b = if a > b then [] else a :: range (a + 1) b
     1618:        16: 
     1619:        17:   let rec intersperse a = function
     1620:        18:     | [] | [_] as t -> t
     1621:        19:     | x::xs         -> x :: a :: intersperse a xs
     1622:        20: 
     1623:        21:   let rec take n = function
     1624:        22:     | x::xs when n > 0 -> x :: take (pred n) xs
     1625:        23:     | _ -> []
     1626:        24: 
     1627:        25:   let rec splitat n = function
     1628:        26:     | x::xs when n > 0 ->
     1629:        27:         let (a, b) = splitat (pred n) xs in (x::a, b)
     1630:        28:     | xs -> ([], xs)
     1631:        29: 
     1632:        30:   let rec chunks n xs =
     1633:        31:     match splitat n xs with
     1634:        32:     | (a, []) -> [a]
     1635:        33:     | (a, b)  -> a :: chunks n b
     1636:        34: 
     1637:        35:   let rec zip xs ys = match (xs, ys) with
     1638:        36:     | ([], _) | (_, []) -> []
     1639:        37:     | (x::xs, y::ys) -> (x, y) :: zip xs ys
     1640:        38: 
     1641:        39: end
     1642:        40: 
     1643:        41: module String = struct
     1644:        42: 
     1645:        43:   include String
     1646:        44: 
     1647:        45:   let repeat n str =
     1648:        46:     let b = Buffer.create 16 in
     1649:        47:     for _ = 1 to n do Buffer.add_string b str done;
     1650:        48:     Buffer.contents b
     1651:        49: end
     1652:        50: 
     1653:        51: let tile w h i = I.tabulate w h (fun _ _ -> i)
     1654:        52: 
     1655:        53: (** A few images used in several places. *)
     1656:        54: module Images = struct
     1657:        55: 
     1658:        56:   let i1 =
     1659:        57:     I.(string A.(fg lightblack) "omgbbq" <->
     1660:        58:        string A.(fg white ++ bg red) "@")
     1661:        59:     <|> I.(pad ~t:2 @@ string A.(fg green) "xo")
     1662:        60: 
     1663:        61:   let i2 = I.(hpad 1 1 (hcrop 1 1 @@ tile 3 3 i1) <|> i1)
     1664:        62: 
     1665:        63:   let i3 = tile 5 5 i2
     1666:        64: 
     1667:        65:   let i4 =
     1668:        66:     let i = I.(i3 <|> crop ~t:1 i3 <|> i3) in
     1669:        67:     I.(crop ~l:1 i <-> crop ~r:1 i <-> crop ~b:2 i)
     1670:        68: 
     1671:        69:   let i5 =
     1672:        70:     tile 5 1 List.(
     1673:        71:       range 0 15 |> map (fun i -> I.pad ~t:i ~l:(i*2) i2) |> I.zcat
     1674:        72:     )
     1675:        73: 
     1676:        74:   let c_gray_ramp =
     1677:        75:     I.tabulate 24 1 (fun g _ -> I.string A.(bg (gray g)) " ")
     1678:        76: 
     1679:        77:   let c_cube_ix =
     1680:        78:     I.tabulate 6 1 @@ fun r _ ->
     1681:        79:       I.hpad 0 1 @@ I.tabulate 6 6 @@ fun b g ->
     1682:        80:         I.string A.(bg (rgb ~r ~g ~b)) " "
     1683:        81: 
     1684:        82:   let c_cube_rgb =
     1685:        83:     let f x = [| 0x00; 0x5f; 0x87; 0xaf; 0xd7; 0xff |].(x) in
     1686:        84:     I.tabulate 6 1 @@ fun r _ ->
     1687:        85:       I.hpad 0 1 @@ I.tabulate 6 6 @@ fun b g ->
     1688:        86:         I.string A.(bg (rgb_888 ~r:(f r) ~g:(f g) ~b:(f b))) " "
     1689:        87: 
     1690:        88:   let c_rainbow w h =
     1691:        89:     let pi2     = 2. *. 3.14159 in
     1692:        90:     let pi2_3   = pi2 /. 3.
     1693:        91:     and f t off = sin (t +. off) *. 128. +. 128. |> truncate in
     1694:        92:     let color t = A.rgb_888 ~r:(f t (-.pi2_3)) ~g:(f t 0.) ~b:(f t pi2_3) in
     1695:        93:     I.tabulate (w - 1) 1 @@ fun x _ ->
     1696:        94:       let t = (pi2 *. float x /. float w) +. 3.7 in
     1697:        95:       I.char A.(bg (color t)) ' ' 1 h
     1698:        96: 
     1699:        97:   (* U+25CF BLACK CIRCLE *)
     1700:        98:   let dot color = I.string (A.fg color) "●"
     1701:        99:   (* U+25AA BLACK SMALL SQUARE *)
     1702:       100:   let square color = I.string (A.fg color) "▪"
     1703:       101: 
     1704:       102:   let rec cantor = function
     1705:       103:     | 0 -> square A.lightblue
     1706:       104:     | n ->
     1707:       105:         let sub = cantor (pred n) in
     1708:       106:         I.hcat (List.replicate (pow 3 n) (square A.lightblue)) <->
     1709:       107:         (sub <|> I.void (pow 3 (n - 1)) 0 <|> sub)
     1710:       108: 
     1711:       109:   let checker n m i =
     1712:       110:     let w = I.width i in
     1713:       111:     I.(tile (n/2) (m/2) (hpad 0 w i <-> hpad w 0 i))
     1714:       112: 
     1715:       113:   let checker1 = checker 20 20 I.(char A.(bg magenta) ' ' 2 1)
     1716:       114: 
     1717:       115:   let rec sierp c n = I.(
     1718:       116:     if n > 1 then
     1719:       117:       let ss = sierp c (pred n) in ss <-> (ss <|> ss)
     1720:       118:     else hpad 1 0 (square c)
     1721:       119:   )
     1722:       120: 
     1723:       121:   let grid xxs = xxs |> List.map I.hcat |> I.vcat
     1724:       122: 
     1725:       123:   let outline attr i =
     1726:       124:     let (w, h) = I.(width i, height i) in
     1727:       125:     let chr x = I.uchar attr (Uchar.of_int x) 1 1
     1728:       126:     and hbar  = I.uchar attr (Uchar.of_int 0x2500) w 1
     1729:       127:     and vbar  = I.uchar attr (Uchar.of_int 0x2502) 1 h in
     1730:       128:     let (a, b, c, d) = (chr 0x256d, chr 0x256e, chr 0x256f, chr 0x2570) in
     1731:       129:     grid [ [a; hbar; b]; [vbar; i; vbar]; [d; hbar; c] ]
     1732:       130: end
     1733:       131: 
     1734:       132: let halfblock = "▄"
     1735:       133: 
     1736:       134: let pxmatrix w h f = I.tabulate w h @@ fun x y ->
     1737:       135:   let y = y * 2 in
     1738:       136:   I.string A.(bg (f x y) ++ fg (f x (y + 1))) halfblock
     1739:       137: 
     1740:       138: module Term = Notty_unix.Term
     1741:       139: 
     1742:       140: let simpleterm ~imgf ~f ~s =
     1743:       141:   let term = Term.create () in
     1744:       142:   let imgf (w, h) s =
     1745:       143:     I.(string A.(fg lightblack) "[ESC quits.]" <-> imgf (w, h - 1) s) in
     1746:       144:   let rec go s =
     1747:       145:     Term.image term (imgf (Term.size term) s);
     1748:       146:     match Term.event term with
     1749:       147:     | `End | `Key (`Escape, []) | `Key (`ASCII 'C', [`Ctrl]) -> ()
     1750:       148:     | `Resize _ -> go s
     1751:       149:     | #Unescape.event as e ->
     1752:       150:         match f s e with Some s -> go s | _ -> ()
     1753:       151:   in go s
     1754: Added regular file ../notty/examples/common_lwt.ml:
     1755:         1: (* Copyright (c) 2016-2017 David Kaloper Meršinjak. All rights reserved.
     1756:         2:    See LICENSE.md. *)
     1757:         3: 
     1758:         4: open Notty
     1759:         5: open Lwt.Infix
     1760:         6: 
     1761:         7: include Common
     1762:         8: 
     1763:         9: module T = Notty_lwt.Term
     1764:        10: 
     1765:        11: let simpleterm_lwt ~imgf ~f ~s =
     1766:        12:   let term = T.create () in
     1767:        13:   let imgf (w, h) s =
     1768:        14:     I.(string A.(fg lightblack) "[ESC quits.]" <-> imgf (w, h - 1) s) in
     1769:        15:   let step e s = match e with
     1770:        16:     | `Key (`Escape, []) | `Key (`ASCII 'C', [`Ctrl]) ->
     1771:        17:         T.release term >|= fun () -> s
     1772:        18:     | `Resize dim -> T.image term (imgf dim s) >|= fun () -> s
     1773:        19:     | #Unescape.event as e ->
     1774:        20:         match f s e with
     1775:        21:         | Some s -> T.image term (imgf (T.size term) s) >|= fun () -> s
     1776:        22:         | None   -> T.release term >|= fun () -> s
     1777:        23:   in
     1778:        24:   ( T.image term (imgf (T.size term) s)
     1779:        25:     >>= fun () -> Lwt_stream.fold_s step (T.events term) s )
     1780:        26:   |> Lwt_main.run |> ignore
     1781:        27: 
     1782:        28: 
     1783:        29: let timer = function
     1784:        30:   | None   -> Lwt.wait () |> fst
     1785:        31:   | Some t -> Lwt_unix.sleep t >|= fun _ -> `Timer
     1786:        32: 
     1787:        33: let event e = Lwt_stream.get (T.events e) >|= function
     1788:        34:   | Some (`Resize _ | #Unescape.event as x) -> x
     1789:        35:   | None -> `End
     1790:        36: 
     1791:        37: let simpleterm_lwt_timed ?delay ~f s0 =
     1792:        38:   let term = T.create () in
     1793:        39:   let rec loop (e, t) dim s =
     1794:        40:     (e <?> t) >>= function
     1795:        41:     | `End | `Key (`Escape, []) | `Key (`ASCII 'C', [`Ctrl]) ->
     1796:        42:         Lwt.return_unit
     1797:        43:     | `Resize dim as evt     -> invoke (event term, t) dim s evt
     1798:        44:     | #Unescape.event as evt -> invoke (event term, t) dim s evt
     1799:        45:     | `Timer as evt          -> invoke (e, timer delay) dim s evt
     1800:        46:   and invoke es dim s e =
     1801:        47:     match f dim s e with
     1802:        48:     | `Continue s    -> loop es dim s
     1803:        49:     | `Redraw (s, i) -> T.image term i >>= fun () -> loop es dim s
     1804:        50:     | `Stop          -> Lwt.return_unit in
     1805:        51:   let size = T.size term in
     1806:        52:   loop (event term, timer delay) size s0
     1807: Added regular file ../notty/examples/crops.ml:
     1808:         1: (* Copyright (c) 2016-2017 David Kaloper Meršinjak. All rights reserved.
     1809:         2:    See LICENSE.md. *)
     1810:         3: 
     1811:         4: (**
     1812:         5:  * Demonstrates edge-case behavior of functions that produce rectangle-like
     1813:         6:  * things.
     1814:         7:  *)
     1815:         8: open Notty
     1816:         9: open Common
     1817:        10: 
     1818:        11: let hdistribute ?align w imgs =
     1819:        12:   let n = List.length imgs in
     1820:        13:   I.(List.map (hsnap ?align (w / n)) imgs |> hcat)
     1821:        14: 
     1822:        15: let take w h i = I.(vsnap h i |> hsnap w)
     1823:        16: 
     1824:        17: let () =
     1825:        18:   simpleterm ~s:(2, 2)
     1826:        19:     ~f:(fun (w, h as s) -> function
     1827:        20:         `Key (`Arrow `Left, _) -> Some (w - 1, h)
     1828:        21:       | `Key (`Arrow `Right, _) -> Some (w + 1, h)
     1829:        22:       | `Key (`Arrow `Up, _) -> Some (w, h - 1)
     1830:        23:       | `Key (`Arrow `Down, _) -> Some (w, h + 1)
     1831:        24:       | `Key (`ASCII '0', _) -> Some (0, 0)
     1832:        25:       | _ -> Some s)
     1833:        26:     ~imgf:I.(fun (ow, oh) (w, h) ->
     1834:        27:       let (a1, a2, a3) = A.(fg lightmagenta, fg lightred, fg lightblue) in
     1835:        28:       strf "Sizing edge behavior. Dim: (%d, %d)" w h <->
     1836:        29:       ( hdistribute ow Images.[
     1837:        30:           outline a1 (uchar a1 (Uchar.of_int 0x2022) w h)
     1838:        31:         ; outline a2 (uchar a2 (Uchar.of_int 0x2022) 300 300 |> take w h)
     1839:        32:         ; outline a3 (void w h)
     1840:        33:         ] |> vsnap (oh - 4) )
     1841:        34:       <->
     1842:        35:       hdistribute ow [string a1 "char"; string a2 "crop"; string a3 "void"]
     1843:        36:     )
     1844: Added regular file ../notty/examples/cursor.ml:
     1845:         1: (* Copyright (c) 2016-2017 David Kaloper Meršinjak. All rights reserved.
     1846:         2:    See LICENSE.md. *)
     1847:         3: 
     1848:         4: open Notty
     1849:         5: open Common
     1850:         6: 
     1851:         7: let rec main t (x, y as pos) =
     1852:         8:   let img =
     1853:         9:     let dot = I.string A.(bg lightred ++ fg black) "✓" |> I.pad ~l:x ~t:y
     1854:        10:     and txt = I.strf ~attr:A.(fg lightblack) "@(%d, %d)" x y in
     1855:        11:     I.(txt </> dot) in
     1856:        12:   Term.image t img;
     1857:        13:   Term.cursor t (Some pos);
     1858:        14:   match Term.event t with
     1859:        15:   | `End | `Key (`Escape, []) | `Key (`ASCII 'C', [`Ctrl]) -> ()
     1860:        16:   | `Resize _ -> main t pos
     1861:        17:   | `Mouse ((`Press _ | `Drag), pos, _) -> main t pos
     1862:        18:   | `Key (`Arrow d, _) ->
     1863:        19:     ( main t @@ match d with
     1864:        20:       | `Up    -> (x, y - 1)
     1865:        21:       | `Down  -> (x, y + 1)
     1866:        22:       | `Left  -> (x - 1, y)
     1867:        23:       | `Right -> (x + 1, y) )
     1868:        24:   | _ -> main t pos
     1869:        25: 
     1870:        26: let () = main (Term.create ()) (0, 1)
     1871: Added regular file ../notty/examples/cuts.ml:
     1872:         1: (* Copyright (c) 2016-2017 David Kaloper Meršinjak. All rights reserved.
     1873:         2:    See LICENSE.md. *)
     1874:         3: 
     1875:         4: (**
     1876:         5:  * Demonstrates text cropping, particularly of grapheme clusters and wide
     1877:         6:  * characters.
     1878:         7:  *)
     1879:         8: open Notty
     1880:         9: open Notty_unix
     1881:        10: open Common
     1882:        11: 
     1883:        12: let hpadwith attr c a b i =
     1884:        13:   I.(char attr c a 1 <|> i <|> char attr c b 1)
     1885:        14: 
     1886:        15: let cuts i =
     1887:        16:   let w = I.width i in
     1888:        17:   List.(
     1889:        18:     range 0 w |> map (fun a ->
     1890:        19:       range 0 (w - a) |> map (fun b ->
     1891:        20:         i |> I.hcrop a b |> hpadwith A.(fg lightblack) '.' a b
     1892:        21:       ) |> I.vcat |> I.hpad 1 1
     1893:        22:     ) |> I.hcat |> I.vpad 1 1
     1894:        23:   )
     1895:        24: 
     1896:        25: let colors = A.[red; green; yellow; blue; magenta; cyan]
     1897:        26: 
     1898:        27: let patterns = [
     1899:        28:   "desu"
     1900:        29: ; ".▪e\204\129●."
     1901:        30: ; "(茶‸茶‶)"
     1902:        31: ; "(⌐■_■)"
     1903:        32: (* ; "¯\\(ツ)/¯" *)
     1904:        33: (* ; "ಠ_ಠ" *)
     1905:        34: (* ; "ಡ_ಡ" *)
     1906:        35: (* ; "\xe0\xb2\xa0\x5f\xe0\xb1\x83" *)
     1907:        36: (* ; "ತಎತ" *)
     1908:        37: (* ; "ಥ_ಥ" *)
     1909:        38: ; "ᕕ( ᐛ )ᕗ"
     1910:        39: (* ; "ᕙ(⇀‸↼‶)ᕗ" *)
     1911:        40: (* ; "ᕦ(ò_óˇ)ᕤ" *)
     1912:        41: (* ; "(╯ ︵╰ )" *)
     1913:        42: (* ; "\x28\x20\xcd\xa1\xc2\xb0\x20\xcd\x9c\xca\x96\x20\xcd\xa1\xc2\xb0\x29" *)
     1914:        43: ]
     1915:        44: 
     1916:        45: 
     1917:        46: let () =
     1918:        47:   let open I in
     1919:        48: 
     1920:        49:   patterns |> List.map (fun s ->
     1921:        50:     cuts (string A.(fg lightmagenta ++ bg lightblack) s)
     1922:        51:   ) |> I.vcat |> eol |> output_image ;
     1923:        52: 
     1924:        53:   colors |> List.mapi (fun i c ->
     1925:        54:     pad ~l:i ~t:i (
     1926:        55:       string A.(fg black ++ bg c ++ st blink) "茶" <|>
     1927:        56:       pad ~l:2 ~t:1
     1928:        57:         (string A.(fg c ++ st blink) "PARTY!"))
     1929:        58:   ) |> zcat |> pad ~l:2 ~t:2 ~b:2 |> output_image
     1930: Added regular file ../notty/examples/dune:
     1931:         1: (library
     1932:         2:   (name common)
     1933:         3:   (modules common)
     1934:         4:   (libraries notty notty.unix))
     1935:         5: 
     1936:         6: (library
     1937:         7:   (name common_lwt)
     1938:         8:   (modules common_lwt)
     1939:         9:   (libraries common notty.lwt))
     1940:        10: 
     1941:        11: (executables
     1942:        12:   (names testpatterns colors almondbread crops cursor cuts emoji inline keys
     1943:        13:          letters mouse thisbig runes sierpinski rain sierpinski_lwt linear
     1944:        14:          life)
     1945:        15:   (modules testpatterns colors almondbread crops cursor cuts emoji inline keys
     1946:        16:            letters mouse thisbig runes sierpinski rain sierpinski_lwt linear
     1947:        17:            life)
     1948:        18:   (libraries common common_lwt))
     1949:        19: 
     1950:        20: (alias
     1951:        21:   (name ex)
     1952:        22:   (package notty)
     1953:        23:   (deps testpatterns.exe colors.exe almondbread.exe crops.exe cursor.exe
     1954:        24:         cuts.exe emoji.exe inline.exe keys.exe letters.exe mouse.exe
     1955:        25:         thisbig.exe runes.exe sierpinski.exe rain.exe sierpinski_lwt.exe
     1956:        26:         linear.exe life.exe))
     1957: Added regular file ../notty/examples/emoji.ml:
     1958:         1: open Notty
     1959:         2: open Common
     1960:         3: 
     1961:         4: let es = [
     1962:         5:   [0x2e; 0x2e; 0x2e; 0x2e];
     1963:         6:   [0x25aa; 0x25fe; 0x25fc; 0x2b1b];
     1964:         7:   [0x1f346; 0x1f351; 0x1f605; 0x1f4a6];
     1965:         8:   [0x1f62d; 0x1f52a; 0x1f52a; 0x1f47c];
     1966:         9: ]
     1967:        10: 
     1968:        11: let image =
     1969:        12:   es |> List.(map (map @@ fun x ->
     1970:        13:     let i = I.uchar A.(fg lightwhite) (Uchar.of_int x) 1 1 in
     1971:        14:     I.(pad ~r:(3 - width i) i)
     1972:        15:   )) |> Images.grid |> I.pad ~l:1 |> Images.outline A.(fg lightblack)
     1973:        16: 
     1974:        17: let () = Notty_unix.output_image_size @@ fun (w, _) ->
     1975:        18:   I.(pad ~l:((w - width image) / 2) ~b:1 image)
     1976: Added regular file ../notty/examples/inline.ml:
     1977:         1: (* Copyright (c) 2017 David Kaloper Meršinjak. All rights reserved.
     1978:         2:    See LICENSE.md. *)
     1979:         3: 
     1980:         4: (** Demonstrates manual cursor positioning. *)
     1981:         5: 
     1982:         6: open Notty
     1983:         7: open Notty.Infix
     1984:         8: open Notty_unix
     1985:         9: 
     1986:        10: let sleep n = flush stdout; Unix.select [] [] [] n |> ignore
     1987:        11: 
     1988:        12: let pp_str attr = I.pp_attr attr Format.pp_print_string
     1989:        13: 
     1990:        14: let rewind n = move_cursor `Home; move_cursor (`By (0, - (max n 0)))
     1991:        15: 
     1992:        16: let output_subst ~prev i =
     1993:        17:   let h = I.height prev in
     1994:        18:   let d = h - I.height i in
     1995:        19:   if d > 0 then ( rewind (d - 1); output_image (I.void 0 d) );
     1996:        20:   rewind (h - 1); output_image i
     1997:        21: 
     1998:        22: let cmyk = function
     1999:        23:   | 0 -> A.rgb ~r:0 ~g:5 ~b:5
     2000:        24:   | 1 -> A.rgb ~r:5 ~g:0 ~b:5
     2001:        25:   | 2 -> A.rgb ~r:5 ~g:5 ~b:0
     2002:        26:   | 3 -> A.rgb ~r:0 ~g:0 ~b:0
     2003:        27:   | _ -> A.rgb ~r:5 ~g:5 ~b:5
     2004:        28: 
     2005:        29: let () =
     2006:        30: 
     2007:        31:   let (w, h) = match winsize Unix.stdout with
     2008:        32:     Some dim -> dim | _ -> assert false
     2009:        33:   and attr = A.(fg lightwhite ++ bg blue) in
     2010:        34:   let img1 =
     2011:        35:     I.(string attr "THE BLUE STRIPE ABOVE" <->
     2012:        36:          tabulate 1 h (fun _ _ -> I.strf "HIDDEN"))
     2013:        37:   and img2 =
     2014:        38:     I.(strf "Top line. There's a %a above. ^^^"
     2015:        39:          (pp_str attr) "blue stripe" |> vpad 0 2) in
     2016:        40: 
     2017:        41:   output_image img1; output_subst ~prev:img1 img2;
     2018:        42: 
     2019:        43:   output_image I.(string A.(fg white) "[..]" |> eol);
     2020:        44:   for i = 0 to 5 do
     2021:        45:     let a  = A.(bg (rgb ~r:i ~b:(5 - i) ~g:0)) in
     2022:        46:     let bg = I.tabulate 1 i (fun _ -> I.strf "HIDDEN [%d]") |> eol
     2023:        47:     and fg = I.char a ' ' 19 (5 - i) <|> I.char a '-' 1 (5 - i) |> eol in
     2024:        48:     output_image bg; output_subst ~prev:bg fg;
     2025:        49:   done;
     2026:        50:   output_image I.(string A.(fg white) "[..]" |> vpad 0 2);
     2027:        51: 
     2028:        52:   let rec go prev n =
     2029:        53:     if n <= w then
     2030:        54:       let h = log (float n) |> truncate in
     2031:        55:       let i = prev <|> I.tabulate 1 h (fun _ y -> I.char A.(bg (cmyk y)) ' ' 1 1) in
     2032:        56:       output_subst ~prev i; sleep 0.01; go i (n + 1)
     2033:        57:     else output_subst ~prev I.empty in
     2034:        58:   show_cursor false;
     2035:        59:   go I.empty 1;
     2036:        60:   show_cursor true;
     2037:        61: 
     2038:        62:   output_image
     2039:        63:     I.(strf "It doesn't say %a anywhere on screen, either."
     2040:        64:         (pp_attr A.(fg white) Format.pp_print_string) "hidden" |> eol)
     2041:        65: 
     2042: Added regular file ../notty/examples/keys.ml:
     2043:         1: (* Copyright (c) 2016-2017 David Kaloper Meršinjak. All rights reserved.
     2044:         2:    See LICENSE.md. *)
     2045:         3: 
     2046:         4: (**
     2047:         5:  * Demonstrates input parsing.
     2048:         6:  *)
     2049:         7: open Notty
     2050:         8: open Common
     2051:         9: 
     2052:        10: let pps = Format.pp_print_string
     2053:        11: let ppi = Format.pp_print_int
     2054:        12: 
     2055:        13: let pp_special fmt = function
     2056:        14:   | `Escape       -> pps fmt "ESCAPE"
     2057:        15:   | `Enter        -> pps fmt "ENTER"
     2058:        16:   | `Tab          -> pps fmt "TAB"
     2059:        17:   | `Backspace    -> pps fmt "BACKSPACE"
     2060:        18:   | `Arrow `Up    -> pps fmt "UP"
     2061:        19:   | `Arrow `Down  -> pps fmt "DOWN"
     2062:        20:   | `Arrow `Left  -> pps fmt "LEFT"
     2063:        21:   | `Arrow `Right -> pps fmt "RIGHT"
     2064:        22:   | `Page `Up     -> pps fmt "PAGE UP"
     2065:        23:   | `Page `Down   -> pps fmt "PAGE DOWN"
     2066:        24:   | `Home         -> pps fmt "HOME"
     2067:        25:   | `End          -> pps fmt "END"
     2068:        26:   | `Insert       -> pps fmt "INSERT"
     2069:        27:   | `Delete       -> pps fmt "DELETE"
     2070:        28:   | `Function n   -> pps fmt "FN"; ppi fmt n
     2071:        29: 
     2072:        30: let pp_mods fmt = function
     2073:        31:   | [] -> ()
     2074:        32:   | ms -> ms |> List.iter (fun m ->
     2075:        33:       pps fmt @@ match m with `Meta -> "M" | `Ctrl -> "C" | `Shift -> "S"
     2076:        34:     )
     2077:        35: 
     2078:        36: let pp_mouse fmt = function
     2079:        37:   | `Release -> pps fmt "Release"
     2080:        38:   | `Drag    -> pps fmt "Drag"
     2081:        39:   | `Move    -> pps fmt "Move"
     2082:        40:   | `Press k ->
     2083:        41:       pps fmt "Press ";
     2084:        42:       pps fmt @@ match k with
     2085:        43:         | `Left         -> "Left"
     2086:        44:         | `Middle       -> "Middle"
     2087:        45:         | `Right        -> "Right"
     2088:        46:         | `Scroll `Up   -> "Scroll Up"
     2089:        47:         | `Scroll `Down -> "Scroll Down"
     2090:        48: 
     2091:        49: let pp_u ppf u = Format.fprintf ppf "U+%04X" (Uchar.to_int u)
     2092:        50: 
     2093:        51: let () =
     2094:        52:   let magenta = A.(fg lightmagenta ++ bg black)
     2095:        53:   and green   = A.(fg lightgreen   ++ bg black)
     2096:        54:   and blue    = A.(fg lightblue    ++ bg black) in
     2097:        55:   let pp_mods  = I.pp_attr green pp_mods
     2098:        56:   and pp_mouse = I.pp_attr blue pp_mouse in
     2099:        57:   simpleterm ~s:[]
     2100:        58:     ~f:(fun xs x -> Some (List.take 100 (x::xs)))
     2101:        59:     ~imgf:(fun (_, h) xs ->
     2102:        60:       let attr = magenta in
     2103:        61:       let msg = I.string A.empty "Push keys."
     2104:        62:       and ks = List.map (function
     2105:        63:         | `Key ((`ASCII _ | `Uchar _) as c, mods) ->
     2106:        64:             let u = Unescape.uchar c in
     2107:        65:             I.(uchar blue u 1 1 <|> strf ~attr " %a %a" pp_u u pp_mods mods)
     2108:        66:         | `Key (#Unescape.special as k, mods) ->
     2109:        67:             I.strf ~attr "%a %a" pp_special k pp_mods mods
     2110:        68:         | `Mouse (e, (x, y), mods) ->
     2111:        69:             I.strf ~attr "MOUSE %a (%d, %d) %a" pp_mouse e x y pp_mods mods
     2112:        70:         | `Paste e ->
     2113:        71:             I.strf ~attr "PASTE %s" (if e = `Start then "START" else "END")
     2114:        72:         ) xs |> I.vcat in
     2115:        73:       I.(vsnap ~align:`Top (h - 3) ks <-> void 0 1 <-> msg |> pad ~l:1 ~t:1))
     2116: Added regular file ../notty/examples/letters.ml:
     2117:         1: (* Copyright (c) 2016-2017 David Kaloper Meršinjak. All rights reserved.
     2118:         2:    See LICENSE.md. *)
     2119:         3: 
     2120:         4: (**
     2121:         5:  * Dancing letters.
     2122:         6:  *)
     2123:         7: open Notty
     2124:         8: open Common
     2125:         9: 
     2126:        10: let nw = 6
     2127:        11: and nh = 5
     2128:        12: 
     2129:        13: let () =
     2130:        14:   simpleterm ~s:[]
     2131:        15:     ~f:(fun us -> function
     2132:        16:       | `Key ((`Delete|`Backspace), _) ->
     2133:        17:           Some (match us with _::xs -> xs | _ -> us)
     2134:        18:       | `Key ((`ASCII _|`Uchar _ as u), _) ->
     2135:        19:           Some (List.take (nw * nh) (Unescape.uchar u :: us))
     2136:        20:       | _  -> Some us)
     2137:        21:     ~imgf:(fun _ us ->
     2138:        22:       let open List in
     2139:        23:       let uus = chunks nw (rev us) in
     2140:        24:       mapi (fun i us ->
     2141:        25:         mapi (fun j u ->
     2142:        26:           I.uchar A.(fg white ++ bg (rgb ~r:0 ~g:i ~b:j)) u 1 1
     2143:        27:         ) us |> I.hcat
     2144:        28:       ) uus |> I.vcat
     2145:        29:       |> I.pad ~t:1 ~l:1
     2146:        30:       |> I.hsnap ~align:`Left (nw + 1)
     2147:        31:       |> tile nw 1)
     2148: Added regular file ../notty/examples/life.ml:
     2149:         1: (* Copyright (c) 2016-2017 David Kaloper Meršinjak. All rights reserved.
     2150:         2:    See LICENSE.md. *)
     2151:         3: 
     2152:         4: (*
     2153:         5:  * Game of Life with some ZX spectrum kitsch.
     2154:         6:  *)
     2155:         7: 
     2156:         8: let flip f a b = f b a
     2157:         9: 
     2158:        10: (** Live, **)
     2159:        11: 
     2160:        12: module Coord = struct
     2161:        13:   type t = int * int
     2162:        14:   let compare ((a, b) : t) (c, d) =
     2163:        15:     match compare a c with 0 -> compare b d | r -> r
     2164:        16:   let equal ((a, b) : t) (c, d) = a = c && b = d
     2165:        17: end
     2166:        18: 
     2167:        19: module CSet = struct
     2168:        20:   include Set.Make (Coord)
     2169:        21:   let of_list = List.fold_left (flip add) empty
     2170:        22:   let map f s = fold (fun x s -> add (f x) s) s empty
     2171:        23: end
     2172:        24: 
     2173:        25: module CMap = struct
     2174:        26:   include Map.Make (Coord)
     2175:        27:   let preimg p m =
     2176:        28:     fold (fun k v s -> if p v then CSet.add k s else s) m CSet.empty
     2177:        29: end
     2178:        30: 
     2179:        31: let erem x y = (x mod y + y) mod y
     2180:        32: let square (w, h) (a, b as ab) =
     2181:        33:   if a < 0 || a >= w || b < 0 || b >= h then (-1, -1) else ab
     2182:        34: let torus (w, h) (a, b) = (erem a w, erem b h)
     2183:        35: let moebius (w, h) (a, b as ab) =
     2184:        36:   if a < 0 || a >= w then (erem a w, h - b - 1) else ab
     2185:        37: 
     2186:        38: let neigh topo (a, b) = [
     2187:        39:   (a-1, b); (a+1, b); (a-1, b-1); (a-1, b+1)
     2188:        40: ; (a, b-1); (a, b+1); (a+1, b-1); (a+1, b+1)
     2189:        41: ] |> List.map topo
     2190:        42: 
     2191:        43: let step topo life =
     2192:        44:   let nlive pt =
     2193:        45:     List.(neigh topo pt |> filter (flip CSet.mem life) |> length) in
     2194:        46:   let f1 pt acc =
     2195:        47:     pt :: neigh topo pt |> List.fold_left (fun acc -> function
     2196:        48:       | (-1, -1) -> acc
     2197:        49:       | pt when CMap.mem pt acc -> acc
     2198:        50:       | pt ->
     2199:        51:           let n = nlive pt in
     2200:        52:           acc |> CMap.add pt
     2201:        53:             (if n = 3 || (n = 2 && CSet.mem pt life) then 0 else 1)
     2202:        54:     ) acc in
     2203:        55:   CSet.fold f1 life CMap.empty |> CMap.preimg ((=) 0)
     2204:        56: 
     2205:        57: let glider = CSet.of_list [(2,1); (3,2); (1,3); (2,3); (3,3)]
     2206:        58: 
     2207:        59: (** ...render, **)
     2208:        60: 
     2209:        61: open Notty
     2210:        62: open Notty.Infix
     2211:        63: 
     2212:        64: let dot = I.string A.(fg lightred) "●"
     2213:        65: 
     2214:        66: let background step (n, m) =
     2215:        67:   let k = 24. *. sin (float (step + m + n) /. 10.) |> truncate in
     2216:        68:   if k > 0 then I.string A.(fg (gray k)) "." else I.void 1 1
     2217:        69: 
     2218:        70: let render (w, h) step life =
     2219:        71:   I.tabulate w (h - 1) (fun x y ->
     2220:        72:     let pt = (x, y) in if CSet.mem pt life then dot else background step pt
     2221:        73:   ) <->
     2222:        74:   I.(strf ~attr:A.(fg lightblack) "[generation %04d]" step |>
     2223:        75:       hsnap ~align:`Right w)
     2224:        76: 
     2225:        77: (** ...and interact. **)
     2226:        78: 
     2227:        79: open Lwt.Infix
     2228:        80: open Notty_lwt
     2229:        81: 
     2230:        82: let timer () = Lwt_unix.sleep 0.1 >|= fun () -> `Timer
     2231:        83: let event term = Lwt_stream.get (Term.events term) >|= function
     2232:        84:   | Some (`Resize _ | #Unescape.event as x) -> x
     2233:        85:   | None -> `End
     2234:        86: 
     2235:        87: let rec loop term (e, t) (dim, n, life as st) =
     2236:        88:   (e <?> t) >>= function
     2237:        89:   | `End | `Key (`Escape, []) | `Key (`ASCII 'C', [`Ctrl]) ->
     2238:        90:       Lwt.return_unit
     2239:        91:   | `Timer ->
     2240:        92:       Term.image term (render dim n life) >>= fun () ->
     2241:        93:         loop term (e, timer ())
     2242:        94:           (dim, n + 1, step (torus dim) life)
     2243:        95:   | `Mouse ((`Press `Left|`Drag), (x, y), _) ->
     2244:        96:       loop term (event term, t)
     2245:        97:         (dim, n, CSet.add (torus dim (x, y)) life)
     2246:        98:   | `Resize dim ->
     2247:        99:       let life = CSet.map (torus dim) life in
     2248:       100:       Term.image term (render dim n life) >>= fun () ->
     2249:       101:         loop term (event term, t) (dim, n, life)
     2250:       102:   | _ -> loop term (event term, t) st
     2251:       103: 
     2252:       104: let main () =
     2253:       105:   let t = Term.create () in
     2254:       106:   loop t (event t, timer ()) (Term.size t, 0, glider)
     2255:       107: 
     2256:       108: let () = Lwt_main.run @@ main ()
     2257: Added regular file ../notty/examples/linear.ml:
     2258:         1: (* Copyright (c) 2016-2017 David Kaloper Meršinjak. All rights reserved.
     2259:         2:    See LICENSE.md. *)
     2260:         3: 
     2261:         4: (*
     2262:         5:  * Elementary Cellular Automata
     2263:         6:  *)
     2264:         7: open Notty
     2265:         8: open Notty.Infix
     2266:         9: open Common_lwt
     2267:        10: 
     2268:        11: let flip f a b = f b a
     2269:        12: let rec take n = function
     2270:        13:   | x::xs when n > 0 -> x :: take (pred n) xs
     2271:        14:   | _                -> []
     2272:        15: 
     2273:        16: let getd arr d i =
     2274:        17:   if i < 0 || i >= Array.length arr then d else arr.(i)
     2275:        18: 
     2276:        19: let f ~rule a b c =
     2277:        20:   if rule land (1 lsl (a lsl 2 + b lsl 1 + c)) > 0 then 1 else 0
     2278:        21: 
     2279:        22: let step ~rule w arr =
     2280:        23:   let get = getd arr 0 in
     2281:        24:   Array.init w @@ fun i ->
     2282:        25:     f ~rule (get (i - 1)) (get i) (get (i + 1))
     2283:        26: 
     2284:        27: let dot  = I.char A.(bg lightwhite) ' ' 1 1
     2285:        28: let void = I.void 1 1
     2286:        29: 
     2287:        30: let render ~rule ~h xss =
     2288:        31:   let cons k = function
     2289:        32:     | 0 -> I.void k 1
     2290:        33:     | _ -> I.char A.(bg lightwhite) ' ' k 1 in
     2291:        34:   let rec rline s k i arr =
     2292:        35:     if i >= Array.length arr then
     2293:        36:       cons k s
     2294:        37:     else if arr.(i) = s then
     2295:        38:       rline s (k + 1) (i + 1) arr
     2296:        39:     else cons k s <|> rline (1 - s) 1 (i + 1) arr in
     2297:        40:   ( xss |> List.rev |> List.map (rline 0 0 0) |> I.vcat
     2298:        41:     |> I.vsnap ~align:`Top (h - 2) ) <->
     2299:        42:   ( I.strf ~attr:A.(fg lightgreen ++ bg black) " RULE %d " rule
     2300:        43:     |> I.vpad 1 0 )
     2301:        44: 
     2302:        45: let rule = 124 (* 110 mirrored *)
     2303:        46: 
     2304:        47: let main () =
     2305:        48:   simpleterm_lwt_timed ~delay:0.1 ([], rule)
     2306:        49:   ~f:(fun (w, h) (lines, rule) -> function
     2307:        50:     | `Timer ->
     2308:        51:         let prev  = match lines with [] -> [|1|] | h::_ -> h in
     2309:        52:         let lines = step ~rule w prev :: lines |> take (h - 2) in
     2310:        53:         `Redraw ((lines, rule), render ~rule ~h lines)
     2311:        54:     | `Resize _ ->
     2312:        55:         let lines = lines |> take h in
     2313:        56:         `Redraw ((lines, rule), render ~rule ~h lines)
     2314:        57:     | `Key (`Arrow `Left, []) ->
     2315:        58:         `Redraw (([], rule - 1), render ~rule ~h lines)
     2316:        59:     | `Key (`Arrow `Right, []) ->
     2317:        60:         `Redraw (([], rule + 1), render ~rule ~h lines)
     2318:        61:     | _ -> `Continue (lines, rule)
     2319:        62:   )
     2320:        63: 
     2321:        64: let () = Lwt_main.run @@ main ()
     2322: Added regular file ../notty/examples/mouse.ml:
     2323:         1: (* Copyright (c) 2016-2017 David Kaloper Meršinjak. All rights reserved.
     2324:         2:    See LICENSE.md. *)
     2325:         3: 
     2326:         4: (**
     2327:         5:  * Demonstrates mouse input.
     2328:         6:  *)
     2329:         7: open Notty
     2330:         8: open Common
     2331:         9: 
     2332:        10: let lnv = Uchar.of_int 0x2502
     2333:        11: and lnh = Uchar.of_int 0x2500
     2334:        12: and crs = Uchar.of_int 0x253c
     2335:        13: 
     2336:        14: let clip a b x = min b (max a x)
     2337:        15: 
     2338:        16: let () =
     2339:        17:   simpleterm ~s:(`Down, (0, 0), [], 11)
     2340:        18:     ~f:(fun (st, pos, mods, scr as s) -> function
     2341:        19:       | `Mouse ((`Press `Left|`Drag), pos, mods) -> Some (`Drag, pos, mods, scr)
     2342:        20:       | `Mouse (`Press (`Scroll s), _, _) ->
     2343:        21:           Some (st, pos, mods, clip 0 23 (scr + match s with `Up -> 1 | _ -> -1))
     2344:        22:       | `Mouse (`Release, pos, _) -> Some (`Down, pos, [], scr)
     2345:        23:       | _ -> Some s)
     2346:        24:     ~imgf:I.(fun (w, h) (st, (x, y), mods, scr) ->
     2347:        25:       let cross =
     2348:        26:         let a  = match st with `Drag -> A.(fg lightgreen) | `Down -> A.(fg green) in
     2349:        27:         (uchar a lnh x 1 |> vpad y 0) <|>
     2350:        28:         (uchar a lnv 1 y <-> uchar a crs 1 1 <-> uchar a lnv 1 (h - y)) <|>
     2351:        29:         (uchar a lnh (w - x - 1) 1 |> vpad y 0)
     2352:        30:         |> crop ~t:1 ~l:1 ~r:3
     2353:        31:         |> hpad 1 1
     2354:        32:         |> vsnap ~align:`Top (h - 1)
     2355:        33:       and scroll =
     2356:        34:         List.(range 0 scr |> rev |> map @@ fun level ->
     2357:        35:           Images.dot A.(gray level)
     2358:        36:         ) |> vcat |> vsnap ~align:`Bottom (h - 1)
     2359:        37:       and status =
     2360:        38:         let a = A.(fg lightblack ++ bg black) in
     2361:        39:         let fa m = if List.mem m mods then A.(fg lightgreen ++ bg black) else a in
     2362:        40:         string A.empty "Use the mouse." </>
     2363:        41:         (hcat [ string a "["
     2364:        42:               ; string (fa `Ctrl) "C"
     2365:        43:               ; string (fa `Meta) "M"
     2366:        44:               ; strf ~attr:a "] @(%03d, %03d)" x y ]
     2367:        45:          |> hsnap ~align:`Right w)
     2368:        46:       in (cross <|> scroll) <-> status
     2369:        47:     )
     2370: Added regular file ../notty/examples/rain.ml:
     2371:         1: 
     2372:         2: let () = Random.self_init ()
     2373:         3: 
     2374:         4: let rec (--) a b = if a > b then [] else a :: succ a -- b
     2375:         5: 
     2376:         6: let utf8_of_code_point =
     2377:         7:   let buf = Buffer.create 7 in fun cp ->
     2378:         8:     Buffer.clear buf;
     2379:         9:     Uutf.Buffer.add_utf_8 buf (Uchar.of_int cp);
     2380:        10:     Buffer.contents buf
     2381:        11: 
     2382:        12: let nsym = 4096
     2383:        13: let glitch = nsym / 20
     2384:        14: let symbols = Array.(concat [
     2385:        15:   init 58 (fun x -> utf8_of_code_point (0xff66 + x));
     2386:        16:   init 10 (fun x -> utf8_of_code_point (0x30 + x));
     2387:        17:   (* init 26 (fun x -> utf8_of_code_point (0x61 + x)); *)
     2388:        18:   (* init 14 (fun x -> utf8_of_code_point (0x21 + x)); *)
     2389:        19: ])
     2390:        20: let sym () = symbols.(Random.int (Array.length symbols))
     2391:        21: let syms = Array.init nsym (fun _ -> sym ())
     2392:        22: 
     2393:        23: let gen_wait h = `Wait Random.(int (h / 2))
     2394:        24: and gen_line h =
     2395:        25:   `Line Random.(0, int (nsym - h), int (h + h / 2) + 1, int 2 + 1)
     2396:        26: let gen (w, h as dim) =
     2397:        27:   let lines = 1 -- w |> List.map @@ fun _ ->
     2398:        28:     if Random.float 1. < 0.1 then gen_line h else gen_wait h in
     2399:        29:   (dim, lines)
     2400:        30: 
     2401:        31: let step ((_, h as dim), xs) =
     2402:        32:   let xs = xs |> List.map @@ function
     2403:        33:       `Wait 0 -> gen_line h
     2404:        34:     | `Wait n -> `Wait (n - 1)
     2405:        35:     | `Line (i, _, win, k) when i - win + k >= h -> gen_wait h
     2406:        36:     | `Line (i, s, win, k) -> `Line (i + k, s, win, k) in
     2407:        37:   Random.(for _ = 0 to int glitch do syms.(int nsym) <- sym () done);
     2408:        38:   (dim, xs)
     2409:        39: 
     2410:        40: open Notty
     2411:        41: open Notty.Infix
     2412:        42: 
     2413:        43: let bgc = A.(bg @@ rgb ~r:0 ~g:0 ~b:0)
     2414:        44: 
     2415:        45: let color i n =
     2416:        46:   let chan x = x *. 255. |> truncate
     2417:        47:   and t  = float i /. float n in
     2418:        48:   let t1 = exp (-. t /. 0.02) |> chan
     2419:        49:   and t2 = exp (-. t /. 0.45) |> chan in
     2420:        50:   A.rgb_888 ~r:t1 ~b:t1 ~g:t2
     2421:        51: 
     2422:        52: let show ((w, h), xs) =
     2423:        53:   let f = function
     2424:        54:     `Wait _ -> I.void 1 0
     2425:        55:   | `Line (i, sym, win, _) ->
     2426:        56:       let last = i - win
     2427:        57:       and off = max 0 (i - h + 1) in
     2428:        58:       let rec chars w =
     2429:        59:         let ix = w + last in
     2430:        60:         if 0 <= min ix w then syms.(sym + ix) :: chars (w - 1) else [] in
     2431:        61:       let rec images acc i = function
     2432:        62:         | []    -> acc
     2433:        63:         | x::xs -> let img = I.string A.(fg (color i win) ++ bgc) x in
     2434:        64:                    images (img :: acc) (i + 1) xs in
     2435:        65:       chars (win - off) |> images [] off
     2436:        66:         |> I.vcat |> I.vpad (max 0 (i - win)) 0 in
     2437:        67:   (List.map f xs |> I.hcat) </> I.char bgc ' ' w h
     2438:        68: 
     2439:        69: open Notty_unix
     2440:        70: 
     2441:        71: type r = [ Unescape.event | `Resize of int * int | `End | `Timer ]
     2442:        72: 
     2443:        73: let event ~delay t =
     2444:        74:   if Term.pending t then (Term.event t :> r) else
     2445:        75:     let open Unix in
     2446:        76:     match select [Term.fds t |> fst] [] [] delay with
     2447:        77:     | ([], _, _) -> `Timer
     2448:        78:     | (_::_, _, _) -> (Term.event t :> r)
     2449:        79:     | exception Unix_error (EINTR, _, _) -> (Term.event t :> r)
     2450:        80: 
     2451:        81: let loop t ~frame st =
     2452:        82:   let rec go st deadline =
     2453:        83:     let now = Unix.gettimeofday () in
     2454:        84:     if deadline <= now then
     2455:        85:       ( Term.image t (show st); go (step st) (frame +. deadline) )
     2456:        86:     else match event ~delay:(deadline -. now) t with
     2457:        87:       | `End | `Key (`Escape, _) | `Key (`ASCII 'C', [`Ctrl]) -> ()
     2458:        88:       | `Resize _ | `Key (`ASCII ' ', _) -> go (gen (Term.size t)) deadline
     2459:        89:       | _ -> go st deadline in
     2460:        90:   go st (Unix.gettimeofday ())
     2461:        91: 
     2462:        92: let () =
     2463:        93:   let t = Term.create () in
     2464:        94:   loop t ~frame:0.075 (gen (Term.size t));
     2465:        95:   Term.release t
     2466: Added regular file ../notty/examples/runes.ml:
     2467:         1: (* Copyright (c) 2016-2017 David Kaloper Meršinjak. All rights reserved.
     2468:         2:    See LICENSE.md. *)
     2469:         3: 
     2470:         4: (**
     2471:         5:  * Demonstrates geometry computation with various scripts. A few of those will
     2472:         6:  * usually break.
     2473:         7:  *)
     2474:         8: open Notty
     2475:         9: open Notty.Infix
     2476:        10: open Common
     2477:        11: 
     2478:        12: let hpad_sp attr l r i =
     2479:        13:   let h = I.height i in
     2480:        14:   I.(char attr ' ' l h <|> i <|> char attr ' ' r h)
     2481:        15: 
     2482:        16: let vpad_sp attr t b i =
     2483:        17:   let w = I.width i in
     2484:        18:   I.(char attr ' ' w t <-> i <-> char attr ' ' w b)
     2485:        19: 
     2486:        20: let grid xxs = xxs |> List.map I.hcat |> I.vcat
     2487:        21: 
     2488:        22: let centered attr xs =
     2489:        23:   let lns = List.map I.(string attr) xs in
     2490:        24:   let w   = List.fold_left (fun a i -> max a I.(width i)) 0 lns in
     2491:        25:   lns |> List.map I.(fun ln ->
     2492:        26:     let d = w - I.width ln in
     2493:        27:     char attr ' ' (d / 2) 1 <|> ln <|> char attr ' ' (d - d / 2) 1
     2494:        28:   ) |> I.vcat
     2495:        29: 
     2496:        30: let note xs = I.(
     2497:        31:   string A.(st bold) "Note:" <|>
     2498:        32:   (xs |> List.map (string A.empty) |> vcat |> hpad 1 0)
     2499:        33: )
     2500:        34: 
     2501:        35: let text = [
     2502:        36:     "\225\154\160\225\155\135\225\154\187\225\155\171\225\155\146\225\155\166\225\154\166\225\155\171\225\154\160\225\154\177\225\154\169\225\154\160\225\154\162\225\154\177\225\155\171\225\154\160\225\155\129\225\154\177\225\154\170\225\155\171\225\154\183\225\155\150\225\154\187\225\154\185\225\155\166\225\155\154\225\154\179\225\154\162\225\155\151"
     2503:        37:   ; "\225\155\139\225\154\179\225\155\150\225\154\170\225\155\154\225\155\171\225\154\166\225\155\150\225\154\170\225\154\187\225\155\171\225\155\151\225\154\170\225\154\190\225\154\190\225\154\170\225\155\171\225\154\183\225\155\150\225\154\187\225\154\185\225\155\166\225\155\154\225\154\179\225\155\171\225\155\151\225\155\129\225\154\179\225\155\154\225\154\162\225\154\190\225\155\171\225\154\187\225\155\166\225\155\143\225\155\171\225\155\158\225\154\171\225\155\154\225\154\170\225\154\190"
     2504:        38:   ; "\225\154\183\225\155\129\225\154\160\225\155\171\225\154\187\225\155\150\225\155\171\225\154\185\225\155\129\225\155\154\225\155\150\225\155\171\225\154\160\225\154\169\225\154\177\225\155\171\225\155\158\225\154\177\225\155\129\225\154\187\225\155\143\225\154\190\225\155\150\225\155\171\225\155\158\225\154\169\225\155\151\225\155\150\225\155\139\225\155\171\225\154\187\225\155\154\225\155\135\225\155\143\225\154\170\225\154\190\225\155\172"
     2505:        39:   ; ""
     2506:        40:   ; "\227\129\132\227\130\141\227\129\175\227\129\171\227\129\187\227\129\184\227\129\168\227\129\161\227\130\138\227\129\172\227\130\139\227\130\146"
     2507:        41:   ; "\227\130\143\227\129\139\227\130\136\227\129\159\227\130\140\227\129\157\227\129\164\227\129\173\227\129\170\227\130\137\227\130\128"
     2508:        42:   ; "\227\129\134\227\130\144\227\129\174\227\129\138\227\129\143\227\130\132\227\129\190\227\129\145\227\129\181\227\129\147\227\129\136\227\129\166"
     2509:        43:   ; "\227\129\130\227\129\149\227\129\141\227\130\134\227\130\129\227\129\191\227\129\151\227\130\145\227\129\178\227\130\130\227\129\155\227\129\153"
     2510:        44:   ; ""
     2511:        45:   ; "\227\130\164\227\131\173\227\131\143\227\131\139\227\131\155\227\131\152\227\131\136 \227\131\129\227\131\170\227\131\140\227\131\171\227\131\178 \227\131\175\227\130\171\227\131\168\227\130\191\227\131\172\227\130\189 \227\131\132\227\131\141\227\131\138\227\131\169\227\131\160"
     2512:        46:   ; "\227\130\166\227\131\176\227\131\142\227\130\170\227\130\175\227\131\164\227\131\158 \227\130\177\227\131\149\227\130\179\227\130\168\227\131\134 \227\130\162\227\130\181\227\130\173\227\131\166\227\131\161\227\131\159\227\130\183 \227\131\177\227\131\146\227\131\162\227\130\187\227\130\185\227\131\179"
     2513:        47:   ; ""
     2514:        48:   ; "\237\130\164\236\138\164\236\157\152 \234\179\160\236\156\160\236\161\176\234\177\180\236\157\128 \236\158\133\236\136\160\235\129\188\235\166\172 \235\167\140\235\130\152\236\149\188"
     2515:        49:   ; "\237\149\152\234\179\160 \237\138\185\235\179\132\237\149\156 \234\184\176\236\136\160\236\157\128 \237\149\132\236\154\148\236\185\152 \236\149\138\235\139\164"
     2516:        50:   ; ""
     2517:        51:   ; "\206\158\206\181\207\131\206\186\206\181\207\128\206\172\206\182\207\137 \207\132\225\189\180\206\189 \207\136\207\133\207\135\206\191\207\134\206\184\207\140\207\129\206\177 \206\178\206\180\206\181\206\187\207\133\206\179\206\188\206\175\206\177"
     2518:        52:   ; ""
     2519:        53:   ; "\208\167\208\181\209\136\209\155\208\181 \209\134e\209\146\208\181\209\154\208\181 \208\188\209\128e\208\182\208\176\209\129\209\130\208\184\208\188 \209\159\208\176\208\186\208\190\208\188 \208\191\208\190\208\177\208\190\209\153\209\136\208\176\208\178\208\176"
     2520:        54:   ; "\209\132\208\181\209\128\209\130\208\184\208\187\208\184\208\183\208\176\209\134\208\184\209\152\209\131 \208\179\208\181\208\189\209\129\208\186\208\184\209\133 \209\133\208\184\208\177\209\128\208\184\208\180\208\176!"
     2521:        55:   ; ""
     2522:        56:   ; "Heiz\195\182lr\195\188cksto\195\159abd\195\164mpfung."
     2523:        57:   ; ""
     2524:        58:   ; "\208\146 \209\135\208\176\209\137\208\176\209\133 \209\142\208\179\208\176 \208\182\208\184\208\187 \208\177\209\139 \209\134\208\184\209\130\209\128\209\131\209\129? \208\148\208\176, \208\189\208\190 \209\132\208\176\208\187\209\140\209\136\208\184\208\178\209\139\208\185 \209\141\208\186\208\183\208\181\208\188\208\191\208\187\209\143\209\128!"
     2525:        59:   ; ""
     2526:        60:   ; "\225\131\149\225\131\148\225\131\158\225\131\174\225\131\152\225\131\161 \225\131\162\225\131\167\225\131\144\225\131\157\225\131\161\225\131\144\225\131\156\225\131\152 \225\131\168\225\131\157\225\131\151\225\131\144 \225\131\160\225\131\163\225\131\161\225\131\151\225\131\144\225\131\149\225\131\148\225\131\154\225\131\152"
     2527:        61:   ; ""
     2528:        62:   ; "Lu\195\173s arg\195\188ia \195\160 J\195\186lia que \194\171bra\195\167\195\181es, f\195\169, ch\195\161,"
     2529:        63:   ; "\195\179xido, p\195\180r, z\195\162ng\195\163o\194\187 eram palavras do portugu\195\170s."
     2530:        64:   ; ""
     2531:        65:   ; "ding ↹ ∀ ⌘ ▓ ◭ ☃ ♠ ♋ ♕ ⚅ ♩ ☭ ✎ 🂡 bats"
     2532:        66:   ; ""
     2533:        67:   ; "\216\181\217\144\217\129 \216\174\217\142\217\132\217\130\217\142 \216\174\217\142\217\136\216\175\217\144 \217\131\217\142\217\133\217\144\216\171\217\132\217\144 \216\167\217\132\216\180\217\142\217\133\216\179\217\144 \216\165\217\144\216\176 \216\168\217\142\216\178\217\142\216\186\217\142\216\170 \226\128\148 \217\138\217\142\216\173\216\184\217\137 \216\167\217\132\216\182\217\142\216\172\217\138\216\185\217\143 \216\168\217\144\217\135\216\167 \217\134\217\142\216\172\217\132\216\167\216\161\217\142 \217\133\217\144\216\185\216\183\216\167\216\177\217\144"
     2534:        68:   ; ""
     2535:        69:   ; "\215\147\215\146 \215\161\215\167\215\168\215\159 \215\169\215\152 \215\145\215\153\215\157 \215\158\215\144\215\149\215\155\215\150\215\145 \215\149\215\156\215\164\215\170\215\162 \215\158\215\166\215\144 \215\156\215\149 \215\151\215\145\215\168\215\148 \215\144\215\153\215\154 \215\148\215\167\215\156\215\153\215\152\215\148"
     2536:        70:   ; ""
     2537:        71:   ; "\224\174\175\224\174\190\224\174\174\224\174\177\224\174\191\224\174\168\224\175\141\224\174\164 \224\174\174\224\175\138\224\174\180\224\174\191\224\174\149\224\174\179\224\174\191\224\174\178\224\175\135 \224\174\164\224\174\174\224\174\191\224\174\180\224\175\141\224\174\174\224\175\138\224\174\180\224\174\191 \224\174\170\224\175\139\224\174\178\224\175\141 \224\174\135\224\174\169\224\174\191\224\174\164\224\174\190\224\174\181\224\174\164\224\175\129 \224\174\142\224\174\153\224\175\141\224\174\149\224\175\129\224\174\174\224\175\141 \224\174\149\224\174\190\224\174\163\224\175\139\224\174\174\224\175\141,"
     2538:        72:   ; "\224\174\170\224\174\190\224\174\174\224\174\176\224\174\176\224\174\190\224\174\175\224\175\141 \224\174\181\224\174\191\224\174\178\224\174\153\224\175\141\224\174\149\224\175\129\224\174\149\224\174\179\224\174\190\224\174\175\224\175\141, \224\174\137\224\174\178\224\174\149\224\174\169\224\175\136\224\174\164\224\175\141\224\174\164\224\175\129\224\174\174\224\175\141 \224\174\135\224\174\149\224\174\180\224\175\141\224\174\154\224\175\141\224\174\154\224\174\191\224\174\154\224\175\138\224\174\178\224\174\170\224\175\141 \224\174\170\224\174\190\224\174\169\224\175\141\224\174\174\224\175\136 \224\174\149\224\175\134\224\174\159\224\175\141\224\174\159\224\175\129"
     2539:        73:   ; ""
     2540:        74:   ; "\224\178\172\224\178\190 \224\178\135\224\178\178\224\179\141\224\178\178\224\178\191 \224\178\184\224\178\130\224\178\173\224\178\181\224\178\191\224\178\184\224\179\129 \224\178\135\224\178\130\224\178\166\224\179\134\224\178\168\224\179\141\224\178\168 \224\178\185\224\179\131\224\178\166\224\178\175\224\178\166\224\178\178\224\178\191"
     2541:        75:   ; "\224\178\168\224\178\191\224\178\164\224\179\141\224\178\175\224\178\181\224\179\130 \224\178\133\224\178\181\224\178\164\224\178\176\224\178\191\224\178\170 \224\178\184\224\178\164\224\179\141\224\178\175\224\178\190\224\178\181\224\178\164\224\178\190\224\178\176"
     2542:        76:   ; ""
     2543:        77:   ; "\224\164\139\224\164\183\224\164\191\224\164\175\224\165\139\224\164\130 \224\164\149\224\165\139 \224\164\184\224\164\164\224\164\190\224\164\168\224\165\135 \224\164\181\224\164\190\224\164\178\224\165\135 \224\164\166\224\165\129\224\164\183\224\165\141\224\164\159 \224\164\176\224\164\190\224\164\149\224\165\141\224\164\183\224\164\184\224\165\139\224\164\130 \224\164\149\224\165\135 \224\164\176\224\164\190\224\164\156\224\164\190 \224\164\176\224\164\190\224\164\181\224\164\163 \224\164\149\224\164\190 \224\164\184\224\164\176\224\165\141\224\164\181\224\164\168\224\164\190\224\164\182 \224\164\149\224\164\176\224\164\168\224\165\135 \224\164\181\224\164\190\224\164\178\224\165\135"
     2544:        78:   ; "\224\164\181\224\164\191\224\164\183\224\165\141\224\164\163\224\165\129\224\164\181\224\164\164\224\164\190\224\164\176 \224\164\173\224\164\151\224\164\181\224\164\190\224\164\168 \224\164\182\224\165\141\224\164\176\224\165\128\224\164\176\224\164\190\224\164\174, \224\164\133\224\164\175\224\165\139\224\164\167\224\165\141\224\164\175\224\164\190 \224\164\149\224\165\135 \224\164\174\224\164\185\224\164\190\224\164\176\224\164\190\224\164\156 \224\164\166\224\164\182\224\164\176\224\164\165 \224\164\149\224\165\135 \224\164\172\224\164\161\224\164\188\224\165\135 \224\164\184\224\164\170\224\165\129\224\164\164\224\165\141\224\164\176 \224\164\165\224\165\135\224\165\164"
     2545:        79: ]
     2546:        80: 
     2547:        81: let () =
     2548:        82:   let attr = A.(fg lightmagenta) in
     2549:        83:   let img = I.(
     2550:        84:     centered attr text
     2551:        85:     |> vpad_sp attr 1 1 |> hpad_sp attr 2 2
     2552:        86:     |> Images.outline attr
     2553:        87:     |> pad ~t:1 ~b:1 ~l:2 ~r:2
     2554:        88:   ) <->
     2555:        89:     note [ "Alignment will usually break on the last few scripts."
     2556:        90:          ; "This is at the limit of what terminals can do."
     2557:        91:          ; ":(" ]
     2558:        92:   in Notty_unix.(eol img |> output_image)
     2559: Added regular file ../notty/examples/sierpinski.ml:
     2560:         1: (* Copyright (c) 2016-2017 David Kaloper Meršinjak. All rights reserved.
     2561:         2:    See LICENSE.md. *)
     2562:         3: 
     2563:         4: (**
     2564:         5:  * A classic example in combinatory graphics.
     2565:         6:  *
     2566:         7:  * Demonstrates interaction.
     2567:         8:  *)
     2568:         9: open Notty
     2569:        10: open Common
     2570:        11: 
     2571:        12: let () =
     2572:        13:   simpleterm ~s:1
     2573:        14:     ~f:(fun s -> function
     2574:        15:       | `Key (`ASCII 'q', _) -> None
     2575:        16:       | `Key (`Arrow a, _) ->
     2576:        17:         ( match a with
     2577:        18:           | `Up | `Left -> Some (max 1 (s - 1))
     2578:        19:           | `Down | `Right -> Some (min 10 (s + 1)) )
     2579:        20:       | _ -> Some s)
     2580:        21:     ~imgf:I.(fun _ s ->
     2581:        22:       string A.empty (string_of_int s) <->
     2582:        23:       pad ~l:2 ~t:1 (Images.sierp A.magenta s)
     2583:        24:     )
     2584: Added regular file ../notty/examples/sierpinski_lwt.ml:
     2585:         1: (* Copyright (c) 2016-2017 David Kaloper Meršinjak. All rights reserved.
     2586:         2:    See LICENSE.md. *)
     2587:         3: 
     2588:         4: (**
     2589:         5:  * Demonstrates Lwt interaction.
     2590:         6:  *)
     2591:         7: open Notty
     2592:         8: open Common_lwt
     2593:         9: 
     2594:        10: let img s = I.(
     2595:        11:   string A.empty (string_of_int s) <-> hpad 2 0 (Images.sierp A.magenta s)
     2596:        12: )
     2597:        13: 
     2598:        14: let () =
     2599:        15:   simpleterm_lwt ~s:1
     2600:        16:     ~f:(fun s -> function
     2601:        17:       | `Key (`ASCII 'q', _) -> None
     2602:        18:       | `Key (`Arrow a, _) ->
     2603:        19:         ( match a with
     2604:        20:           | `Up | `Left -> Some (max 1 (s - 1))
     2605:        21:           | `Down | `Right -> Some (min 10 (s + 1)) )
     2606:        22:       | _ -> Some s)
     2607:        23:     ~imgf:I.(fun _ s ->
     2608:        24:       string A.empty (string_of_int s) <->
     2609:        25:       pad ~l:2 ~t:1 (Images.sierp A.magenta s)
     2610:        26:     )
     2611: Added regular file ../notty/examples/testpatterns.ml:
     2612:         1: (* Copyright (c) 2016-2017 David Kaloper Meršinjak. All rights reserved.
     2613:         2:    See LICENSE.md. *)
     2614:         3: 
     2615:         4: (**
     2616:         5:  * A few images that exercise image composition, cropping, and padding. This
     2617:         6:  * test is a good canary.
     2618:         7:  *)
     2619:         8: open Common
     2620:         9: open Notty_unix
     2621:        10: 
     2622:        11: let () = Images.[i3; i5; checker1] |> List.map eol |> List.iter output_image
     2623: Added regular file ../notty/examples/thisbig.ml:
     2624:         1: (* Copyright (c) 2016-2017 David Kaloper Meršinjak. All rights reserved.
     2625:         2:    See LICENSE.md. *)
     2626:         3: 
     2627:         4: open Notty
     2628:         5: open Common
     2629:         6: 
     2630:         7: let () =
     2631:         8:   Notty_unix.output_image_size @@ fun (w, h) ->
     2632:         9:     Images.outline A.(fg lightblue)
     2633:        10:       I.(hsnap (w - 2) @@
     2634:        11:           vsnap (h - 3) @@ (* +1 for the prompt *)
     2635:        12:             Images.sierp A.lightblue 5)
     2636: Added regular file ../notty/notty.opam:
     2637:         1: opam-version: "2.0"
     2638:         2: homepage:     "https://github.com/pqwy/notty"
     2639:         3: dev-repo:     "git+https://github.com/pqwy/notty.git"
     2640:         4: bug-reports:  "https://github.com/pqwy/notty/issues"
     2641:         5: doc:          "https://pqwy.github.io/notty/doc"
     2642:         6: author:       "David Kaloper <dk505@cam.ac.uk>"
     2643:         7: maintainer:   "David Kaloper <dk505@cam.ac.uk>"
     2644:         8: license:      "ISC"
     2645:         9: synopsis:     "Declaring terminals"
     2646:        10: description:
     2647:        11:   "Notty is a declarative terminal library for OCaml structured around a notion
     2648:        12:   of composable images. It tries to abstract away the basic terminal programming
     2649:        13:   model, providing something simpler and more expressive."
     2650:        14: 
     2651:        15: build: [ [ "dune" "subst" ] {dev}
     2652:        16:          [ "dune" "build" "-p" name "-j" jobs ] ]
     2653:        17: depends: [
     2654:        18:   "ocaml" {>= "4.08.0"}
     2655:        19:   "dune" {>= "1.7"}
     2656:        20:   "cppo" {build & >= "1.1.0"}
     2657:        21:   "uutf" {>= "1.0.0"}
     2658:        22: ]
     2659:        23: depopts: [ "lwt" ]
     2660:        24: conflicts: [ "lwt" {<"2.5.2"} ]
     2661: Added regular file ../notty/src/dune:
     2662:         1: (include_subdirs unqualified)
     2663:         2: 
     2664:         3: (library
     2665:         4:   (public_name notty)
     2666:         5:   (synopsis "Declaring terminals")
     2667:         6:   (libraries uutf)
     2668:         7:   (wrapped false)
     2669:         8:   (modules notty notty_grapheme_cluster notty_uucp notty_uucp_data)
     2670:         9:   (private_modules notty_grapheme_cluster notty_uucp notty_uucp_data))
     2671:        10: 
     2672:        11: (library
     2673:        12:   (public_name notty.top)
     2674:        13:   (synopsis "Notty toplevel support")
     2675:        14:   (name notty_top)
     2676:        15:   (wrapped false)
     2677:        16:   (modules notty_top)
     2678:        17:   (preprocess (action (run %{bin:cppo} -V OCAML:%{ocaml_version} %{input-file})))
     2679:        18:   (libraries notty compiler-libs.toplevel))
     2680:        19: 
     2681:        20: (install
     2682:        21:   (section lib)
     2683:        22:   (files (notty_top_init.ml as top/notty_top_init.ml)))
     2684: Added regular file ../notty/src/no-uucp/README.md:
     2685:         1: Cannibalized bits of Uucp:
     2686:         2: 
     2687:         3: - `Notty_uucp_data` is generated from an actual Uucp installation.
     2688:         4: - `Notty_uucp` uses it to provide the few Unicode properties that Notty needs.
     2689:         5: - `Notty_grapheme_cluster` is `Grapheme_cluster` from Uuseg, adapted to use the
     2690:         6:   above.
     2691:         7: 
     2692:         8: Compiled size of these is on the order of 70K. Uucp is presently a monolithic 10M.
     2693:         9: 
     2694:        10: The idea is to remove these in favor of the actual Uucp/Uuseg, as soon as it
     2695:        11: becomes possible to depend only on the necessary parts of Uucp.
     2696:        12: 
     2697:        13: Uucp and Uuseg are Copyright (c) 2014 Daniel C. Bünzli.
     2698: Added regular file ../notty/src/no-uucp/notty_grapheme_cluster.ml:
     2699:         1: (*---------------------------------------------------------------------------
     2700:         2:    Copyright (c) 2014 Daniel C. Bünzli. All rights reserved.
     2701:         3:    Distributed under the ISC license, see terms at the end of the file.
     2702:         4:    %%NAME%% %%VERSION%%
     2703:         5:   ---------------------------------------------------------------------------*)
     2704:         6: 
     2705:         7: (* These are the rules as found in [1], with property values aliases [2]
     2706:         8:    substituted.
     2707:         9: 
     2708:        10:    GB1.               sot ÷ Any
     2709:        11:    GB2.               Any ÷ eot
     2710:        12:    GB3.                CR × LF
     2711:        13:    GB4.        (CN|CR|LF) ÷
     2712:        14:    GB5.                   ÷ (CN|CR|LF)
     2713:        15:    GB6.                 L × (L|V|LV|LVT)
     2714:        16:    GB7.            (LV|V) × (V|T)
     2715:        17:    GB8.           (LVT|T) × T
     2716:        18:    GB9.                   × (EX|ZWJ)
     2717:        19:    GB9a.                  × SM
     2718:        20:    GB9b.               PP ×
     2719:        21:    GB10. (v10.0.0) (EB|EBG) EX* × EM
     2720:        22:    GB11. (v10.0.0)          ZWJ × (GAZ|EBG)
     2721:        23:    GB12.  sot (RI RI)* RI × RI
     2722:        24:    GB13.   [^RI] (RI RI)* × RI
     2723:        25:    GB999.             Any ÷ Any
     2724:        26: 
     2725:        27:    [1]: http://www.unicode.org/reports/tr29/#Grapheme_Cluster_Boundaries
     2726:        28:    [2]: http://www.unicode.org/Public/7.0.0/ucd/PropertyValueAliases.txt
     2727:        29:    [3]: http://www.unicode.org/Public/7.0.0/ucd/auxiliary/GraphemeBreakTest.html
     2728:        30: 
     2729:        31:    By the structure of the rules we see that grapheme clusters
     2730:        32:    boundaries can *mostly* be determined by simply looking at the
     2731:        33:    grapheme cluster break property value of the character on the left
     2732:        34:    and on the right of a boundary. The exceptions are GB10 and GB12-13
     2733:        35:    which are handled specially by enriching the segmenter state in
     2734:        36:    a horribly ad-hoc fashion. *)
     2735:        37: 
     2736:        38: type ret = [ `Await | `Boundary | `End | `Uchar of Uchar.t ]
     2737:        39: 
     2738:        40: type gcb =
     2739:        41:   | CN | CR | EX | EB | EBG | EM | GAZ | L | LF | LV | LVT | PP | RI
     2740:        42:   | SM | T | V | XX | ZWJ | Sot
     2741:        43: 
     2742:        44: (* WARNING. The indexes used here need to be synchronized with those
     2743:        45:    assigned by uucp for Uucp.Break.Low.grapheme_cluster. *)
     2744:        46: 
     2745:        47: let byte_to_gcb =
     2746:        48:   [| CN; CR; EX; EB; EBG; EM; GAZ; L; LF; LV; LVT; PP; RI;
     2747:        49:      SM; T; V; XX; ZWJ; |]
     2748:        50: 
     2749:        51: let gcb u = byte_to_gcb.(Notty_uucp.grapheme_cluster_boundary u)
     2750:        52: 
     2751:        53: type state =
     2752:        54: | Fill  (* get next uchar to decide boundary. *)
     2753:        55: | Flush (* an uchar is buffered, client needs to get it out with `Await. *)
     2754:        56: | End   (* `End was added. *)
     2755:        57: 
     2756:        58: type t =
     2757:        59:   { mutable state : state;                                 (* current state. *)
     2758:        60:     mutable left : gcb;            (* break property value left of boundary. *)
     2759:        61:     mutable odd_ri : bool;                  (* odd number of RI on the left. *)
     2760:        62:     mutable emoji_seq : bool;               (* (EB|EBG) Extend* on the left. *)
     2761:        63:     mutable buf : [ `Uchar of Uchar.t ] }                 (* bufferized add. *)
     2762:        64: 
     2763:        65: let nul_buf = `Uchar (Uchar.unsafe_of_int 0x0000)
     2764:        66: 
     2765:        67: let create () =
     2766:        68:   { state = Fill; left = Sot;
     2767:        69:     odd_ri = false; emoji_seq = false;
     2768:        70:     buf = nul_buf (* overwritten *); }
     2769:        71: 
     2770:        72: let break s right = match s.left, right with
     2771:        73: | (* GB1 *)   Sot, _ -> true
     2772:        74:   (* GB2 is handled by `End *)
     2773:        75: | (* GB3 *)   CR, LF -> false
     2774:        76: | (* GB4 *)   (CN|CR|LF), _ -> true
     2775:        77: | (* GB5 *)   _, (CN|CR|LF) -> true
     2776:        78: | (* GB6 *)   L, (L|V|LV|LVT) -> false
     2777:        79: | (* GB7 *)   (LV|V), (V|T) -> false
     2778:        80: | (* GB8 *)   (LVT|T), T -> false
     2779:        81: | (* GB9+a *) _, (EX|ZWJ|SM) -> false
     2780:        82: | (* GB9b *)  PP, _ -> false
     2781:        83: | (* GB10 *)  _, EM when s.emoji_seq -> false
     2782:        84: | (* GB11 *)  ZWJ, (GAZ|EBG) -> false
     2783:        85: | (* GB12+13 *) RI, RI when s.odd_ri -> false
     2784:        86: | (* GB999 *) _, _ -> true
     2785:        87: 
     2786:        88: let update_left s right =
     2787:        89:   s.left <- right;
     2788:        90:   match s.left with
     2789:        91:   | EX -> (* keep s.emoji_seq as is *) s.odd_ri <- false
     2790:        92:   | EB | EBG -> s.emoji_seq <- true; s.odd_ri <- false
     2791:        93:   | RI -> s.emoji_seq <- false; s.odd_ri <- not s.odd_ri
     2792:        94:   | _ -> s.emoji_seq <- false; s.odd_ri <- false
     2793:        95: 
     2794:        96: let add s = function
     2795:        97: | `Uchar u as add ->
     2796:        98:     begin match s.state with
     2797:        99:     | Fill ->
     2798:       100:         let right = gcb u in
     2799:       101:         let break = break s right in
     2800:       102:         update_left s right;
     2801:       103:         if not break then add else
     2802:       104:         (s.state <- Flush; s.buf <- add; `Boundary)
     2803:       105:     | Flush | End -> assert false
     2804:       106:     end
     2805:       107: | `Await ->
     2806:       108:     begin match s.state with
     2807:       109:     | Flush -> s.state <- Fill; (s.buf :> ret)
     2808:       110:     | End -> `End
     2809:       111:     | Fill -> `Await
     2810:       112:     end
     2811:       113: | `End ->
     2812:       114:     begin match s.state with
     2813:       115:     | Fill -> s.state <- End; if s.left = Sot then `End else `Boundary
     2814:       116:     | Flush | End -> assert false
     2815:       117:     end
     2816:       118: 
     2817:       119: (*---------------------------------------------------------------------------
     2818:       120:    Copyright (c) 2014 Daniel C. Bünzli
     2819:       121: 
     2820:       122:    Permission to use, copy, modify, and/or distribute this software for any
     2821:       123:    purpose with or without fee is hereby granted, provided that the above
     2822:       124:    copyright notice and this permission notice appear in all copies.
     2823:       125: 
     2824:       126:    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
     2825:       127:    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
     2826:       128:    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
     2827:       129:    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
     2828:       130:    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
     2829:       131:    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
     2830:       132:    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
     2831:       133:   ---------------------------------------------------------------------------*)
     2832: Added regular file ../notty/src/no-uucp/notty_grapheme_cluster.mli:
     2833:         1: (*---------------------------------------------------------------------------
     2834:         2:    Copyright (c) 2014 Daniel C. Bünzli. All rights reserved.
     2835:         3:    Distributed under the ISC license, see terms at the end of the file.
     2836:         4:    %%NAME%% %%VERSION%%
     2837:         5:   ---------------------------------------------------------------------------*)
     2838:         6: 
     2839:         7: type ret = [ `Await | `Boundary | `End | `Uchar of Uchar.t ]
     2840:         8: 
     2841:         9: type t
     2842:        10: val create : unit -> t
     2843:        11: val add : t -> [ `Await | `End | `Uchar of Uchar.t ] -> ret
     2844:        12: 
     2845:        13: (*---------------------------------------------------------------------------
     2846:        14:    Copyright (c) 2014 Daniel C. Bünzli
     2847:        15: 
     2848:        16:    Permission to use, copy, modify, and/or distribute this software for any
     2849:        17:    purpose with or without fee is hereby granted, provided that the above
     2850:        18:    copyright notice and this permission notice appear in all copies.
     2851:        19: 
     2852:        20:    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
     2853:        21:    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
     2854:        22:    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
     2855:        23:    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
     2856:        24:    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
     2857:        25:    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
     2858:        26:    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
     2859:        27:   ---------------------------------------------------------------------------*)
     2860: Added regular file ../notty/src/no-uucp/notty_uucp.ml:
     2861:         1: (* Copyright (c) 2020 David Kaloper Meršinjak. All rights reserved.
     2862:         2:    See LICENSE.md. *)
     2863:         3: 
     2864:         4: (* Unpacked interval lookup table. *)
     2865:         5: let find_i ~def k (xs, _, _ as tab) =
     2866:         6:   let rec go i j (los, his, vs as tab) (k: int) def =
     2867:         7:     if i > j then def else
     2868:         8:     let x = (i + j) / 2 in
     2869:         9:     if k < Array.unsafe_get los x then go i (x - 1) tab k def else
     2870:        10:     if k > Array.unsafe_get his x then go (x + 1) j tab k def else
     2871:        11:       Array.unsafe_get vs x in
     2872:        12:   go 0 (Array.length xs - 1) tab k def
     2873:        13: 
     2874:        14: (* 12-6-6-bit (0xfff-0x3f-0x3f) trie, 3 levels, array-array-string.
     2875:        15:    Root is variable; lower levels are either empty or complete. *)
     2876:        16: let find_t ~def k tab =
     2877:        17:   let k = if k > 0xd7ff then k - 0x800 else k in (* Pack to continuous range. *)
     2878:        18:   let b0 = (k lsr 12) land 0xfff in
     2879:        19:   if Array.length tab <= b0 then def else
     2880:        20:   match Array.unsafe_get tab b0 with
     2881:        21:   | [||] -> def
     2882:        22:   | arr -> match Array.unsafe_get arr ((k lsr 6) land 0x3f) with
     2883:        23:     | "" -> def
     2884:        24:     | str -> String.unsafe_get str (k land 0x3f) |> Char.code
     2885:        25: 
     2886:        26: (* We catch w = -1 and default to w = 1 to minimize the table. *)
     2887:        27: let tty_width_hint u = match Uchar.to_int u with
     2888:        28: | 0 -> 0
     2889:        29: | u when u <= 0x001F || 0x007F <= u && u <= 0x009F -> -1
     2890:        30: | u when u <= 0x02ff -> 1
     2891:        31: | u -> find_i ~def:1 u Notty_uucp_data.tty_width_hint
     2892:        32: 
     2893:        33: let grapheme_cluster_boundary u =
     2894:        34:   find_t ~def:16 (Uchar.to_int u) Notty_uucp_data.grapheme_cluster_boundary
     2895:        35: 
     2896:        36: (* let check () = *)
     2897:        37: (*   let pp_u ppf u = Format.fprintf ppf "u+%04x" (Uchar.to_int u) in *)
     2898:        38: (*   let rec go i u = *)
     2899:        39: (*     let w1 = tty_width_hint u *)
     2900:        40: (*     and w2 = Uucp.Break.tty_width_hint u in *)
     2901:        41: (*     if w1 <> w2 then Format.printf "w: %a here: %d there: %d@." pp_u u w1 w2; *)
     2902:        42: (*     let gc1 = grapheme_cluster_boundary u *)
     2903:        43: (*     and gc2 = Uucp.Break.Low.grapheme_cluster u in *)
     2904:        44: (*     if gc1 <> gc2 then Format.printf "gc: %a here: %d there: %d@." pp_u u gc1 gc2; *)
     2905:        45: (*     if u = Uchar.max then i else go (i + 1) (Uchar.succ u) in *)
     2906:        46: (*   let n = go 1 Uchar.min in *)
     2907:        47: (*   Format.printf "Checked equality for %d code points.@." n *)
     2908:        48: 
     2909: Added regular file ../notty/src/no-uucp/notty_uucp.mli:
     2910:         1: (* Copyright (c) 2020 David Kaloper Meršinjak. All rights reserved.
     2911:         2:    See LICENSE.md. *)
     2912:         3: 
     2913:         4: (* This is a local copy of the (very few) relevant [uucp] properties. *)
     2914:         5: 
     2915:         6: val tty_width_hint : Uchar.t -> int
     2916:         7: (* [Uucp.Break.tty_width_hint]. *)
     2917:         8: 
     2918:         9: val grapheme_cluster_boundary : Uchar.t -> int
     2919:        10: (* [Uucp.Break.Low.grapheme_cluster]. *)
     2920:        11: 
     2921:        12: (* val check : unit -> unit *)
     2922:        13: 
     2923: Added regular file ../notty/src/no-uucp/notty_uucp_data.ml:
     2924:         1: (* Do not edit.
     2925:         2:  *
     2926:         3:  * This module contains select unicode properties extracted from Uucp,
     2927:         4:  * using `./support/gen_unicode_props.ml`.
     2928:         5:  *
     2929:         6:  * Unicode version 13.0.0.
     2930:         7:  *)
     2931:         8: 
     2932:         9: 
     2933:        10: let tty_width_hint =
     2934:        11:   ([|0x0000; 0x0300; 0x0483; 0x0591; 0x05bf; 0x05c1; 0x05c4; 0x05c7; 0x0600;
     2935:        12:      0x0610; 0x061c; 0x064b; 0x0670; 0x06d6; 0x06df; 0x06e7; 0x06ea; 0x070f;
     2936:        13:      0x0711; 0x0730; 0x07a6; 0x07eb; 0x07fd; 0x0816; 0x081b; 0x0825; 0x0829;
     2937:        14:      0x0859; 0x08d3; 0x093a; 0x093c; 0x0941; 0x094d; 0x0951; 0x0962; 0x0981;
     2938:        15:      0x09bc; 0x09c1; 0x09cd; 0x09e2; 0x09fe; 0x0a01; 0x0a3c; 0x0a41; 0x0a47;
     2939:        16:      0x0a4b; 0x0a51; 0x0a70; 0x0a75; 0x0a81; 0x0abc; 0x0ac1; 0x0ac7; 0x0acd;
     2940:        17:      0x0ae2; 0x0afa; 0x0b01; 0x0b3c; 0x0b3f; 0x0b41; 0x0b4d; 0x0b55; 0x0b62;
     2941:        18:      0x0b82; 0x0bc0; 0x0bcd; 0x0c00; 0x0c04; 0x0c3e; 0x0c46; 0x0c4a; 0x0c55;
     2942:        19:      0x0c62; 0x0c81; 0x0cbc; 0x0cbf; 0x0cc6; 0x0ccc; 0x0ce2; 0x0d00; 0x0d3b;
     2943:        20:      0x0d41; 0x0d4d; 0x0d62; 0x0d81; 0x0dca; 0x0dd2; 0x0dd6; 0x0e31; 0x0e34;
     2944:        21:      0x0e47; 0x0eb1; 0x0eb4; 0x0ec8; 0x0f18; 0x0f35; 0x0f37; 0x0f39; 0x0f71;
     2945:        22:      0x0f80; 0x0f86; 0x0f8d; 0x0f99; 0x0fc6; 0x102d; 0x1032; 0x1039; 0x103d;
     2946:        23:      0x1058; 0x105e; 0x1071; 0x1082; 0x1085; 0x108d; 0x109d; 0x1100; 0x135d;
     2947:        24:      0x1712; 0x1732; 0x1752; 0x1772; 0x17b4; 0x17b7; 0x17c6; 0x17c9; 0x17dd;
     2948:        25:      0x180b; 0x1885; 0x18a9; 0x1920; 0x1927; 0x1932; 0x1939; 0x1a17; 0x1a1b;
     2949:        26:      0x1a56; 0x1a58; 0x1a60; 0x1a62; 0x1a65; 0x1a73; 0x1a7f; 0x1ab0; 0x1b00;
     2950:        27:      0x1b34; 0x1b36; 0x1b3c; 0x1b42; 0x1b6b; 0x1b80; 0x1ba2; 0x1ba8; 0x1bab;
     2951:        28:      0x1be6; 0x1be8; 0x1bed; 0x1bef; 0x1c2c; 0x1c36; 0x1cd0; 0x1cd4; 0x1ce2;
     2952:        29:      0x1ced; 0x1cf4; 0x1cf8; 0x1dc0; 0x1dfb; 0x200b; 0x202a; 0x2060; 0x2066;
     2953:        30:      0x20d0; 0x231a; 0x2329; 0x23e9; 0x23f0; 0x23f3; 0x25fd; 0x2614; 0x2648;
     2954:        31:      0x267f; 0x2693; 0x26a1; 0x26aa; 0x26bd; 0x26c4; 0x26ce; 0x26d4; 0x26ea;
     2955:        32:      0x26f2; 0x26f5; 0x26fa; 0x26fd; 0x2705; 0x270a; 0x2728; 0x274c; 0x274e;
     2956:        33:      0x2753; 0x2757; 0x2795; 0x27b0; 0x27bf; 0x2b1b; 0x2b50; 0x2b55; 0x2cef;
     2957:        34:      0x2d7f; 0x2de0; 0x2e80; 0x2e9b; 0x2f00; 0x2ff0; 0x3000; 0x302a; 0x302e;
     2958:        35:      0x3041; 0x3099; 0x309b; 0x3105; 0x3131; 0x3190; 0x31f0; 0x3220; 0x3250;
     2959:        36:      0x4e00; 0xa490; 0xa66f; 0xa674; 0xa69e; 0xa6f0; 0xa802; 0xa806; 0xa80b;
     2960:        37:      0xa825; 0xa82c; 0xa8c4; 0xa8e0; 0xa8ff; 0xa926; 0xa947; 0xa960; 0xa980;
     2961:        38:      0xa9b3; 0xa9b6; 0xa9bc; 0xa9e5; 0xaa29; 0xaa31; 0xaa35; 0xaa43; 0xaa4c;
     2962:        39:      0xaa7c; 0xaab0; 0xaab2; 0xaab7; 0xaabe; 0xaac1; 0xaaec; 0xaaf6; 0xabe5;
     2963:        40:      0xabe8; 0xabed; 0xac00; 0xf900; 0xfb1e; 0xfe00; 0xfe10; 0xfe20; 0xfe30;
     2964:        41:      0xfe54; 0xfe68; 0xfeff; 0xff01; 0xffe0; 0xfff9; 0x101fd; 0x102e0;
     2965:        42:      0x10376; 0x10a01; 0x10a05; 0x10a0c; 0x10a38; 0x10a3f; 0x10ae5; 0x10d24;
     2966:        43:      0x10eab; 0x10f46; 0x11001; 0x11038; 0x1107f; 0x110b3; 0x110b9; 0x110bd;
     2967:        44:      0x110cd; 0x11100; 0x11127; 0x1112d; 0x11173; 0x11180; 0x111b6; 0x111c9;
     2968:        45:      0x111cf; 0x1122f; 0x11234; 0x11236; 0x1123e; 0x112df; 0x112e3; 0x11300;
     2969:        46:      0x1133b; 0x11340; 0x11366; 0x11370; 0x11438; 0x11442; 0x11446; 0x1145e;
     2970:        47:      0x114b3; 0x114ba; 0x114bf; 0x114c2; 0x115b2; 0x115bc; 0x115bf; 0x115dc;
     2971:        48:      0x11633; 0x1163d; 0x1163f; 0x116ab; 0x116ad; 0x116b0; 0x116b7; 0x1171d;
     2972:        49:      0x11722; 0x11727; 0x1182f; 0x11839; 0x1193b; 0x1193e; 0x11943; 0x119d4;
     2973:        50:      0x119da; 0x119e0; 0x11a01; 0x11a33; 0x11a3b; 0x11a47; 0x11a51; 0x11a59;
     2974:        51:      0x11a8a; 0x11a98; 0x11c30; 0x11c38; 0x11c3f; 0x11c92; 0x11caa; 0x11cb2;
     2975:        52:      0x11cb5; 0x11d31; 0x11d3a; 0x11d3c; 0x11d3f; 0x11d47; 0x11d90; 0x11d95;
     2976:        53:      0x11d97; 0x11ef3; 0x13430; 0x16af0; 0x16b30; 0x16f4f; 0x16f8f; 0x16fe0;
     2977:        54:      0x16fe4; 0x16ff0; 0x17000; 0x18800; 0x18d00; 0x1b000; 0x1b150; 0x1b164;
     2978:        55:      0x1b170; 0x1bc9d; 0x1bca0; 0x1d167; 0x1d173; 0x1d185; 0x1d1aa; 0x1d242;
     2979:        56:      0x1da00; 0x1da3b; 0x1da75; 0x1da84; 0x1da9b; 0x1daa1; 0x1e000; 0x1e008;
     2980:        57:      0x1e01b; 0x1e023; 0x1e026; 0x1e130; 0x1e2ec; 0x1e8d0; 0x1e944; 0x1f004;
     2981:        58:      0x1f0cf; 0x1f18e; 0x1f191; 0x1f200; 0x1f210; 0x1f240; 0x1f250; 0x1f260;
     2982:        59:      0x1f300; 0x1f32d; 0x1f337; 0x1f37e; 0x1f3a0; 0x1f3cf; 0x1f3e0; 0x1f3f4;
     2983:        60:      0x1f3f8; 0x1f440; 0x1f442; 0x1f4ff; 0x1f54b; 0x1f550; 0x1f57a; 0x1f595;
     2984:        61:      0x1f5a4; 0x1f5fb; 0x1f680; 0x1f6cc; 0x1f6d0; 0x1f6d5; 0x1f6eb; 0x1f6f4;
     2985:        62:      0x1f7e0; 0x1f90c; 0x1f93c; 0x1f947; 0x1f97a; 0x1f9cd; 0x1fa70; 0x1fa78;
     2986:        63:      0x1fa80; 0x1fa90; 0x1fab0; 0x1fac0; 0x1fad0; 0x20000; 0x30000; 0xe0001;
     2987:        64:      0xe0020; 0xe0100|],
     2988:        65:    [|0x0000; 0x036f; 0x0489; 0x05bd; 0x05bf; 0x05c2; 0x05c5; 0x05c7; 0x0605;
     2989:        66:      0x061a; 0x061c; 0x065f; 0x0670; 0x06dd; 0x06e4; 0x06e8; 0x06ed; 0x070f;
     2990:        67:      0x0711; 0x074a; 0x07b0; 0x07f3; 0x07fd; 0x0819; 0x0823; 0x0827; 0x082d;
     2991:        68:      0x085b; 0x0902; 0x093a; 0x093c; 0x0948; 0x094d; 0x0957; 0x0963; 0x0981;
     2992:        69:      0x09bc; 0x09c4; 0x09cd; 0x09e3; 0x09fe; 0x0a02; 0x0a3c; 0x0a42; 0x0a48;
     2993:        70:      0x0a4d; 0x0a51; 0x0a71; 0x0a75; 0x0a82; 0x0abc; 0x0ac5; 0x0ac8; 0x0acd;
     2994:        71:      0x0ae3; 0x0aff; 0x0b01; 0x0b3c; 0x0b3f; 0x0b44; 0x0b4d; 0x0b56; 0x0b63;
     2995:        72:      0x0b82; 0x0bc0; 0x0bcd; 0x0c00; 0x0c04; 0x0c40; 0x0c48; 0x0c4d; 0x0c56;
     2996:        73:      0x0c63; 0x0c81; 0x0cbc; 0x0cbf; 0x0cc6; 0x0ccd; 0x0ce3; 0x0d01; 0x0d3c;
     2997:        74:      0x0d44; 0x0d4d; 0x0d63; 0x0d81; 0x0dca; 0x0dd4; 0x0dd6; 0x0e31; 0x0e3a;
     2998:        75:      0x0e4e; 0x0eb1; 0x0ebc; 0x0ecd; 0x0f19; 0x0f35; 0x0f37; 0x0f39; 0x0f7e;
     2999:        76:      0x0f84; 0x0f87; 0x0f97; 0x0fbc; 0x0fc6; 0x1030; 0x1037; 0x103a; 0x103e;
     3000:        77:      0x1059; 0x1060; 0x1074; 0x1082; 0x1086; 0x108d; 0x109d; 0x115f; 0x135f;
     3001:        78:      0x1714; 0x1734; 0x1753; 0x1773; 0x17b5; 0x17bd; 0x17c6; 0x17d3; 0x17dd;
     3002:        79:      0x180e; 0x1886; 0x18a9; 0x1922; 0x1928; 0x1932; 0x193b; 0x1a18; 0x1a1b;
     3003:        80:      0x1a56; 0x1a5e; 0x1a60; 0x1a62; 0x1a6c; 0x1a7c; 0x1a7f; 0x1ac0; 0x1b03;
     3004:        81:      0x1b34; 0x1b3a; 0x1b3c; 0x1b42; 0x1b73; 0x1b81; 0x1ba5; 0x1ba9; 0x1bad;
     3005:        82:      0x1be6; 0x1be9; 0x1bed; 0x1bf1; 0x1c33; 0x1c37; 0x1cd2; 0x1ce0; 0x1ce8;
     3006:        83:      0x1ced; 0x1cf4; 0x1cf9; 0x1df9; 0x1dff; 0x200f; 0x202e; 0x2064; 0x206f;
     3007:        84:      0x20f0; 0x231b; 0x232a; 0x23ec; 0x23f0; 0x23f3; 0x25fe; 0x2615; 0x2653;
     3008:        85:      0x267f; 0x2693; 0x26a1; 0x26ab; 0x26be; 0x26c5; 0x26ce; 0x26d4; 0x26ea;
     3009:        86:      0x26f3; 0x26f5; 0x26fa; 0x26fd; 0x2705; 0x270b; 0x2728; 0x274c; 0x274e;
     3010:        87:      0x2755; 0x2757; 0x2797; 0x27b0; 0x27bf; 0x2b1c; 0x2b50; 0x2b55; 0x2cf1;
     3011:        88:      0x2d7f; 0x2dff; 0x2e99; 0x2ef3; 0x2fd5; 0x2ffb; 0x3029; 0x302d; 0x303e;
     3012:        89:      0x3096; 0x309a; 0x30ff; 0x312f; 0x318e; 0x31e3; 0x321e; 0x3247; 0x4dbf;
     3013:        90:      0xa48c; 0xa4c6; 0xa672; 0xa67d; 0xa69f; 0xa6f1; 0xa802; 0xa806; 0xa80b;
     3014:        91:      0xa826; 0xa82c; 0xa8c5; 0xa8f1; 0xa8ff; 0xa92d; 0xa951; 0xa97c; 0xa982;
     3015:        92:      0xa9b3; 0xa9b9; 0xa9bd; 0xa9e5; 0xaa2e; 0xaa32; 0xaa36; 0xaa43; 0xaa4c;
     3016:        93:      0xaa7c; 0xaab0; 0xaab4; 0xaab8; 0xaabf; 0xaac1; 0xaaed; 0xaaf6; 0xabe5;
     3017:        94:      0xabe8; 0xabed; 0xd7a3; 0xfaff; 0xfb1e; 0xfe0f; 0xfe19; 0xfe2f; 0xfe52;
     3018:        95:      0xfe66; 0xfe6b; 0xfeff; 0xff60; 0xffe6; 0xfffb; 0x101fd; 0x102e0;
     3019:        96:      0x1037a; 0x10a03; 0x10a06; 0x10a0f; 0x10a3a; 0x10a3f; 0x10ae6; 0x10d27;
     3020:        97:      0x10eac; 0x10f50; 0x11001; 0x11046; 0x11081; 0x110b6; 0x110ba; 0x110bd;
     3021:        98:      0x110cd; 0x11102; 0x1112b; 0x11134; 0x11173; 0x11181; 0x111be; 0x111cc;
     3022:        99:      0x111cf; 0x11231; 0x11234; 0x11237; 0x1123e; 0x112df; 0x112ea; 0x11301;
     3023:       100:      0x1133c; 0x11340; 0x1136c; 0x11374; 0x1143f; 0x11444; 0x11446; 0x1145e;
     3024:       101:      0x114b8; 0x114ba; 0x114c0; 0x114c3; 0x115b5; 0x115bd; 0x115c0; 0x115dd;
     3025:       102:      0x1163a; 0x1163d; 0x11640; 0x116ab; 0x116ad; 0x116b5; 0x116b7; 0x1171f;
     3026:       103:      0x11725; 0x1172b; 0x11837; 0x1183a; 0x1193c; 0x1193e; 0x11943; 0x119d7;
     3027:       104:      0x119db; 0x119e0; 0x11a0a; 0x11a38; 0x11a3e; 0x11a47; 0x11a56; 0x11a5b;
     3028:       105:      0x11a96; 0x11a99; 0x11c36; 0x11c3d; 0x11c3f; 0x11ca7; 0x11cb0; 0x11cb3;
     3029:       106:      0x11cb6; 0x11d36; 0x11d3a; 0x11d3d; 0x11d45; 0x11d47; 0x11d91; 0x11d95;
     3030:       107:      0x11d97; 0x11ef4; 0x13438; 0x16af4; 0x16b36; 0x16f4f; 0x16f92; 0x16fe3;
     3031:       108:      0x16fe4; 0x16ff1; 0x187f7; 0x18cd5; 0x18d08; 0x1b11e; 0x1b152; 0x1b167;
     3032:       109:      0x1b2fb; 0x1bc9e; 0x1bca3; 0x1d169; 0x1d182; 0x1d18b; 0x1d1ad; 0x1d244;
     3033:       110:      0x1da36; 0x1da6c; 0x1da75; 0x1da84; 0x1da9f; 0x1daaf; 0x1e006; 0x1e018;
     3034:       111:      0x1e021; 0x1e024; 0x1e02a; 0x1e136; 0x1e2ef; 0x1e8d6; 0x1e94a; 0x1f004;
     3035:       112:      0x1f0cf; 0x1f18e; 0x1f19a; 0x1f202; 0x1f23b; 0x1f248; 0x1f251; 0x1f265;
     3036:       113:      0x1f320; 0x1f335; 0x1f37c; 0x1f393; 0x1f3ca; 0x1f3d3; 0x1f3f0; 0x1f3f4;
     3037:       114:      0x1f43e; 0x1f440; 0x1f4fc; 0x1f53d; 0x1f54e; 0x1f567; 0x1f57a; 0x1f596;
     3038:       115:      0x1f5a4; 0x1f64f; 0x1f6c5; 0x1f6cc; 0x1f6d2; 0x1f6d7; 0x1f6ec; 0x1f6fc;
     3039:       116:      0x1f7eb; 0x1f93a; 0x1f945; 0x1f978; 0x1f9cb; 0x1f9ff; 0x1fa74; 0x1fa7a;
     3040:       117:      0x1fa86; 0x1faa8; 0x1fab6; 0x1fac2; 0x1fad6; 0x2fffd; 0x3fffd; 0xe0001;
     3041:       118:      0xe007f; 0xe01ef|],
     3042:       119:    [|0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0;
     3043:       120:      0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0;
     3044:       121:      0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0;
     3045:       122:      0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0;
     3046:       123:      0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 2; 0; 0; 0; 0;
     3047:       124:      0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0;
     3048:       125:      0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0;
     3049:       126:      0; 0; 0; 0; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2;
     3050:       127:      2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 0; 0; 0; 2; 2; 2; 2; 2; 0; 2;
     3051:       128:      2; 0; 2; 2; 2; 2; 2; 2; 2; 2; 2; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0;
     3052:       129:      0; 2; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 2;
     3053:       130:      2; 0; 0; 2; 0; 2; 2; 2; 0; 2; 2; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0;
     3054:       131:      0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0;
     3055:       132:      0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0;
     3056:       133:      0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0;
     3057:       134:      0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 2; 0; 2; 2; 2; 2; 2; 2; 2; 2; 0;
     3058:       135:      0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 2; 2; 2;
     3059:       136:      2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2;
     3060:       137:      2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 0; 0; 0|])
     3061:       138: 
     3062:       139: let s000 = ""
     3063:       140: let s001 = "\000\000\000\000\000\000\000\000\000\000\b\000\000\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
     3064:       141: let s002 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\000"
     3065:       142: let s003 = "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\016\016\016\016\016\016\016\016\016\016\016\016\016\000\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
     3066:       143: let s004 = "\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002"
     3067:       144: let s005 = "\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
     3068:       145: let s006 = "\016\016\016\002\002\002\002\002\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
     3069:       146: let s007 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\016\002"
     3070:       147: let s008 = "\016\002\002\016\002\002\016\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
     3071:       148: let s009 = "\011\011\011\011\011\011\016\016\016\016\016\016\016\016\016\016\002\002\002\002\002\002\002\002\002\002\002\016\000\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
     3072:       149: let s010 = "\016\016\016\016\016\016\016\016\016\016\016\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
     3073:       150: let s011 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\002\002\002\002\002\011\016\002\002\002\002\002\002\016\016\002\002\016\002\002\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
     3074:       151: let s012 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\011\016\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002"
     3075:       152: let s013 = "\002\002\002\002\002\002\002\002\002\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
     3076:       153: let s014 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\002\002\002\002\002\002\002\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
     3077:       154: let s015 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\002\002\002\002\002\002\002\016\016\016\016\016\016\016\016\016\002\016\016"
     3078:       155: let s016 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\002\002\016\002\002\002\002\002\002\002\002\002\016\002\002\002\016\002\002\002\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
     3079:       156: let s017 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
     3080:       157: let s018 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\011\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002"
     3081:       158: let s019 = "\002\002\002\r\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\r\002\016\r\r"
     3082:       159: let s020 = "\r\002\002\002\002\002\002\002\002\r\r\r\r\002\r\r\016\002\002\002\002\002\002\002\016\016\016\016\016\016\016\016\016\016\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
     3083:       160: let s021 = "\016\002\r\r\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\016\002\r"
     3084:       161: let s022 = "\r\002\002\002\002\016\016\r\r\016\016\r\r\002\016\016\016\016\016\016\016\016\016\002\016\016\016\016\016\016\016\016\016\016\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\016"
     3085:       162: let s023 = "\016\002\002\r\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\016\r\r"
     3086:       163: let s024 = "\r\002\002\016\016\016\016\002\002\016\016\002\002\002\016\016\016\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\016\016\016\002\016\016\016\016\016\016\016\016\016\016"
     3087:       164: let s025 = "\r\002\002\002\002\002\016\002\002\r\016\r\r\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\002\002\002\002"
     3088:       165: let s026 = "\016\002\r\r\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\016\002\002"
     3089:       166: let s027 = "\r\002\002\002\002\016\016\r\r\016\016\r\r\002\016\016\016\016\016\016\016\002\002\002\016\016\016\016\016\016\016\016\016\016\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
     3090:       167: let s028 = "\016\016\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\r"
     3091:       168: let s029 = "\002\r\r\016\016\016\r\r\r\016\r\r\r\002\016\016\016\016\016\016\016\016\016\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
     3092:       169: let s030 = "\002\r\r\r\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002"
     3093:       170: let s031 = "\002\r\r\r\r\016\002\002\002\016\002\002\002\002\016\016\016\016\016\016\016\002\002\016\016\016\016\016\016\016\016\016\016\016\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
     3094:       171: let s032 = "\016\002\r\r\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\016\r\002"
     3095:       172: let s033 = "\r\r\002\r\r\016\002\r\r\016\r\r\002\002\016\016\016\016\016\016\016\002\002\016\016\016\016\016\016\016\016\016\016\016\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
     3096:       173: let s034 = "\002\002\r\r\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\016\002\r"
     3097:       174: let s035 = "\r\002\002\002\002\016\r\r\r\016\r\r\r\002\011\016\016\016\016\016\016\016\016\002\016\016\016\016\016\016\016\016\016\016\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
     3098:       175: let s036 = "\016\002\r\r\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
     3099:       176: let s037 = "\016\016\016\016\016\016\016\016\016\016\002\016\016\016\016\002\r\r\002\002\002\016\002\016\r\r\r\r\r\r\r\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\r\r\016\016\016\016\016\016\016\016\016\016\016\016"
     3100:       177: let s038 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\016\r\002\002\002\002\002\002\002\016\016\016\016\016"
     3101:       178: let s039 = "\016\016\016\016\016\016\016\002\002\002\002\002\002\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
     3102:       179: let s040 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\016\r\002\002\002\002\002\002\002\002\002\016\016\016"
     3103:       180: let s041 = "\016\016\016\016\016\016\016\016\002\002\002\002\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
     3104:       181: let s042 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\016\002\016\002\016\016\016\016\r\r"
     3105:       182: let s043 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\002\002\002\002\002\002\002\002\002\002\002\002\r"
     3106:       183: let s044 = "\002\002\002\002\002\016\002\002\016\016\016\016\016\002\002\002\002\002\002\002\002\002\002\002\016\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\016\016\016"
     3107:       184: let s045 = "\016\016\016\016\016\016\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
     3108:       185: let s046 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\002\002\r\002\002\002\002\002\002\016\002\002\r\r\002\002\016"
     3109:       186: let s047 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\r\r\002\002\016\016\016\016\002\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\002\002\016\016\016\016\016\016\016\016\016\016\016"
     3110:       187: let s048 = "\016\016\002\016\r\002\002\016\016\016\016\016\016\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
     3111:       188: let s049 = "\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007"
     3112:       189: let s050 = "\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\015\015\015\015\015\015\015\015\015\015\015\015\015\015\015\015\015\015\015\015\015\015\015\015\015\015\015\015\015\015\015\015"
     3113:       190: let s051 = "\015\015\015\015\015\015\015\015\015\015\015\015\015\015\015\015\015\015\015\015\015\015\015\015\015\015\015\015\015\015\015\015\015\015\015\015\015\015\015\015\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014"
     3114:       191: let s052 = "\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014"
     3115:       192: let s053 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
     3116:       193: let s054 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\002\016\016\016\016\016\016\016\016\016\016\016"
     3117:       194: let s055 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\016\016\016\016\016\016\016\016\016\016\016\016"
     3118:       195: let s056 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\r\002\002\002\002\002\002\002\r\r"
     3119:       196: let s057 = "\r\r\r\r\r\r\002\r\r\002\002\002\002\002\002\002\002\002\002\002\016\016\016\016\016\016\016\016\016\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
     3120:       197: let s058 = "\016\016\016\016\016\016\016\016\016\016\016\002\002\002\000\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
     3121:       198: let s059 = "\016\016\016\016\016\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
     3122:       199: let s060 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\002\r\r\r\r\002\002\r\r\r\016\016\016\016\r\r\002\r\r\r\r\r\r\002\002\002\016\016\016\016"
     3123:       200: let s061 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\r\r\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
     3124:       201: let s062 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\r\002\r\002\002\002\002\002\002\002\016\002\016\002\016\016\002\002\002\002\002\002\002\002\r\r\r\r\r\r\002\002\002\002\002\002\002\002\002\002\016\016\002"
     3125:       202: let s063 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002"
     3126:       203: let s064 = "\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
     3127:       204: let s065 = "\002\002\002\002\r\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\002\002\002\002\002\r\002\r\r\r"
     3128:       205: let s066 = "\r\r\002\r\r\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\002\002\002\002\002\002\002\016\016\016\016\016\016\016\016\016\016\016\016"
     3129:       206: let s067 = "\002\002\r\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\r\002\002\002\002\r\r\002\002\r\002\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
     3130:       207: let s068 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\r\002\002\r\r\r\002\r\002\002\002\r\r\016\016\016\016\016\016\016\016\016\016\016\016"
     3131:       208: let s069 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\r\r\r\r\r\r\r\r\002\002\002\002\002\002\002\002\r\r\002\002\016\016\016\016\016\016\016\016"
     3132:       209: let s070 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\002\016\002\002\002\002\002\002\002\002\002\002\002\002\002\r\002\002\002\002\002\002\002\016\016\016\016\002\016\016\016\016\016\016\002\016\016\r\002\002\016\016\016\016\016\016"
     3133:       210: let s071 = "\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\016\002\002\002\002\002"
     3134:       211: let s072 = "\016\016\016\016\016\016\016\016\016\016\016\000\002\017\000\000\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\000\000\000\000\000\000\000\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
     3135:       212: let s073 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
     3136:       213: let s074 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
     3137:       214: let s075 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
     3138:       215: let s076 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002"
     3139:       216: let s077 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002"
     3140:       217: let s078 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\002\002\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
     3141:       218: let s079 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
     3142:       219: let s080 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\002\002\016\002\002\002\002\002\002\002\002\002\002\016\016"
     3143:       220: let s081 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
     3144:       221: let s082 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
     3145:       222: let s083 = "\016\016\002\016\016\016\002\016\016\016\016\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\r\r\002\002\r\016\016\016\016\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
     3146:       223: let s084 = "\r\r\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\r\r\r\r\r\r\r\r\r\r\r\r"
     3147:       224: let s085 = "\r\r\r\r\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\002"
     3148:       225: let s086 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\002\002\002\002\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
     3149:       226: let s087 = "\016\016\016\016\016\016\016\002\002\002\002\002\002\002\002\002\002\002\r\r\016\016\016\016\016\016\016\016\016\016\016\016\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\016\016\016"
     3150:       227: let s088 = "\002\002\002\r\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\r\r\002\002\002\002\r\r\002\002\r\r"
     3151:       228: let s089 = "\r\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
     3152:       229: let s090 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\002\002\002\002\r\r\002\002\r\r\002\002\016\016\016\016\016\016\016\016\016"
     3153:       230: let s091 = "\016\016\016\002\016\016\016\016\016\016\016\016\002\r\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\016\016\016"
     3154:       231: let s092 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\016\002\002\002\016\016\002\002\016\016\016\016\016\002\002"
     3155:       232: let s093 = "\016\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\r\002\002\r\r\016\016\016\016\016\r\002\016\016\016\016\016\016\016\016\016"
     3156:       233: let s094 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\r\r\002\r\r\002\r\r\016\r\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
     3157:       234: let s095 = "\t\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\t\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\t\n\n\n\n\n\n\n"
     3158:       235: let s096 = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\t\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\t\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
     3159:       236: let s097 = "\n\n\n\n\n\n\n\n\n\n\n\n\t\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\t\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
     3160:       237: let s098 = "\n\n\n\n\t\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\t\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\t\n\n\n"
     3161:       238: let s099 = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\t\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\t\n\n\n\n\n\n\n\n\n\n\n"
     3162:       239: let s100 = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\t\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\t\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
     3163:       240: let s101 = "\n\n\n\n\n\n\n\n\t\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\t\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
     3164:       241: let s102 = "\n\n\n\n\n\n\n\n\t\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\016\016\016\016\016\016\016\016\016\016\016\016\015\015\015\015\015\015\015\015\015\015\015\015\015\015\015\015"
     3165:       242: let s103 = "\015\015\015\015\015\015\015\016\016\016\016\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\016\016\016\016"
     3166:       243: let s104 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
     3167:       244: let s105 = "\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
     3168:       245: let s106 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\000\000\000\000\000\000\000\000\000\000\000\000\016\016\016\016"
     3169:       246: let s107 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\016\016"
     3170:       247: let s108 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
     3171:       248: let s109 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\002\002\002\016\016\016\016\016"
     3172:       249: let s110 = "\016\002\002\002\016\002\002\016\016\016\016\016\002\002\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\002\016\016\016\016\002"
     3173:       250: let s111 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
     3174:       251: let s112 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
     3175:       252: let s113 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
     3176:       253: let s114 = "\016\016\016\016\016\016\002\002\002\002\002\002\002\002\002\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
     3177:       254: let s115 = "\r\002\r\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\002\002\002\002\002\002"
     3178:       255: let s116 = "\002\002\002\002\002\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002"
     3179:       256: let s117 = "\002\002\r\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\r\r\r\002\002\002\002\r\r\002\002\016\016\011\016\016"
     3180:       257: let s118 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\011\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
     3181:       258: let s119 = "\002\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\002\002\002\r\002\002\002\002\002\002\002\002\016\016\016\016\016\016\016\016\016\016\016"
     3182:       259: let s120 = "\016\016\016\016\016\r\r\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\016\016\016\016\016\016\016\016\016\016\016\016"
     3183:       260: let s121 = "\002\002\r\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\r\r\r\002\002\002\002\002\002\002\002\002\r"
     3184:       261: let s122 = "\r\016\011\011\016\016\016\016\016\002\002\002\002\016\r\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
     3185:       262: let s123 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\r\r\r\002\002\002\r\r\002\r\002\002\016\016\016\016\016\016\002\016"
     3186:       263: let s124 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\r\r\r\002\002\002\002\002\002\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
     3187:       264: let s125 = "\002\r\r\r\r\016\016\r\r\016\016\r\r\r\016\016\016\016\016\016\016\016\016\002\016\016\016\016\016\016\016\016\016\016\r\r\016\016\002\002\002\002\002\002\002\016\016\016\002\002\002\002\002\016\016\016\016\016\016\016\016\016\016\016"
     3188:       265: let s126 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\r\r\r\002\002\002\002\002\002\002\002"
     3189:       266: let s127 = "\r\r\002\002\002\r\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
     3190:       267: let s128 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\r\r\002\002\002\002\002\002\r\002\r\r\002\r\002"
     3191:       268: let s129 = "\002\r\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
     3192:       269: let s130 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\r\r\002\002\002\002\016\016\r\r\r\r\002\002\r\002"
     3193:       270: let s131 = "\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
     3194:       271: let s132 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\r\r\r\002\002\002\002\002\002\002\002\r\r\002\r\002"
     3195:       272: let s133 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\r\002\r\r\002\002\002\002\002\002\r\002\016\016\016\016\016\016\016\016"
     3196:       273: let s134 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\002\r\r\002\002\002\002\r\002\002\002\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
     3197:       274: let s135 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\r\r\r\002\002\002\002\002\002\002\002\002\r\002\002\016\016\016\016\016"
     3198:       275: let s136 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\r\r\r\r\r\016\r\r\016\016\002\002\r\002\011"
     3199:       276: let s137 = "\r\011\r\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
     3200:       277: let s138 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\r\r\r\002\002\002\002\016\016\002\002\r\r\r\r\002\016\016\016\r\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
     3201:       278: let s139 = "\016\002\002\002\002\002\002\002\002\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\002\002\002\002\r\011\002\002\002\002\016"
     3202:       279: let s140 = "\016\016\016\016\016\016\016\002\016\016\016\016\016\016\016\016\016\002\002\002\002\002\002\r\r\002\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
     3203:       280: let s141 = "\016\016\016\016\011\011\011\011\011\011\002\002\002\002\002\002\002\002\002\002\002\002\002\r\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
     3204:       281: let s142 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\r\002\002\002\002\002\002\002\016\002\002\002\002\002\002\r\002"
     3205:       282: let s143 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\016\r\002\002\002\002\002\002\002\r\002\002\r\002\002\016\016\016\016\016\016\016\016\016"
     3206:       283: let s144 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\002\002\002\002\016\016\016\002\016\002\002\016\002"
     3207:       284: let s145 = "\002\002\002\002\002\002\011\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
     3208:       285: let s146 = "\016\016\016\016\016\016\016\016\016\016\r\r\r\r\r\016\002\002\016\r\r\002\r\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
     3209:       286: let s147 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\r\r\016\016\016\016\016\016\016\016\016"
     3210:       287: let s148 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\000\000\000\000\000\000\000\000\000\016\016\016\016\016\016\016"
     3211:       288: let s149 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\002\002\002\016\016\016\016\016\016\016\016\016\016\016"
     3212:       289: let s150 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\002\002\002\002\002\016\016\016\016\016\016\016\016\016"
     3213:       290: let s151 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\016\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r"
     3214:       291: let s152 = "\r\r\r\r\r\r\r\r\016\016\016\016\016\016\016\002\002\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
     3215:       292: let s153 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\016\016\016\016\016\016\016\016\016\016\016\r\r\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
     3216:       293: let s154 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\016\000\000\000\000\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
     3217:       294: let s155 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\r\002\002\002\016\016\016\r\002\002\002\002\002\000\000\000\000\000\000\000\000\002\002\002\002\002"
     3218:       295: let s156 = "\002\002\002\016\016\002\002\002\002\002\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
     3219:       296: let s157 = "\016\016\002\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
     3220:       297: let s158 = "\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\016\016\016\016\002\002\002\002\002"
     3221:       298: let s159 = "\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\016\016\016\016\016\016\016\016\002\016\016\016\016\016\016\016\016\016\016"
     3222:       299: let s160 = "\016\016\016\016\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\002\002\002\016\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
     3223:       300: let s161 = "\002\002\002\002\002\002\002\016\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\016\016\002\002\002\002\002\002\002\016\002\002\016\002\002\002\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
     3224:       301: let s162 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
     3225:       302: let s163 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\002\002\002\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
     3226:       303: let s164 = "\016\016\016\016\002\002\002\002\002\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
     3227:       304: let s165 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\012\012\012\012\012\012\012\012\012\012\012\012\012\012\012\012\012\012\012\012\012\012\012\012\012\012"
     3228:       305: let s166 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\002\002\002"
     3229:       306: let s167 = "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002"
     3230:       307: let s168 = "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
     3231:       308: let s169 = "\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
     3232:       309: 
     3233:       310: let grapheme_cluster_boundary =
     3234:       311:   [|[|s001; s002; s003; s000; s000; s000; s000; s000; s000; s000; s000; s000;
     3235:       312:       s004; s005; s000; s000; s000; s000; s006; s000; s000; s000; s007; s008;
     3236:       313:       s009; s010; s000; s011; s012; s013; s014; s015; s016; s017; s000; s018;
     3237:       314:       s019; s020; s021; s022; s023; s024; s023; s025; s026; s027; s028; s029;
     3238:       315:       s030; s031; s032; s033; s034; s035; s036; s037; s038; s039; s040; s041;
     3239:       316:       s042; s043; s044; s045|];
     3240:       317:     [|s046; s047; s048; s000; s049; s050; s051; s052; s000; s000; s000; s000;
     3241:       318:       s000; s053; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000;
     3242:       319:       s000; s000; s000; s000; s054; s055; s056; s057; s058; s000; s059; s000;
     3243:       320:       s060; s000; s000; s000; s061; s062; s063; s064; s065; s066; s067; s068;
     3244:       321:       s069; s000; s000; s070; s000; s000; s000; s071; s000; s000; s000; s000;
     3245:       322:       s000; s000; s000; s000|];
     3246:       323:     [|s072; s073; s000; s074; s000; s000; s000; s000; s000; s000; s000; s000;
     3247:       324:       s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000;
     3248:       325:       s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000;
     3249:       326:       s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000;
     3250:       327:       s000; s000; s000; s075; s000; s076; s000; s077; s000; s000; s000; s000;
     3251:       328:       s000; s000; s000; s000|];
     3252:       329:     [|s078; s000; s079; s000; s000; s000; s000; s000; s000; s000; s000; s000;
     3253:       330:       s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000;
     3254:       331:       s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000;
     3255:       332:       s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000;
     3256:       333:       s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000;
     3257:       334:       s000; s000; s000; s000|];
     3258:       335:     [||]; [||]; [||]; [||]; [||]; [||];
     3259:       336:     [|s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000;
     3260:       337:       s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000;
     3261:       338:       s000; s080; s081; s082; s000; s000; s000; s000; s083; s000; s084; s085;
     3262:       339:       s086; s087; s088; s089; s090; s091; s092; s093; s000; s000; s000; s094;
     3263:       340:       s095; s096; s097; s098; s099; s100; s101; s095; s096; s097; s098; s099;
     3264:       341:       s100; s101; s095; s096|];
     3265:       342:     [|s097; s098; s099; s100; s101; s095; s096; s097; s098; s099; s100; s101;
     3266:       343:       s095; s096; s097; s098; s099; s100; s101; s095; s096; s097; s098; s099;
     3267:       344:       s100; s101; s095; s096; s097; s098; s099; s100; s101; s095; s096; s097;
     3268:       345:       s098; s099; s100; s101; s095; s096; s097; s098; s099; s100; s101; s095;
     3269:       346:       s096; s097; s098; s099; s100; s101; s095; s096; s097; s098; s099; s100;
     3270:       347:       s101; s095; s096; s097|];
     3271:       348:     [|s098; s099; s100; s101; s095; s096; s097; s098; s099; s100; s101; s095;
     3272:       349:       s096; s097; s098; s099; s100; s101; s095; s096; s097; s098; s099; s100;
     3273:       350:       s101; s095; s096; s097; s098; s099; s100; s101; s095; s096; s097; s098;
     3274:       351:       s099; s100; s101; s095; s096; s097; s098; s099; s100; s101; s095; s096;
     3275:       352:       s097; s098; s099; s100; s101; s095; s096; s097; s098; s099; s100; s101;
     3276:       353:       s095; s096; s097; s098|];
     3277:       354:     [|s099; s100; s101; s095; s096; s097; s098; s099; s100; s101; s095; s096;
     3278:       355:       s097; s098; s099; s100; s101; s095; s096; s097; s098; s099; s100; s101;
     3279:       356:       s095; s096; s097; s098; s099; s100; s102; s103; s000; s000; s000; s000;
     3280:       357:       s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000;
     3281:       358:       s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000;
     3282:       359:       s000; s000; s000; s000|];
     3283:       360:     [||];
     3284:       361:     [|s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000;
     3285:       362:       s104; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000;
     3286:       363:       s105; s000; s000; s002; s000; s000; s081; s106; s000; s000; s000; s000;
     3287:       364:       s000; s000; s000; s107; s000; s000; s000; s108; s000; s109; s000; s000;
     3288:       365:       s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000;
     3289:       366:       s000; s000; s000; s000|];
     3290:       367:     [|s000; s000; s000; s000; s000; s000; s000; s000; s110; s000; s000; s111;
     3291:       368:       s000; s000; s000; s000; s000; s000; s000; s000; s112; s000; s000; s000;
     3292:       369:       s000; s000; s113; s000; s000; s114; s000; s000; s115; s116; s117; s118;
     3293:       370:       s119; s120; s121; s122; s123; s000; s000; s124; s034; s125; s000; s000;
     3294:       371:       s126; s127; s128; s129; s000; s000; s130; s131; s132; s064; s133; s000;
     3295:       372:       s134; s000; s000; s000|];
     3296:       373:     [|s135; s000; s000; s000; s136; s137; s000; s138; s139; s140; s141; s000;
     3297:       374:       s000; s000; s000; s000; s142; s000; s143; s000; s144; s145; s146; s000;
     3298:       375:       s000; s000; s000; s147; s000; s000; s000; s000; s000; s000; s000; s000;
     3299:       376:       s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000;
     3300:       377:       s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000;
     3301:       378:       s000; s000; s000; s000|];
     3302:       379:     [|s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000;
     3303:       380:       s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000;
     3304:       381:       s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000;
     3305:       382:       s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000;
     3306:       383:       s148; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000;
     3307:       384:       s000; s000; s000; s000|];
     3308:       385:     [||]; [||]; [||];
     3309:       386:     [|s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s149;
     3310:       387:       s150; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000;
     3311:       388:       s000; s000; s000; s000; s000; s151; s152; s153; s000; s000; s000; s000;
     3312:       389:       s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000;
     3313:       390:       s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000;
     3314:       391:       s000; s000; s000; s000|];
     3315:       392:     [||]; [||]; [||]; [||];
     3316:       393:     [|s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000;
     3317:       394:       s000; s000; s000; s000; s000; s000; s154; s000; s000; s000; s000; s000;
     3318:       395:       s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000;
     3319:       396:       s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000;
     3320:       397:       s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000;
     3321:       398:       s000; s000; s000; s000|];
     3322:       399:     [|s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000;
     3323:       400:       s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000;
     3324:       401:       s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000;
     3325:       402:       s000; s155; s156; s000; s000; s157; s000; s000; s000; s000; s000; s000;
     3326:       403:       s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000;
     3327:       404:       s000; s000; s000; s000|];
     3328:       405:     [|s000; s000; s000; s000; s000; s000; s000; s000; s158; s159; s160; s000;
     3329:       406:       s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000;
     3330:       407:       s000; s000; s000; s000; s000; s000; s000; s000; s161; s000; s000; s000;
     3331:       408:       s150; s000; s000; s000; s000; s000; s000; s162; s000; s000; s000; s000;
     3332:       409:       s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000;
     3333:       410:       s000; s000; s000; s000|];
     3334:       411:     [|s000; s000; s000; s163; s000; s164; s000; s000; s000; s000; s000; s000;
     3335:       412:       s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000;
     3336:       413:       s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000;
     3337:       414:       s000; s000; s000; s165; s000; s000; s000; s000; s000; s000; s000; s166;
     3338:       415:       s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000;
     3339:       416:       s000; s000; s000; s000|];
     3340:       417:     [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; 
     3341:       418:     [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; 
     3342:       419:     [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; 
     3343:       420:     [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; 
     3344:       421:     [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; 
     3345:       422:     [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; 
     3346:       423:     [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; 
     3347:       424:     [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; 
     3348:       425:     [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; 
     3349:       426:     [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; 
     3350:       427:     [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; 
     3351:       428:     [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; 
     3352:       429:     [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; 
     3353:       430:     [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; 
     3354:       431:     [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; 
     3355:       432:     [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; 
     3356:       433:     [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; 
     3357:       434:     [||]; [||]; [||]; [||]; [||];
     3358:       435:     [|s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000;
     3359:       436:       s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000;
     3360:       437:       s000; s000; s000; s000; s000; s000; s000; s000; s167; s004; s168; s168;
     3361:       438:       s004; s004; s004; s169; s168; s168; s168; s168; s168; s168; s168; s168;
     3362:       439:       s168; s168; s168; s168; s168; s168; s168; s168; s168; s168; s168; s168;
     3363:       440:       s168; s168; s168; s168|];
     3364:       441:     [|s168; s168; s168; s168; s168; s168; s168; s168; s168; s168; s168; s168;
     3365:       442:       s168; s168; s168; s168; s168; s168; s168; s168; s168; s168; s168; s168;
     3366:       443:       s168; s168; s168; s168; s168; s168; s168; s168; s000; s000; s000; s000;
     3367:       444:       s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000;
     3368:       445:       s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000;
     3369:       446:       s000; s000; s000; s000|]|]
     3370: Added regular file ../notty/src/no-uucp/notty_uucp_data.mli:
     3371:         1: (* Do not edit.
     3372:         2:  *
     3373:         3:  * This module contains select unicode properties extracted from Uucp,
     3374:         4:  * using `./support/gen_unicode_props.ml`.
     3375:         5:  *
     3376:         6:  * Unicode version 13.0.0.
     3377:         7:  *)
     3378:         8: 
     3379:         9: (* Uucp.Break.tty_width_hint *)
     3380:        10: val tty_width_hint: int array * int array * int array
     3381:        11: 
     3382:        12: (* Uucp.Break.Low.grapheme_cluster. *)
     3383:        13: val grapheme_cluster_boundary: string array array
     3384:        14: 
     3385: Added regular file ../notty/src/notty.ml:
     3386:         1: (* Copyright (c) 2016-2017 David Kaloper Meršinjak. All rights reserved.
     3387:         2:    See LICENSE.md. *)
     3388:         3: 
     3389:         4: let invalid_arg fmt = Format.kasprintf invalid_arg fmt
     3390:         5: 
     3391:         6: let (&.) f g x = f (g x)
     3392:         7: 
     3393:         8: let btw (x : int) a b = a <= x && x <= b
     3394:         9: let bit n b = b land (1 lsl n) > 0
     3395:        10: 
     3396:        11: let max (a : int) b = if a > b then a else b
     3397:        12: let min (a : int) b = if a < b then a else b
     3398:        13: 
     3399:        14: let is_C0 x = x < 0x20 || x = 0x7f
     3400:        15: and is_C1 x = 0x80 <= x && x < 0xa0
     3401:        16: let is_ctrl x = is_C0 x || is_C1 x
     3402:        17: and is_ascii x = x < 0x80
     3403:        18: 
     3404:        19: let rec concatm z (@) xs =
     3405:        20:   let rec accum (@) = function
     3406:        21:     | []|[_] as xs -> xs
     3407:        22:     | a::b::xs -> (a @ b) :: accum (@) xs in
     3408:        23:   match xs with [] -> z | [x] -> x | xs -> concatm z (@) (accum (@) xs)
     3409:        24: 
     3410:        25: let rec linspcm z (@) x n f = match n with
     3411:        26:   | 0 -> z
     3412:        27:   | 1 -> f x
     3413:        28:   | _ -> let m = n / 2 in linspcm z (@) x m f @ linspcm z (@) (x + m) (n - m) f
     3414:        29: 
     3415:        30: let memo (type a) ?(hash=Hashtbl.hash) ?(eq=(=)) ~size f =
     3416:        31:   let module H = Ephemeron.K1.Make
     3417:        32:     (struct type t = a let (hash, equal) = (hash, eq) end) in
     3418:        33:   let t = H.create size in fun x ->
     3419:        34:     try H.find t x with Not_found -> let y = f x in H.add t x y; y
     3420:        35: 
     3421:        36: module Buffer = struct
     3422:        37:   include Buffer
     3423:        38:   let buf = Buffer.create 1024
     3424:        39:   let mkstring f = f buf; let res = contents buf in reset buf; res
     3425:        40:   let add_decimal b = function
     3426:        41:     | x when btw x 0 999 ->
     3427:        42:         let d1 = x / 100 and d2 = (x mod 100) / 10 and d3 = x mod 10 in
     3428:        43:         if d1 > 0 then 0x30 + d1 |> Char.unsafe_chr |> add_char b;
     3429:        44:         if (d1 + d2) > 0 then 0x30 + d2 |> Char.unsafe_chr |> add_char b;
     3430:        45:         0x30 + d3 |> Char.unsafe_chr |> add_char b
     3431:        46:     | x -> string_of_int x |> add_string b
     3432:        47:   let add_chars b c n = for _ = 1 to n do add_char b c done
     3433:        48: end
     3434:        49: 
     3435:        50: module String = struct
     3436:        51:   include String
     3437:        52:   let sub0cp s i len = if i > 0 || len < length s then sub s i len else s
     3438:        53:   let of_chars_rev = function
     3439:        54:     | []  -> ""
     3440:        55:     | [c] -> String.make 1 c
     3441:        56:     | cs  ->
     3442:        57:         let n = List.length cs in
     3443:        58:         let rec go bs i = Bytes.(function
     3444:        59:           | []    -> unsafe_to_string bs
     3445:        60:           | x::xs -> unsafe_set bs i x; go bs (pred i) xs
     3446:        61:         ) in go (Bytes.create n) (n - 1) cs
     3447:        62: end
     3448:        63: 
     3449:        64: module Option = struct
     3450:        65: 
     3451:        66:   let map f = function Some x -> Some (f x) | _ -> None
     3452:        67:   let get def = function Some x -> x | _ -> def
     3453:        68:   let to_list = function Some x -> [x] | _ -> []
     3454:        69:   let (>>|) a f = map f a
     3455:        70:   let (>>=) a f = match a with Some x -> f x | _ -> None
     3456:        71: end
     3457:        72: 
     3458:        73: module Text = struct
     3459:        74: 
     3460:        75:   let err_ctrl u = invalid_arg "Notty: control char: U+%02X, %S" (Char.code u)
     3461:        76:   let err_malformed = invalid_arg "Notty: malformed UTF-8: %s, %S"
     3462:        77: 
     3463:        78:   type t =
     3464:        79:     | Ascii of string * int * int
     3465:        80:     | Utf8  of string * int array * int * int
     3466:        81: 
     3467:        82:   let equal t1 t2 = match (t1, t2) with
     3468:        83:     | (Utf8 (s1, _, i1, n1), Utf8 (s2, _, i2, n2))
     3469:        84:     | (Ascii (s1, i1, n1), Ascii (s2, i2, n2)) -> i1 = i2 && n1 = n2 && s1 = s2
     3470:        85:     | _ -> false
     3471:        86: 
     3472:        87:   let width = function Utf8 (_, _, _, w) -> w | Ascii (_, _, w)   -> w
     3473:        88: 
     3474:        89:   let empty = Ascii ("", 0, 0)
     3475:        90: 
     3476:        91:   let is_empty t = width t = 0
     3477:        92: 
     3478:        93:   let graphemes str =
     3479:        94:     let module Uuseg = Notty_grapheme_cluster in
     3480:        95:     let seg = Uuseg.create () in
     3481:        96:     let rec f (is, w as acc) i evt =
     3482:        97:       match Uuseg.add seg evt with
     3483:        98:       | `Await | `End -> acc
     3484:        99:       | `Uchar u      -> f (is, w + Notty_uucp.tty_width_hint u) i `Await
     3485:       100:       | `Boundary     ->
     3486:       101:           let is = match w with 0 -> is | 1 -> i::is | _ -> i::(-1)::is in
     3487:       102:           f (is, 0) i `Await in
     3488:       103:     let acc = Uutf.String.fold_utf_8 (fun acc i -> function
     3489:       104:       | `Malformed err -> err_malformed err str
     3490:       105:       | `Uchar _ as u  -> f acc i u
     3491:       106:       ) ([0], 0) str in
     3492:       107:     f acc (String.length str) `End |> fst |> List.rev |> Array.of_list (*XXX*)
     3493:       108: 
     3494:       109:   let dead = ' '
     3495:       110: 
     3496:       111:   let to_buffer buf = function
     3497:       112:     | Ascii (s, off, w)    -> Buffer.add_substring buf s off w
     3498:       113:     | Utf8 (s, ix, off, w) ->
     3499:       114:         let x1 = match ix.(off) with
     3500:       115:           | -1 -> Buffer.add_char buf dead; ix.(off + 1) | x -> x
     3501:       116:         and x2 = ix.(off + w) in
     3502:       117:         Buffer.add_substring buf s x1 @@
     3503:       118:           (if x2 = -1 then ix.(off + w - 1) else x2) - x1;
     3504:       119:         if x2 = -1 then Buffer.add_char buf dead
     3505:       120: 
     3506:       121:   let sub t x w =
     3507:       122:     let w1 = width t in
     3508:       123:     if w = 0 || x >= w1 then empty else
     3509:       124:       let w = min w (w1 - x) in
     3510:       125:       if w = w1 then t else match t with
     3511:       126:         Ascii (s, off, _) -> Ascii (s, off + x, w)
     3512:       127:       | Utf8 (s, ix, off, _) -> Utf8 (s, ix, off + x, w)
     3513:       128: 
     3514:       129:   let is_ascii_or_raise_ctrl s =
     3515:       130:     let (@!) s i = String.unsafe_get s i |> Char.code in
     3516:       131:     let rec go s acc i n =
     3517:       132:       if n = 0 then acc else
     3518:       133:         let x = s @! i in
     3519:       134:         if is_C0 x then
     3520:       135:           err_ctrl s.[i] s
     3521:       136:         else if x = 0xc2 && n > 1 && is_C1 (s @! (i + 1)) then
     3522:       137:           err_ctrl s.[i + 1] s
     3523:       138:         else go s (acc && is_ascii x) (i + 1) (n - 1) in
     3524:       139:     go s true 0 (String.length s)
     3525:       140: 
     3526:       141:   let of_ascii s = Ascii (s, 0, String.length s)
     3527:       142:   and of_unicode s = let x = graphemes s in Utf8 (s, x, 0, Array.length x - 1)
     3528:       143:   let of_unicode = memo ~eq:String.equal ~size:128 of_unicode
     3529:       144: 
     3530:       145:   let of_string = function
     3531:       146:     | "" -> empty
     3532:       147:     | s  -> if is_ascii_or_raise_ctrl s then of_ascii s else of_unicode s
     3533:       148: 
     3534:       149:   let of_uchars ucs = of_string @@ Buffer.mkstring @@ fun buf ->
     3535:       150:     Array.iter (Buffer.add_utf_8_uchar buf) ucs
     3536:       151: 
     3537:       152:   let replicateu w u =
     3538:       153:     if is_ctrl (Uchar.to_int u) then
     3539:       154:       err_ctrl (Uchar.unsafe_to_char u) "<repeated character>"
     3540:       155:     else if w < 1 then empty
     3541:       156:     else if is_ascii (Uchar.to_int u) then
     3542:       157:       of_ascii (String.make w (Uchar.unsafe_to_char u))
     3543:       158:     else of_unicode @@ Buffer.mkstring @@ fun buf ->
     3544:       159:       for _ = 1 to w do Buffer.add_utf_8_uchar buf u done
     3545:       160: 
     3546:       161:   let replicatec w c = replicateu w (Uchar.of_char c)
     3547:       162: end
     3548:       163: 
     3549:       164: module A = struct
     3550:       165: 
     3551:       166:   type color = int
     3552:       167:   type style = int
     3553:       168:   type t = { fg : color; bg : color; st : style }
     3554:       169: 
     3555:       170:   let equal t1 t2 = t1.fg = t2.fg && t1.bg = t2.bg && t1.st = t2.st
     3556:       171:   let unsafe_color_of_int int= int
     3557:       172:   let unsafe_style_of_int int= int
     3558:       173: 
     3559:       174:   let black        = 0x01000000
     3560:       175:   and red          = 0x01000001
     3561:       176:   and green        = 0x01000002
     3562:       177:   and yellow       = 0x01000003
     3563:       178:   and blue         = 0x01000004
     3564:       179:   and magenta      = 0x01000005
     3565:       180:   and cyan         = 0x01000006
     3566:       181:   and white        = 0x01000007
     3567:       182:   and lightblack   = 0x01000008
     3568:       183:   and lightred     = 0x01000009
     3569:       184:   and lightgreen   = 0x0100000a
     3570:       185:   and lightyellow  = 0x0100000b
     3571:       186:   and lightblue    = 0x0100000c
     3572:       187:   and lightmagenta = 0x0100000d
     3573:       188:   and lightcyan    = 0x0100000e
     3574:       189:   and lightwhite   = 0x0100000f
     3575:       190: 
     3576:       191:   let tag c = (c land 0x03000000) lsr 24
     3577:       192: 
     3578:       193:   let rgb ~r ~g ~b =
     3579:       194:     if r < 0 || g < 0 || b < 0 || r > 5 || g > 5 || b > 5 then
     3580:       195:       invalid_arg "Notty.A.rgb %d %d %d: channel out of range" r g b
     3581:       196:     else 0x01000000 lor (r * 36 + g * 6 + b + 16)
     3582:       197: 
     3583:       198:   let gray level =
     3584:       199:     if level < 0 || level > 23 then
     3585:       200:       invalid_arg "Notty.A.gray %d: level out of range" level
     3586:       201:     else 0x01000000 lor (level + 232)
     3587:       202: 
     3588:       203:   let rgb_888 ~r ~g ~b =
     3589:       204:     if r < 0 || g < 0 || b < 0 || r > 255 || g > 255 || b > 255 then
     3590:       205:       invalid_arg "Notty.A.rgb_888 %d %d %d: channel out of range" r g b
     3591:       206:     else 0x02000000 lor ((r lsl 16) lor (g lsl 8) lor b)
     3592:       207: 
     3593:       208:   let i x = x land 0xff
     3594:       209:   and r x = x lsr 16 land 0xff
     3595:       210:   and g x = x lsr 8 land 0xff
     3596:       211:   and b x = x land 0xff
     3597:       212: 
     3598:       213:   let bold      = 1
     3599:       214:   and italic    = 2
     3600:       215:   and underline = 4
     3601:       216:   and blink     = 8
     3602:       217:   and reverse   = 16
     3603:       218: 
     3604:       219:   let empty = { fg = 0; bg = 0; st = 0 }
     3605:       220: 
     3606:       221:  let (++) a1 a2 =
     3607:       222:    if a1 == empty then a2 else if a2 == empty then a1 else
     3608:       223:      { fg = (match a2.fg with 0 -> a1.fg | x -> x)
     3609:       224:      ; bg = (match a2.bg with 0 -> a1.bg | x -> x)
     3610:       225:      ; st = a1.st lor a2.st }
     3611:       226: 
     3612:       227:   let fg fg = { empty with fg }
     3613:       228:   let bg bg = { empty with bg }
     3614:       229:   let st st = { empty with st }
     3615:       230: end
     3616:       231: 
     3617:       232: module I = struct
     3618:       233: 
     3619:       234:   type dim = int * int
     3620:       235: 
     3621:       236:   type t =
     3622:       237:     | Empty
     3623:       238:     | Segment  of A.t * Text.t
     3624:       239:     | Hcompose of (t * t) * dim
     3625:       240:     | Vcompose of (t * t) * dim
     3626:       241:     | Zcompose of (t * t) * dim
     3627:       242:     | Hcrop    of (t * int * int) * dim
     3628:       243:     | Vcrop    of (t * int * int) * dim
     3629:       244:     | Void     of dim
     3630:       245: 
     3631:       246:   let width = function
     3632:       247:     | Empty -> 0
     3633:       248:     | Segment (_, text) -> Text.width text
     3634:       249:     | Hcompose (_, (w, _)) -> w
     3635:       250:     | Vcompose (_, (w, _)) -> w
     3636:       251:     | Zcompose (_, (w, _)) -> w
     3637:       252:     | Hcrop    (_, (w, _)) -> w
     3638:       253:     | Vcrop    (_, (w, _)) -> w
     3639:       254:     | Void         (w, _)  -> w [@@inline]
     3640:       255: 
     3641:       256:   let height = function
     3642:       257:     | Empty -> 0
     3643:       258:     | Segment _ -> 1
     3644:       259:     | Hcompose (_, (_, h)) -> h
     3645:       260:     | Vcompose (_, (_, h)) -> h
     3646:       261:     | Zcompose (_, (_, h)) -> h
     3647:       262:     | Hcrop    (_, (_, h)) -> h
     3648:       263:     | Vcrop    (_, (_, h)) -> h
     3649:       264:     | Void         (_, h)  -> h [@@inline]
     3650:       265: 
     3651:       266:   let equal t1 t2 =
     3652:       267:     let rec eq t1 t2 = match (t1, t2) with
     3653:       268:       | (Empty, Empty) -> true
     3654:       269:       | (Segment (a1, t1), Segment (a2, t2)) ->
     3655:       270:           A.equal a1 a2 && Text.equal t1 t2
     3656:       271:       | (Hcompose ((a, b), _), Hcompose ((c, d), _))
     3657:       272:       | (Vcompose ((a, b), _), Vcompose ((c, d), _))
     3658:       273:       | (Zcompose ((a, b), _), Zcompose ((c, d), _)) -> eq a c && eq b d
     3659:       274:       | (Hcrop ((a, i1, n1), _), Hcrop ((b, i2, n2), _))
     3660:       275:       | (Vcrop ((a, i1, n1), _), Vcrop ((b, i2, n2), _)) ->
     3661:       276:           i1 = i2 && n1 = n2 && eq a b
     3662:       277:       | (Void (a, b), Void (c, d)) -> a = c && b = d
     3663:       278:       | _ -> false in
     3664:       279:     width t1 = width t2 && height t1 = height t2 && eq t1 t2
     3665:       280: 
     3666:       281:   let empty = Empty
     3667:       282: 
     3668:       283:   let (<|>) t1 t2 = match (t1, t2) with
     3669:       284:     | (_, Empty) -> t1
     3670:       285:     | (Empty, _) -> t2
     3671:       286:     | _          ->
     3672:       287:         let w = width t1 + width t2
     3673:       288:         and h = max (height t1) (height t2) in
     3674:       289:         Hcompose ((t1, t2), (w, h))
     3675:       290: 
     3676:       291:   let (<->) t1 t2 = match (t1, t2) with
     3677:       292:     | (_, Empty) -> t1
     3678:       293:     | (Empty, _) -> t2
     3679:       294:     | _          ->
     3680:       295:         let w = max (width t1) (width t2)
     3681:       296:         and h = height t1 + height t2 in
     3682:       297:         Vcompose ((t1, t2), (w, h))
     3683:       298: 
     3684:       299:   let (</>) t1 t2 = match (t1, t2) with
     3685:       300:     | (_, Empty) -> t1
     3686:       301:     | (Empty, _) -> t2
     3687:       302:     | _          ->
     3688:       303:         let w = max (width t1) (width t2)
     3689:       304:         and h = max (height t1) (height t2) in
     3690:       305:         Zcompose ((t1, t2), (w, h))
     3691:       306: 
     3692:       307:   let void w h =
     3693:       308:     if w < 1 && h < 1 then Empty else Void (max 0 w, max 0 h)
     3694:       309: 
     3695:       310:   let lincropinv crop void (++) init fini img =
     3696:       311:     match (init >= 0, fini >= 0) with
     3697:       312:     | (true, true) -> crop init fini img
     3698:       313:     | (true, _   ) -> crop init 0 img ++ void (-fini)
     3699:       314:     | (_   , true) -> void (-init) ++ crop 0 fini img
     3700:       315:     | _            -> void (-init) ++ img ++ void (-fini)
     3701:       316: 
     3702:       317:   let hcrop =
     3703:       318:     let ctor left right img =
     3704:       319:       let h = height img and w = width img - left - right in
     3705:       320:       if w > 0 then Hcrop ((img, left, right), (w, h)) else void w h
     3706:       321:     in lincropinv ctor (fun w -> void w 0) (<|>)
     3707:       322: 
     3708:       323:   let vcrop =
     3709:       324:     let ctor top bottom img =
     3710:       325:       let w = width img and h = height img - top - bottom in
     3711:       326:       if h > 0 then Vcrop ((img, top, bottom), (w, h)) else void w h
     3712:       327:     in lincropinv ctor (void 0) (<->)
     3713:       328: 
     3714:       329:   let crop ?(l=0) ?(r=0) ?(t=0) ?(b=0) img =
     3715:       330:     let img = if l <> 0 || r <> 0 then hcrop l r img else img in
     3716:       331:     if t <> 0 || b <> 0 then vcrop t b img else img
     3717:       332: 
     3718:       333:   let hpad left right img = hcrop (-left) (-right) img
     3719:       334: 
     3720:       335:   let vpad top bottom img = vcrop (-top) (-bottom) img
     3721:       336: 
     3722:       337:   let pad ?(l=0) ?(r=0) ?(t=0) ?(b=0) img =
     3723:       338:     crop ~l:(-l) ~r:(-r) ~t:(-t) ~b:(-b) img
     3724:       339: 
     3725:       340:   let hcat = concatm empty (<|>)
     3726:       341: 
     3727:       342:   let vcat = concatm empty (<->)
     3728:       343: 
     3729:       344:   let zcat xs = List.fold_right (</>) xs empty
     3730:       345: 
     3731:       346:   let text attr tx =
     3732:       347:     if Text.is_empty tx then void 0 1 else Segment (attr, tx)
     3733:       348: 
     3734:       349:   let string attr s = text attr (Text.of_string s)
     3735:       350: 
     3736:       351:   let uchars attr a = text attr (Text.of_uchars a)
     3737:       352: 
     3738:       353:   let tabulate m n f =
     3739:       354:     let m = max m 0 and n = max n 0 in
     3740:       355:     linspcm empty (<->) 0 n (fun y -> linspcm empty (<|>) 0 m (fun x -> f x y))
     3741:       356: 
     3742:       357:   let chars ctor attr c w h =
     3743:       358:     if w < 1 || h < 1 then void w h else
     3744:       359:       let line = text attr (ctor w c) in tabulate 1 h (fun _ _ -> line)
     3745:       360: 
     3746:       361:   let char  = chars Text.replicatec
     3747:       362:   let uchar = chars Text.replicateu
     3748:       363: 
     3749:       364:   let hsnap ?(align=`Middle) w img =
     3750:       365:     let off = width img - w in match align with
     3751:       366:       | `Left   -> hcrop 0 off img
     3752:       367:       | `Right  -> hcrop off 0 img
     3753:       368:       | `Middle -> let w1 = off / 2 in hcrop w1 (off - w1) img
     3754:       369: 
     3755:       370:   let vsnap ?(align=`Middle) h img =
     3756:       371:     let off = height img - h in match align with
     3757:       372:       | `Top    -> vcrop 0 off img
     3758:       373:       | `Bottom -> vcrop off 0 img
     3759:       374:       | `Middle -> let h1 = off / 2 in vcrop h1 (off - h1) img
     3760:       375: 
     3761:       376:   module Fmt = struct
     3762:       377: 
     3763:       378:     open Format
     3764:       379: 
     3765:       380:     type stag += Attr of A.t
     3766:       381: 
     3767:       382:     let push r x = r := x :: !r
     3768:       383:     let pop r = r := (match !r with _::xs -> xs | _ -> [])
     3769:       384:     let top_a r = match !r with a::_ -> a | _ -> A.empty
     3770:       385: 
     3771:       386:     let create () =
     3772:       387:       let img, line, attr = ref empty, ref empty, ref [] in
     3773:       388:       let fmt = formatter_of_out_functions {
     3774:       389:           out_flush = (fun () ->
     3775:       390:             img := !img <-> !line; line := empty; attr := [])
     3776:       391:         ; out_newline = (fun () ->
     3777:       392:             img := !img <-> !line; line := void 0 1)
     3778:       393:         ; out_string = (fun s i n ->
     3779:       394:             line := !line <|> string (top_a attr) String.(sub0cp s i n))
     3780:       395:         (* Not entirely clear; either or both could be void: *)
     3781:       396:         ; out_spaces = (fun w -> line := !line <|> char (top_a attr) ' ' w 1)
     3782:       397:         ; out_indent = (fun w -> line := !line <|> char (top_a attr) ' ' w 1)
     3783:       398:       } in
     3784:       399:       pp_set_formatter_stag_functions fmt {
     3785:       400:         (pp_get_formatter_stag_functions fmt ()) with
     3786:       401:             mark_open_stag =
     3787:       402:               (function Attr a -> push attr A.(top_a attr ++ a); "" | _ -> "")
     3788:       403:           ; mark_close_stag = (fun _ -> pop attr; "") };
     3789:       404:       pp_set_mark_tags fmt true;
     3790:       405:       fmt, fun () -> let i = !img in img := empty; line := empty; attr := []; i
     3791:       406: 
     3792:       407:     let ppf, reset = create ()
     3793:       408: 
     3794:       409:     let kstrf ?(attr = A.empty) ?(w = 1000000) k format =
     3795:       410:       let m = ref 0 in
     3796:       411:       let f1 _ () =
     3797:       412:         m := pp_get_margin ppf ();
     3798:       413:         pp_set_margin ppf w;
     3799:       414:         pp_open_stag ppf (Attr attr)
     3800:       415:       and k _ =
     3801:       416:         pp_print_flush ppf ();
     3802:       417:         pp_set_margin ppf !m;
     3803:       418:         reset () |> k
     3804:       419:       in kfprintf k ppf ("%a" ^^ format) f1 ()
     3805:       420: 
     3806:       421:     let strf ?attr ?w format = kstrf ?attr ?w (fun i -> i) format
     3807:       422: 
     3808:       423:     let attr attr f fmt x =
     3809:       424:       pp_open_stag fmt (Attr attr); f fmt x; pp_close_stag fmt ()
     3810:       425:   end
     3811:       426: 
     3812:       427:   let kstrf, strf, pp_attr = Fmt.(kstrf, strf, attr)
     3813:       428: end
     3814:       429: 
     3815:       430: module Operation = struct
     3816:       431: 
     3817:       432:   type t =
     3818:       433:     End
     3819:       434:   | Skip of int * t
     3820:       435:   | Text of A.t * Text.t * t
     3821:       436: 
     3822:       437:   let skip n k = if n = 0 then k else match k with
     3823:       438:       End         -> End
     3824:       439:     | Skip (m, k) -> Skip (m + n, k)
     3825:       440:     | _           -> Skip (n, k) [@@inline]
     3826:       441: 
     3827:       442:   let rec scan x w row i k =
     3828:       443:     let open I in match i with
     3829:       444: 
     3830:       445:     | Empty | Void _ -> skip w k
     3831:       446: 
     3832:       447:     | Segment _ when row > 0 -> skip w k
     3833:       448:     | Segment (attr, text) ->
     3834:       449:         let t  = Text.sub text x w in
     3835:       450:         let w1 = Text.width t in
     3836:       451:         let p  = if w > w1 then skip (w - w1) k else k in
     3837:       452:         if w1 > 0 then Text (attr, t, p) else p
     3838:       453: 
     3839:       454:     | Hcompose ((i1, i2), _) ->
     3840:       455:         let w1 = width i1
     3841:       456:         and w2 = width i2 in
     3842:       457:         if x >= w1 + w2 then skip w k else
     3843:       458:         if x >= w1 then scan (x - w1) w row i2 k else
     3844:       459:         if x + w <= w1 then scan x w row i1 k else
     3845:       460:           scan x (w1 - x) row i1 @@ scan 0 (w - w1 + x) row i2 @@ k
     3846:       461: 
     3847:       462:     | Vcompose ((i1, i2), _) ->
     3848:       463:         let h1 = height i1
     3849:       464:         and h2 = height i2 in
     3850:       465:         if row >= h1 + h2 then skip w k else
     3851:       466:         if row >= h1 then scan x w (row - h1) i2 k else scan x w row i1 k
     3852:       467: 
     3853:       468:     | Zcompose ((i1, i2), _) ->
     3854:       469:         let rec stitch x w row i = function
     3855:       470:           | End -> scan x w row i End
     3856:       471:           | Text (a, t, ops) as opss ->
     3857:       472:               let w1 = Text.width t in
     3858:       473:               if w1 >= w then opss else
     3859:       474:                 Text (a, t, stitch (x + w1) (w - w1) row i ops)
     3860:       475:           | Skip (w1, ops) ->
     3861:       476:               scan x w1 row i @@
     3862:       477:                 if w1 >= w then ops else stitch (x + w1) (w - w1) row i ops
     3863:       478:         in stitch x w row i2 @@ scan x w row i1 @@ k
     3864:       479: 
     3865:       480:     | Hcrop ((i, left, _), (w1, _)) ->
     3866:       481:         if x >= w1 then skip w k else
     3867:       482:         if x + w <= w1 then scan (x + left) w row i k else
     3868:       483:           scan (x + left) (w1 - x) row i @@ skip (w - w1 + x) k
     3869:       484: 
     3870:       485:     | Vcrop ((i, top, _), (_, h1)) ->
     3871:       486:         if row < h1 then scan x w (top + row) i k else skip w k
     3872:       487: 
     3873:       488:   let of_image (x, y) (w, h) i =
     3874:       489:     List.init h (fun off -> scan x (x + w) (y + off) i End)
     3875:       490: end
     3876:       491: 
     3877:       492: module Cap = struct
     3878:       493: 
     3879:       494:   type op = Buffer.t -> unit
     3880:       495: 
     3881:       496:   let (&) op1 op2 buf = op1 buf; op2 buf
     3882:       497: 
     3883:       498:   type t = {
     3884:       499:     skip    : int -> op
     3885:       500:   ; sgr     : A.t -> op
     3886:       501:   ; newline : op
     3887:       502:   ; clreol  : op
     3888:       503:   ; cursvis : bool -> op
     3889:       504:   ; cursat  : int -> int -> op
     3890:       505:   ; cubcuf  : int -> op
     3891:       506:   ; cuucud  : int -> op
     3892:       507:   ; cr      : op
     3893:       508:   ; altscr  : bool -> op
     3894:       509:   ; mouse   : bool -> op
     3895:       510:   ; bpaste  : bool -> op
     3896:       511:   }
     3897:       512: 
     3898:       513:   let ((<|), (<.), (<!)) = Buffer.(add_string, add_char, add_decimal)
     3899:       514: 
     3900:       515:   let sts = [ ";1"; ";3"; ";4"; ";5"; ";7" ]
     3901:       516: 
     3902:       517:   let sgr { A.fg; bg; st } buf =
     3903:       518:     buf <| "\x1b[0";
     3904:       519:     let rgb888 buf x =
     3905:       520:       buf <! A.r x; buf <. ';'; buf <! A.g x; buf <. ';'; buf <! A.b x in
     3906:       521:     ( match A.tag fg with
     3907:       522:         0 -> ()
     3908:       523:       | 1 -> let c = A.i fg in
     3909:       524:              if c < 8  then ( buf <. ';'; buf <! (c + 30) )
     3910:       525:              else if c < 16 then ( buf <. ';'; buf <! (c + 82) )
     3911:       526:              else ( buf <| ";38;5;"; buf <! c )
     3912:       527:       | _ -> buf <| ";38;2;"; rgb888 buf fg );
     3913:       528:     ( match A.tag bg with
     3914:       529:         0 -> ()
     3915:       530:       | 1 -> let c = A.i bg in
     3916:       531:              if c < 8  then ( buf <. ';'; buf <! (c + 40) )
     3917:       532:              else if c < 16 then ( buf <. ';'; buf <! (c + 92) )
     3918:       533:              else ( buf <| ";48;5;"; buf <! c )
     3919:       534:       | _ -> buf <| ";48;2;"; rgb888 buf bg );
     3920:       535:     if st <> 0 then
     3921:       536:       ( let rec go f xs = match (f, xs) with
     3922:       537:           | (0, _) | (_, []) -> ()
     3923:       538:           | (_, x::xs) -> if f land 1 > 0 then buf <| x; go (f lsr 1) xs in
     3924:       539:         go st sts );
     3925:       540:     buf <. 'm'
     3926:       541: 
     3927:       542:   let ansi = {
     3928:       543:       skip    = (fun n b -> b <| "\x1b[0m"; Buffer.add_chars b ' ' n)
     3929:       544:     ; newline = (fun b -> b <| "\x1bE")
     3930:       545:     ; altscr  = (fun x b -> b <| if x then "\x1b[?1049h" else "\x1b[?1049l")
     3931:       546:     ; cursat  = (fun w h b -> b <| "\x1b["; b <! h; b <. ';'; b <! w; b <. 'H')
     3932:       547:     ; cubcuf  = (fun x b -> b <| "\x1b["; b <! abs x; b <. if x < 0 then 'D' else 'C')
     3933:       548:     ; cuucud  = (fun y b -> b <| "\x1b["; b <! abs y; b <. if y < 0 then 'A' else 'B')
     3934:       549:     ; cr      = (fun b -> b <| "\x1b[1G")
     3935:       550:     ; clreol  = (fun b -> b <| "\x1b[K")
     3936:       551:     ; cursvis = (fun x b -> b <| if x then "\x1b[34h\x1b[?25h" else "\x1b[?25l")
     3937:       552:     ; mouse   = (fun x b -> b <| if x then "\x1b[?1000;1002;1005;1015;1006h"
     3938:       553:                                       else "\x1b[?1000;1002;1005;1015;1006l")
     3939:       554:     ; bpaste  = (fun x b -> b <| if x then "\x1b[?2004h" else "\x1b[?2004l")
     3940:       555:     ; sgr }
     3941:       556: 
     3942:       557:   let no0 _     = ()
     3943:       558:   and no1 _ _   = ()
     3944:       559:   and no2 _ _ _ = ()
     3945:       560: 
     3946:       561:   let dumb = {
     3947:       562:       skip    = (fun n b -> Buffer.add_chars b ' ' n)
     3948:       563:     ; newline = (fun b -> b <| "\n")
     3949:       564:     ; altscr  = no1
     3950:       565:     ; cursat  = no2
     3951:       566:     ; cubcuf  = no1
     3952:       567:     ; cuucud  = no1
     3953:       568:     ; cr      = no0
     3954:       569:     ; clreol  = no0
     3955:       570:     ; cursvis = no1
     3956:       571:     ; sgr     = no1
     3957:       572:     ; mouse   = no1
     3958:       573:     ; bpaste  = no1
     3959:       574:     }
     3960:       575: 
     3961:       576:   let erase cap buf = cap.sgr A.empty buf; cap.clreol buf (* KEEP ETA-LONG. *)
     3962:       577:   let cursat0 cap w h = cap.cursat (max w 0 + 1) (max h 0 + 1)
     3963:       578: end
     3964:       579: 
     3965:       580: module Render = struct
     3966:       581: 
     3967:       582:   open Cap
     3968:       583:   open Operation
     3969:       584: 
     3970:       585:   let skip_op cap buf n = cap.skip n buf
     3971:       586:   let text_op cap buf a x = cap.sgr a buf; Text.to_buffer buf x
     3972:       587: 
     3973:       588:   let rec line cap buf = function
     3974:       589:     End              -> erase cap buf
     3975:       590:   | Skip (n,    End) -> erase cap buf; skip_op cap buf n
     3976:       591:   | Text (a, x, End) -> erase cap buf; text_op cap buf a x
     3977:       592:   | Skip (n,    ops) -> skip_op cap buf n; line cap buf ops
     3978:       593:   | Text (a, x, ops) -> text_op cap buf a x; line cap buf ops
     3979:       594: 
     3980:       595:   let rec lines cap buf = function
     3981:       596:     []      -> ()
     3982:       597:   | [ln]    -> line cap buf ln; cap.sgr A.empty buf
     3983:       598:   | ln::lns -> line cap buf ln; cap.newline buf; lines cap buf lns
     3984:       599: 
     3985:       600:   let to_buffer buf cap off dim img =
     3986:       601:     Operation.of_image off dim img |> lines cap buf
     3987:       602: 
     3988:       603:   let pp cap ppf img =
     3989:       604:     let open Format in
     3990:       605:     let buf = Buffer.create (I.width img * 2) in
     3991:       606:     let h, w = I.(height img, width img |> min (pp_get_margin ppf ())) in
     3992:       607:     let img = I.(img </> vpad (h - 1) 0 (char A.empty ' ' w 1)) in
     3993:       608:     pp_open_vbox ppf 0;
     3994:       609:     for y = 0 to h - 1 do
     3995:       610:       Buffer.clear buf; to_buffer buf cap (0, y) (w, 1) img;
     3996:       611:       pp_print_as ppf w (Buffer.contents buf);
     3997:       612:       if y < h - 1 then pp_print_cut ppf ()
     3998:       613:     done;
     3999:       614:     pp_close_box ppf ()
     4000:       615: 
     4001:       616:   let pp_image = pp Cap.ansi
     4002:       617:   let pp_attr ppf a =
     4003:       618:     let string_ = I.string A.empty in
     4004:       619:     pp_image ppf I.(string_ "<" <|> string a "ATTR" <|> string_ ">")
     4005:       620: end
     4006:       621: 
     4007:       622: module Unescape = struct
     4008:       623: 
     4009:       624:   type special = [
     4010:       625:     `Escape
     4011:       626:   | `Enter
     4012:       627:   | `Tab
     4013:       628:   | `Backspace
     4014:       629:   | `Insert
     4015:       630:   | `Delete
     4016:       631:   | `Home | `End
     4017:       632:   | `Arrow of [ `Up | `Down | `Left | `Right ]
     4018:       633:   | `Page of [ `Up | `Down ]
     4019:       634:   | `Function of int
     4020:       635:   ]
     4021:       636: 
     4022:       637:   type button = [ `Left | `Middle | `Right | `Scroll of [ `Up | `Down ] ]
     4023:       638: 
     4024:       639:   type mods = [ `Meta | `Ctrl | `Shift ] list
     4025:       640: 
     4026:       641:   type key = [ special | `Uchar of Uchar.t  | `ASCII of char ] * mods
     4027:       642: 
     4028:       643:   type mouse = [ `Press of button | `Drag | `Release ] * (int * int) * mods
     4029:       644: 
     4030:       645:   type paste = [ `Start | `End ]
     4031:       646: 
     4032:       647:   type event = [ `Key of key | `Mouse of mouse | `Paste of paste ]
     4033:       648: 
     4034:       649:   type esc =
     4035:       650:     C0    of char
     4036:       651:   | C1    of char
     4037:       652:   | SS2   of char
     4038:       653:   | CSI   of string * int list * char
     4039:       654:   | Esc_M of int * int * int
     4040:       655:   | Uchar of Uchar.t
     4041:       656: 
     4042:       657:   let uchar = function `Uchar u -> u | `ASCII c -> Uchar.of_char c
     4043:       658: 
     4044:       659:   let csi =
     4045:       660:     let open Option in
     4046:       661:     let rec priv acc = function
     4047:       662:       | x::xs when btw x 0x3c 0x3f -> priv (Char.unsafe_chr x::acc) xs
     4048:       663:       | xs                         -> param (String.of_chars_rev acc) None [] xs
     4049:       664:     and param prv p ps = function
     4050:       665:       | x::xs when btw x 0x30 0x39 -> param prv (Some (get 0 p * 10 + x - 0x30)) ps xs
     4051:       666:       | 0x3b::xs                   -> param prv None (get 0 p :: ps) xs
     4052:       667:       | xs                         -> code prv (List.rev (to_list p @ ps)) xs
     4053:       668:     and code prv ps = function (* Conflate two classes because urxvt... *)
     4054:       669:       | x::xs when btw x 0x20 0x2f || btw x 0x40 0x7e ->
     4055:       670:           Some (CSI (prv, ps, (Char.chr x)), xs)
     4056:       671:       | _ -> None in
     4057:       672:     priv []
     4058:       673: 
     4059:       674:   let rec demux =
     4060:       675:     let chr = Char.chr in function
     4061:       676:     | 0x1b::0x5b::0x4d::a::b::c::xs -> Esc_M (a, b, c) :: demux xs
     4062:       677:     | 0x1b::0x5b::xs | 0x9b::xs ->
     4063:       678:         let (r, xs) = csi xs |> Option.get (C1 '\x5b', xs) in r :: demux xs
     4064:       679:     | 0x1b::0x4f::x::xs | 0x8f::x::xs
     4065:       680:         when is_ascii x                 -> SS2 (chr x) :: demux xs
     4066:       681:     | 0x1b::x::xs when is_C1 (x + 0x40) -> C1 (chr x) :: demux xs
     4067:       682:     | x::xs when is_C1 x                -> C1 (chr (x - 0x40)) :: demux xs
     4068:       683:     | x::xs when is_C0 x                -> C0 (chr x) :: demux xs
     4069:       684:     | x::xs -> Uchar (Uchar.unsafe_of_int x) :: demux xs
     4070:       685:     | [] -> []
     4071:       686: 
     4072:       687:   let xtrm_mod_flags = function
     4073:       688:     | 2 -> Some [`Shift]
     4074:       689:     | 3 -> Some [`Meta]
     4075:       690:     | 4 -> Some [`Shift; `Meta]
     4076:       691:     | 5 -> Some [`Ctrl]
     4077:       692:     | 6 -> Some [`Shift; `Ctrl]
     4078:       693:     | 7 -> Some [`Meta; `Ctrl]
     4079:       694:     | 8 -> Some [`Shift; `Meta; `Ctrl]
     4080:       695:     | _ -> None
     4081:       696: 
     4082:       697:   let mods_xtrm = function
     4083:       698:     | [1;p] -> xtrm_mod_flags p
     4084:       699:     | []    -> Some []
     4085:       700:     | _     -> None
     4086:       701: 
     4087:       702:   let mods_rxvt = function
     4088:       703:     | '~' -> Some []
     4089:       704:     | '$' -> Some [`Shift]
     4090:       705:     | '^' -> Some [`Ctrl]
     4091:       706:     | '@' -> Some [`Ctrl; `Shift]
     4092:       707:     | _ -> None
     4093:       708: 
     4094:       709:   let mods_common ps code = match (ps, code) with
     4095:       710:     | ([], '~')  -> Some []
     4096:       711:     | ([], c)    -> mods_rxvt c
     4097:       712:     | ([p], '~') -> xtrm_mod_flags p
     4098:       713:     | _          -> None
     4099:       714: 
     4100:       715:   let mouse_p p =
     4101:       716:     let btn = match p land 3 with
     4102:       717:       | 0 when bit 6 p -> `Scroll `Up
     4103:       718:       | 0              -> `Left
     4104:       719:       | 1 when bit 6 p -> `Scroll `Down
     4105:       720:       | 1              -> `Middle
     4106:       721:       | 2 when bit 6 p -> `ALL (* `Scroll `Left *)
     4107:       722:       | 2              -> `Right
     4108:       723:       | 3 when bit 6 p -> `ALL (* `Scroll `Right *)
     4109:       724:       | _              -> `ALL
     4110:       725:     and drag = bit 5 p
     4111:       726:     and mods =
     4112:       727:       (if bit 3 p then [`Meta] else []) @
     4113:       728:       (if bit 4 p then [`Ctrl] else [])
     4114:       729:     in (btn, drag, mods)
     4115:       730: 
     4116:       731:   let key k mods = Some (`Key (k, mods))
     4117:       732: 
     4118:       733:   let event_of_control_code =
     4119:       734:     let open Option in function
     4120:       735:     | Uchar u when Uchar.to_int u |> is_ascii ->
     4121:       736:         Some (`Key (`ASCII (Uchar.unsafe_to_char u), []))
     4122:       737:     | Uchar u -> Some (`Key (`Uchar u, []))
     4123:       738: 
     4124:       739:     | C0 '\x1b'        -> key `Escape []
     4125:       740:     | C0 ('\b'|'\x7f') -> key `Backspace []
     4126:       741:     | C0 '\n'          -> key `Enter []
     4127:       742:     | C0 '\t'          -> key `Tab []
     4128:       743: 
     4129:       744:     | C0 x -> key (`ASCII Char.(code x + 0x40 |> unsafe_chr)) [`Ctrl]
     4130:       745:     | C1 x -> key (`ASCII x) [`Meta]
     4131:       746: 
     4132:       747:     | CSI ("",[],'Z') -> key `Tab [`Shift]
     4133:       748: 
     4134:       749:     | CSI ("",p,'A') -> mods_xtrm p >>= key (`Arrow `Up)
     4135:       750:     | CSI ("",p,'B') -> mods_xtrm p >>= key (`Arrow `Down)
     4136:       751:     | CSI ("",p,'C') -> mods_xtrm p >>= key (`Arrow `Right)
     4137:       752:     | CSI ("",p,'D') -> mods_xtrm p >>= key (`Arrow `Left)
     4138:       753: 
     4139:       754:     | CSI ("",[],'a') -> key (`Arrow `Up) [`Shift]
     4140:       755:     | CSI ("",[],'b') -> key (`Arrow `Down) [`Shift]
     4141:       756:     | CSI ("",[],'c') -> key (`Arrow `Right) [`Shift]
     4142:       757:     | CSI ("",[],'d') -> key (`Arrow `Left) [`Shift]
     4143:       758:     | SS2 ('A'|'a') -> key (`Arrow `Up) [`Ctrl]
     4144:       759:     | SS2 ('B'|'b') -> key (`Arrow `Down) [`Ctrl]
     4145:       760:     | SS2 ('C'|'c') -> key (`Arrow `Right) [`Ctrl]
     4146:       761:     | SS2 ('D'|'d') -> key (`Arrow `Left) [`Ctrl]
     4147:       762: 
     4148:       763:     | CSI ("",5::p,c) -> mods_common p c >>= key (`Page `Up)
     4149:       764:     | CSI ("",6::p,c) -> mods_common p c >>= key (`Page `Down)
     4150:       765: 
     4151:       766:     | CSI ("",2::p,c) -> mods_common p c >>= key `Insert
     4152:       767:     | CSI ("",3::p,c) -> mods_common p c >>= key `Delete
     4153:       768: 
     4154:       769:     | CSI ("",[4],'h') -> key `Insert []
     4155:       770:     | CSI ("",[],'L')  -> key `Insert [`Ctrl]
     4156:       771:     | CSI ("",[],'P')  -> key `Delete []
     4157:       772:     | CSI ("",[],'M')  -> key `Delete [`Ctrl]
     4158:       773: 
     4159:       774:     | CSI ("",p,'H')   -> mods_xtrm p >>= key `Home
     4160:       775:     | CSI ("",[7|1],c) -> mods_rxvt c >>= key `Home
     4161:       776: 
     4162:       777:     | CSI ("",p,'F')   -> mods_xtrm p >>= key `End
     4163:       778:     | CSI ("",[8|4],c) -> mods_rxvt c >>= key `End
     4164:       779:     | CSI ("",[],'J')  -> key `End [`Ctrl]
     4165:       780: 
     4166:       781:     | SS2 ('P'..'S' as c) -> key (`Function (Char.code c - 0x4f)) []
     4167:       782: 
     4168:       783:     | CSI ("",p,('P'..'S' as c)) ->
     4169:       784:         mods_xtrm p >>= key (`Function (Char.code c - 0x4f))
     4170:       785: 
     4171:       786:     | CSI ("",k::p,c) when btw k 11 15 || btw k 17 21 || btw k 23 26 ->
     4172:       787:         mods_common p c >>= key (`Function ((k - 10) - (k - 10) / 6))
     4173:       788: 
     4174:       789:     | CSI ("<",[p;x;y],('M'|'m' as c)) ->
     4175:       790:         let (btn, drag, mods) = mouse_p p in
     4176:       791:         ( match (c, btn, drag) with
     4177:       792:           | ('M', (#button as b), false) -> Some (`Press b)
     4178:       793:           | ('M', #button, true)         -> Some `Drag
     4179:       794:           | ('m', #button, false)        -> Some `Release
     4180:       795:           (* | ('M', `ALL   , true)         -> Some `Move *)
     4181:       796:           | _                            -> None
     4182:       797:         ) >>| fun e -> `Mouse (e, (x - 1, y - 1), mods)
     4183:       798: 
     4184:       799:     | CSI ("",[p;x;y],'M') | Esc_M (p,x,y) as evt ->
     4185:       800:         let (x, y) = match evt with Esc_M _ -> x - 32, y - 32 | _ -> x, y
     4186:       801:         and (btn, drag, mods) = mouse_p (p - 32) in
     4187:       802:         ( match (btn, drag) with
     4188:       803:           | (#button as b, false) -> Some (`Press b)
     4189:       804:           | (#button     , true ) -> Some `Drag
     4190:       805:           | (`ALL        , false) -> Some `Release
     4191:       806:           (* | (`ALL        , true)  -> Some `Move *)
     4192:       807:           | _                     -> None
     4193:       808:         ) >>| fun e -> `Mouse (e, (x - 1, y - 1), mods)
     4194:       809: 
     4195:       810:     | CSI ("",[200],'~') -> Some (`Paste `Start)
     4196:       811:     | CSI ("",[201],'~') -> Some (`Paste `End)
     4197:       812: 
     4198:       813:     | CSI _ | SS2 _ -> None
     4199:       814: 
     4200:       815:   let rec events = function
     4201:       816:     | C0 '\x1b' :: cc :: ccs ->
     4202:       817:       ( match event_of_control_code cc with
     4203:       818:         | Some (`Key (k, mods)) -> `Key (k, `Meta :: mods) :: events ccs
     4204:       819:         | Some _                -> `Key (`Escape, []) :: events (cc::ccs)
     4205:       820:         | None                  -> events ccs )
     4206:       821:     | cc::ccs -> (event_of_control_code cc |> Option.to_list) @ events ccs
     4207:       822:     | [] -> []
     4208:       823: 
     4209:       824:   let decode = events &. demux &. List.map Uchar.to_int
     4210:       825: 
     4211:       826:   type t = (event list * bool) ref
     4212:       827: 
     4213:       828:   let create () = ref ([], false)
     4214:       829: 
     4215:       830:   let next t = match !t with
     4216:       831:     | (#event as e::es, eof) -> t := (es, eof) ; e
     4217:       832:     | ([], false) -> `Await
     4218:       833:     | _           -> `End
     4219:       834: 
     4220:       835:   let list_of_utf8 buf i l =
     4221:       836:     let f cs _ = function `Uchar c -> c::cs | _ -> cs in
     4222:       837:     String.sub0cp (Bytes.unsafe_to_string buf) i l
     4223:       838:     |> Uutf.String.fold_utf_8 f [] |> List.rev
     4224:       839: 
     4225:       840:   let input t buf i l = t := match !t with
     4226:       841:     | (es, false) when l > 0 -> (es @ (list_of_utf8 buf i l |> decode), false)
     4227:       842:     | (es, _)                -> (es, true)
     4228:       843: 
     4229:       844:   let pending t = match !t with ([], false) -> false | _ -> true
     4230:       845: end
     4231:       846: 
     4232:       847: module Tmachine = struct
     4233:       848: 
     4234:       849:   open Cap
     4235:       850:   (* XXX This is sad. This should be a composable, stateless transducer. *)
     4236:       851: 
     4237:       852:   type t = {
     4238:       853:     cap           : Cap.t
     4239:       854:   ; mutable write : Buffer.t -> unit
     4240:       855:   ; mutable curs  : (int * int) option
     4241:       856:   ; mutable dim   : (int * int)
     4242:       857:   ; mutable image : I.t
     4243:       858:   ; mutable dead  : bool
     4244:       859:   }
     4245:       860: 
     4246:       861:   let emit t op =
     4247:       862:     if t.dead then
     4248:       863:       invalid_arg "Notty: use of released terminal"
     4249:       864:     else t.write <- t.write & op
     4250:       865: 
     4251:       866:   let cursor cap = function
     4252:       867:     | None        -> cap.cursvis false
     4253:       868:     | Some (w, h) -> cap.cursvis true & cursat0 cap w h
     4254:       869: 
     4255:       870:   let create ~mouse ~bpaste cap = {
     4256:       871:       cap
     4257:       872:     ; curs  = None
     4258:       873:     ; dim   = (0, 0)
     4259:       874:     ; image = I.empty
     4260:       875:     ; dead  = false
     4261:       876:     ; write =
     4262:       877:         cap.altscr true & cursor cap None & cap.mouse mouse & cap.bpaste bpaste
     4263:       878:     }
     4264:       879: 
     4265:       880:   let release t =
     4266:       881:     if t.dead then false else
     4267:       882:       ( emit t ( t.cap.altscr false & t.cap.cursvis true &
     4268:       883:                  t.cap.mouse false & t.cap.bpaste false );
     4269:       884:         t.dead <- true; true )
     4270:       885: 
     4271:       886:   let output t buf = t.write buf; t.write <- ignore
     4272:       887: 
     4273:       888:   let refresh ({ dim; image; _ } as t) =
     4274:       889:     emit t ( cursor t.cap None & cursat0 t.cap 0 0 &
     4275:       890:              (fun buf -> Render.to_buffer buf t.cap (0, 0) dim image) &
     4276:       891:              cursor t.cap t.curs )
     4277:       892: 
     4278:       893:   let set_size t dim = t.dim <- dim
     4279:       894:   let image t image = t.image <- image; refresh t
     4280:       895:   let cursor t curs = t.curs <- curs; emit t (cursor t.cap curs)
     4281:       896: 
     4282:       897:   let size t = t.dim
     4283:       898:   let dead t = t.dead
     4284:       899: end
     4285:       900: 
     4286:       901: module Direct = struct
     4287:       902:   let show_cursor buf cap x = cap.Cap.cursvis x buf
     4288:       903:   and move_cursor buf cap cmd = match cmd with
     4289:       904:     | `To (w, h) -> Cap.cursat0 cap w h buf
     4290:       905:     | `Home      -> cap.Cap.cr buf
     4291:       906:     | `By (x, y) ->
     4292:       907:         Cap.(if x <> 0 then cap.cubcuf x buf; if y <> 0 then cap.cuucud y buf)
     4293:       908: end
     4294:       909: 
     4295:       910: type attr  = A.t
     4296:       911: type image = I.t
     4297:       912: 
     4298:       913: module Infix = struct
     4299:       914:   let ((<->), (<|>), (</>)) = I.((<->), (<|>), (</>))
     4300:       915:   let (++) = A.(++)
     4301:       916: end
     4302: Added regular file ../notty/src/notty.mli:
     4303:         1: (* Copyright (c) 2016-2017 David Kaloper Meršinjak. All rights reserved.
     4304:         2:    See LICENSE.md. *)
     4305:         3: 
     4306:         4: (** Declaring terminals.
     4307:         5: 
     4308:         6:     Notty is a terminal library that revolves around construction and
     4309:         7:     composition of displayable images.
     4310:         8: 
     4311:         9:     This module provides the core {{!I}[image]} abstraction, standalone
     4312:        10:     {{!Render}rendering}, and escape sequence {{!Unescape}parsing}. It does not
     4313:        11:     depend on any platform code, and does not interact with the environment.
     4314:        12:     Input and output are provided by {!Notty_unix} and {!Notty_lwt}.
     4315:        13: 
     4316:        14:     Consult the {{!basics}basics}, {{!examples}examples} and
     4317:        15:     {{!limitations}limitations}.
     4318:        16: 
     4319:        17:     {e %%VERSION%% — {{:%%PKG_HOMEPAGE%% }homepage}} *)
     4320:        18: 
     4321:        19: (** {1 Interface} *)
     4322:        20: 
     4323:        21: type attr
     4324:        22: (** Visual characteristics of displayed text. *)
     4325:        23: 
     4326:        24: type image
     4327:        25: (** Rectangles of styled characters. *)
     4328:        26: 
     4329:        27: (** [A] is for attribute.
     4330:        28: 
     4331:        29:     Construction and composition of styling characteristics of text.
     4332:        30: 
     4333:        31:     Consult the {{!basics}basics} for an overview. *)
     4334:        32: module A : sig
     4335:        33: 
     4336:        34:   (** {1 Colors} *)
     4337:        35: 
     4338:        36:   type color
     4339:        37:   (** An ineffable quality of light.
     4340:        38: 
     4341:        39:       There are three kinds of colors:
     4342:        40:       {ul
     4343:        41:       {- {e Core 16 colors.}
     4344:        42: 
     4345:        43:          ANSI defines 8 color {e names}, with the actual display colors
     4346:        44:          considered an implementation detail. Historically, this palette was
     4347:        45:          extended with their light (sometimes {e bright} or {e high-intensity})
     4348:        46:          counterparts. Their presentation is undefined too, but typically
     4349:        47:          produces a brighter shade. These colors - often called the {e ANSI
     4350:        48:          colors} - tend to be unpredictable, but ubiquitously supported.
     4351:        49: 
     4352:        50:          }
     4353:        51:       {- {e Extended 256-color palette.}
     4354:        52: 
     4355:        53:          This common feature extends the palette by further 240 colors. They
     4356:        54:          come in two groups:
     4357:        55: 
     4358:        56:          {ul
     4359:        57:          {- The {e color cube}, a 6*6*6 approximation to the usual 24-bit RGB
     4360:        58:             color cube; and}
     4361:        59:          {- the {e grayscale ramp}, containing (merely) 24 shades of gray.}}
     4362:        60: 
     4363:        61:          XTerm was the first to support this extension. Many terminals have
     4364:        62:          since cloned it, so the support is wide, but not universal.
     4365:        63: 
     4366:        64:          As the extended colors are still palette-driven they do not have a
     4367:        65:          fixed presentation, and the presentation can be changed in some
     4368:        66:          terminals. Default palette tends to match {{:
     4369:        67:          https://upload.wikimedia.org/wikipedia/commons/1/15/Xterm_256color_chart.svg}
     4370:        68:          XTerm's}.
     4371:        69: 
     4372:        70:          }
     4373:        71:       {- {e True color}
     4374:        72: 
     4375:        73:          A recently established convention allows directly sending 24-bit colors
     4376:        74:          to the terminal. This has been adopted by a growing minority of
     4377:        75:          terminals. A reasonably up-to-date status document maintained by the
     4378:        76:          community can be found {{:https://gist.github.com/XVilka/8346728}here}.}}
     4379:        77: 
     4380:        78:       Some of the technical and historical background can be found in {{:
     4381:        79:       http://invisible-island.net/xterm/xterm.faq.html#problems_colors}
     4382:        80:       XTerm's FAQ}.
     4383:        81: 
     4384:        82:       {b Note} No attempt is made to remap colors depending on the terminal.
     4385:        83:       Terminals might ignore, remap, or completely misinterpret unsupported
     4386:        84:       colors. *)
     4387:        85: 
     4388:        86:   (** {2:corecolors Core 16 colors}
     4389:        87: 
     4390:        88:       The first 8 have their standard ANSI names. *)
     4391:        89:     val unsafe_color_of_int:int->color
     4392:        90: 
     4393:        91:   val black        : color
     4394:        92:   val red          : color
     4395:        93:   val green        : color
     4396:        94:   val yellow       : color
     4397:        95:   val blue         : color
     4398:        96:   val magenta      : color
     4399:        97:   val cyan         : color
     4400:        98:   val white        : color
     4401:        99:   val lightblack   : color
     4402:       100:   val lightred     : color
     4403:       101:   val lightgreen   : color
     4404:       102:   val lightyellow  : color
     4405:       103:   val lightblue    : color
     4406:       104:   val lightmagenta : color
     4407:       105:   val lightcyan    : color
     4408:       106:   val lightwhite   : color
     4409:       107: 
     4410:       108:   (** {2 Extended 256-color palette} *)
     4411:       109: 
     4412:       110:   val rgb : r:int -> g:int -> b:int -> color
     4413:       111:   (** [rgb ~r:red ~g:green ~b:blue] is an extended-palette color from the color cube.
     4414:       112: 
     4415:       113:       All three channels must be in the range [0 - 5]. XTerm default palette maps
     4416:       114:       this to [0x00], [0x5f], [0x87], [0xaf], [0xd7], and [0xff] independently
     4417:       115:       per channel.
     4418:       116: 
     4419:       117:       @raise Invalid_argument if a channel is outside the range. *)
     4420:       118: 
     4421:       119:   val gray : int -> color
     4422:       120:   (** [gray level] is an extended-palette color from the grayscale ramp.
     4423:       121: 
     4424:       122:       [level] must be in the range [0 - 23]. XTerm default palette maps this to
     4425:       123:       [8 + level * 10] on all three channels.
     4426:       124: 
     4427:       125:       @raise Invalid_argument if the [level] is outside the range. *)
     4428:       126: 
     4429:       127:   (** {2 True Color} *)
     4430:       128: 
     4431:       129:   val rgb_888 : r:int -> g:int -> b:int -> color
     4432:       130:   (** [rgb_888 ~r:red ~g:green ~b:blue] is a 24-bit color.
     4433:       131: 
     4434:       132:       All three channels must be in the range [0 - 255].
     4435:       133: 
     4436:       134:       @raise Invalid_argument if a channel is outside the range. *)
     4437:       135: 
     4438:       136:   (** {1 Text styles} *)
     4439:       137: 
     4440:       138:   type style
     4441:       139:   (** Additional text properties. *)
     4442:       140: 
     4443:       141:   val unsafe_style_of_int: int-> style
     4444:       142: 
     4445:       143:   val bold      : style
     4446:       144:   val italic    : style
     4447:       145:   val underline : style
     4448:       146:   val blink     : style
     4449:       147:   val reverse   : style
     4450:       148: 
     4451:       149:   (** {1 Attribute construction and composition} *)
     4452:       150: 
     4453:       151:   type t = attr
     4454:       152: 
     4455:       153:   val equal : t -> t -> bool
     4456:       154: 
     4457:       155:   val empty : attr
     4458:       156:   (** [empty] is the attribute with the default foreground and background color
     4459:       157:       and empty style set. *)
     4460:       158: 
     4461:       159:   val (++) : attr -> attr -> attr
     4462:       160:   (** [a1 ++ a2] is the concatenation of [a1] and [a2], the attribute that has
     4463:       161:       [a2]'s foreground (resp. background), unless {e unset}, in which case it
     4464:       162:       is [a1]'s, and the union of both style sets.
     4465:       163: 
     4466:       164:       [++] is left-associative, and forms a monoid with [empty]. *)
     4467:       165: 
     4468:       166:   val fg : color -> attr
     4469:       167:   (** [fg c] is [empty] with foreground [c]. *)
     4470:       168: 
     4471:       169:   val bg : color -> attr
     4472:       170:   (** [bg c] is [empty] with background [c]. *)
     4473:       171: 
     4474:       172:   val st : style -> attr
     4475:       173:   (** [st s] is [empty] with style [s]. *)
     4476:       174: end
     4477:       175: 
     4478:       176: (** [I] is for image.
     4479:       177: 
     4480:       178:     Construction and composition of images.
     4481:       179: 
     4482:       180:     Consult the {{!basics}basics} for an overview. *)
     4483:       181: module I : sig
     4484:       182: 
     4485:       183:   type t = image
     4486:       184: 
     4487:       185:   val height : image -> int
     4488:       186:   val width  : image -> int
     4489:       187: 
     4490:       188:   val equal : t -> t -> bool
     4491:       189:   (** [equal t1 t2] is [true] iff [t1] and [t2] are constructed by the same term.
     4492:       190: 
     4493:       191:       {b Note} This is a weak form of equality. Images that are not [equal]
     4494:       192:       could still render the same. *)
     4495:       193: 
     4496:       194:   (** {1:imgprims Primitives} *)
     4497:       195: 
     4498:       196:   val empty : image
     4499:       197:   (** [empty] is a zero-sized image. *)
     4500:       198: 
     4501:       199:   val string : attr -> string -> image
     4502:       200:   (** [string attr s] is an image containing text [s], styled with [attr].
     4503:       201: 
     4504:       202:       @raise Invalid_argument if [string] is not a valid UTF-8 sequence, or
     4505:       203:       contains {{!ctrls}control characters}. *)
     4506:       204: 
     4507:       205:   val uchars : attr -> Uchar.t array -> image
     4508:       206:   (** [uchars attr us] is an image containing text [us], styled with [attr].
     4509:       207: 
     4510:       208:       @raise Invalid_argument if [us] contains {{!ctrls}control characters}. *)
     4511:       209: 
     4512:       210:   val char : attr -> char -> int -> int -> image
     4513:       211:   (** [char attr c w h] is a [w * h] grid of [c].
     4514:       212: 
     4515:       213:       @raise Invalid_argument if [c] is a {{!ctrls}control character}. *)
     4516:       214: 
     4517:       215:   val uchar : attr -> Uchar.t -> int -> int -> image
     4518:       216:   (** [uchar attr u w h] is a [w * h] grid of [u].
     4519:       217: 
     4520:       218:       @raise Invalid_argument if [u] is a {{!ctrls}control character}. *)
     4521:       219: 
     4522:       220:   val void  : int -> int -> image
     4523:       221:   (** [void w h] is a [w * h] rectangle of transparent cells.
     4524:       222: 
     4525:       223:       [void] is magical: it has geometry, but no displayable content. This is
     4526:       224:       different, for example, from the space character [U+0020], which renders
     4527:       225:       as a cell filled with the background color. This means that [void]
     4528:       226:       interacts specially with {{!(</>)}overlays}.
     4529:       227: 
     4530:       228:       [void 0 0 = empty].
     4531:       229:       [void] with only one dimension [0] acts as a spacing element in the other
     4532:       230:       dimension. Negative size is treated as [0]. *)
     4533:       231: 
     4534:       232:   (** {1:imgcomp Image composition}
     4535:       233: 
     4536:       234:       Three basic composition modes allow construction of more complex images
     4537:       235:       from simpler ones.
     4538:       236: 
     4539:       237:       Composition operators are left-associative and form a monoid with [void].
     4540:       238:       *)
     4541:       239: 
     4542:       240:   val (<|>) : image -> image -> image
     4543:       241:   (**  [i1 <|> i2] is the horizontal combination of [i1] and [i2].
     4544:       242: 
     4545:       243:       [width (i1 <|> i2) = width i1 + width i2]
     4546:       244:       [height (i1 <|> i2) = max (height i1) (height i2)]
     4547:       245: 
     4548:       246:       Images are top-aligned. The missing region is implicitly filled with
     4549:       247:       {{!void}[void]}.
     4550:       248: 
     4551:       249: {v
     4552:       250: [x] <|> [y] = [xy]
     4553:       251:         [y]   [.y]
     4554:       252: v}
     4555:       253: 
     4556:       254:       where [.] denotes {{!void}[void]}. *)
     4557:       255: 
     4558:       256:   val (<->) : image -> image -> image
     4559:       257:   (** [i1 <-> i2] is the vertical combination of [i1] and [i2].
     4560:       258: 
     4561:       259:       [width (i1 <-> i2) = max (width i1) (width i2)]
     4562:       260:       [height (i1 <-> i2) = height i1 + height i2]
     4563:       261: 
     4564:       262:       Images are left-aligned. The missing region is implicitly filled with
     4565:       263:       {{!void}[void]}.
     4566:       264: 
     4567:       265: {v
     4568:       266: [xx] <-> [y] = [xx]
     4569:       267:                [y.]
     4570:       268: v}
     4571:       269:       *)
     4572:       270: 
     4573:       271:   val (</>) : image -> image -> image
     4574:       272:   (** [i1 </> i2] is [i1] overlaid over [i2].
     4575:       273: 
     4576:       274:       [width (i1 </> i2) = max (width i1) (width i2)]
     4577:       275:       [height (i1 </> i2) = max (height i1) (height i2)]
     4578:       276: 
     4579:       277:       Images are top-left-aligned. In the region of their overlap, only the
     4580:       278:       {{!void}[void]} cells of [i1] show fragments of [i2].
     4581:       279: 
     4582:       280: {v
     4583:       281: [x.x] </> [yyyy] = [xyxy]
     4584:       282: v}
     4585:       283:       *)
     4586:       284: 
     4587:       285:   (** {1:imgcrop Cropping and padding} *)
     4588:       286: 
     4589:       287:   val hcrop : int -> int -> image -> image
     4590:       288:   (** [hcrop left right i] is [i] with [left] leftmost, and [right]
     4591:       289:       rightmost columns missing. If [left + right >= width i] the result is
     4592:       290:       [empty].
     4593:       291: 
     4594:       292:       If either [left] or [right] is negative, instead of being cropped, the
     4595:       293:       image is padded on that side.
     4596:       294: 
     4597:       295:       For example:
     4598:       296:       {ul
     4599:       297:       {- [hcrop 0 1 [abc]] = [[ab]]}
     4600:       298:       {- [hcrop 1 1 [abc]] = [[b]]}
     4601:       299:       {- [hcrop (-1) 1 [abc]] = [void 1 1 <|> hcrop 0 1 [abc]] = [[.ab]]}
     4602:       300:       {- [hcrop 2 2 [abc]] = [empty]}} *)
     4603:       301: 
     4604:       302:   val vcrop : int -> int -> image -> image
     4605:       303:   (** [vcrop top bottom i] is the vertical analogue to {{!hcrop}[hcrop]}. *)
     4606:       304: 
     4607:       305:   val crop : ?l:int -> ?r:int -> ?t:int -> ?b:int -> image -> image
     4608:       306:   (** [crop ~l:left ~r:right ~t:top ~b:bottom i] is
     4609:       307:       [vcrop left right (hcrop top bottom) i].
     4610:       308: 
     4611:       309:       Missing arguments default to [0]. *)
     4612:       310: 
     4613:       311:   val hpad : int -> int -> image -> image
     4614:       312:   (** {{!hcrop}[hcrop]} with margins negated. *)
     4615:       313: 
     4616:       314:   val vpad : int -> int -> image -> image
     4617:       315:   (** {{!vcrop}[vcrop]} with margins negated. *)
     4618:       316: 
     4619:       317:   val pad : ?l:int -> ?r:int -> ?t:int -> ?b:int -> image -> image
     4620:       318:   (** {{!crop}[crop]} with margins negated. *)
     4621:       319: 
     4622:       320: 
     4623:       321:   (** {1 Additional combinators} *)
     4624:       322: 
     4625:       323:   val hcat : image list -> image
     4626:       324:   (** [hcat xs] horizontally concatenates [xs]. See {{!(<|>)}beside}. *)
     4627:       325: 
     4628:       326:   val vcat : image list -> image
     4629:       327:   (** [vcat xs] vertically concatenates [xs]. See {{!(<->)}above}. *)
     4630:       328: 
     4631:       329:   val zcat : image list -> image
     4632:       330:   (** [zcat xs] overlays [xs]. See {{!(</>)}over}. *)
     4633:       331: 
     4634:       332:   val tabulate : int -> int -> (int -> int -> image) -> image
     4635:       333:   (** [tabulate m n f] is the grid of values [f x y] with [x = 0..m-1]
     4636:       334:       and [y = 0..n-1], where [x] grows to the right, and [y] growns down.
     4637:       335: 
     4638:       336:       [f a y] is to the left of [f b y] if [a < b], and [f x a] is above [f x b]
     4639:       337:       if [a < b], but the exact alignment is unspecified if the various [f x y]
     4640:       338:       have different dimensions. *)
     4641:       339: 
     4642:       340:   val hsnap : ?align:[ `Left | `Middle | `Right ] -> int -> image -> image
     4643:       341:   (** [hsnap ~align w i] is an image of width strictly [w] obtained by either
     4644:       342:       horizontally padding or cropping [i] and positioning it according to
     4645:       343:       [~align].
     4646:       344: 
     4647:       345:       [~align] defaults to [`Middle]. *)
     4648:       346: 
     4649:       347:   val vsnap : ?align:[ `Top | `Middle | `Bottom ] -> int -> image -> image
     4650:       348:   (** [vsnap ~align h i] is an image of height strictly [h] obtained by either
     4651:       349:       vertically padding or cropping [i] and positioning it according to
     4652:       350:       [~align].
     4653:       351: 
     4654:       352:       [~align] defaults to [`Middle]. *)
     4655:       353: 
     4656:       354:   (** {1 [Format] interoperability} *)
     4657:       355: 
     4658:       356:   val strf : ?attr:attr -> ?w:int -> ('a, Format.formatter, unit, image) format4 -> 'a
     4659:       357:   (** [strf ?attr ?w:width format ...] pretty-prints like
     4660:       358:       [Format.asprintf format ...], but returns an [image].
     4661:       359: 
     4662:       360:       [attr] is the (outermost) attribute. Defaults to {!A.empty}.
     4663:       361: 
     4664:       362:       [width] is used to set the margin on the formatter. This is only a hint,
     4665:       363:       and does not guarantee the width of the result. Consult
     4666:       364:       {{: http://caml.inria.fr/pub/docs/manual-ocaml/libref/Format.html#VALset_margin}
     4667:       365:       [Format.set_margin]} for details. Defaults to an unspecified, large
     4668:       366:       number.
     4669:       367: 
     4670:       368:       @raise Invalid_argument if the printing process attempts to directly
     4671:       369:       output {{!ctrls}control characters}, by embedding them in [format] or a
     4672:       370:       string printed with the [%s] conversion, for example.
     4673:       371:       {{: http://caml.inria.fr/pub/docs/manual-ocaml/libref/Format.html#fpp}
     4674:       372:       Formatted printing} is allowed. *)
     4675:       373: 
     4676:       374:   val kstrf : ?attr:attr -> ?w:int -> (image -> 'a) -> ('b, Format.formatter, unit, 'a) format4 -> 'b
     4677:       375:   (** [kstrf ?attr ?w k format ...] is continuation-based [strf ?attr ?w format ...]. *)
     4678:       376: 
     4679:       377:   val pp_attr : attr -> (Format.formatter -> 'a -> unit) -> Format.formatter -> 'a -> unit
     4680:       378:   (** [pp_attr a f] is a pretty-printer like [f], except its output is styled
     4681:       379:       with [a]. This applies only outside of any styling [f] itself might embed. *)
     4682:       380: end
     4683:       381: 
     4684:       382: (** Operators, repeated. *)
     4685:       383: module Infix : sig
     4686:       384: 
     4687:       385:   (** {2 [I]}
     4688:       386: 
     4689:       387:       See {{!I}[I]}. *)
     4690:       388: 
     4691:       389:   val (<->) : image -> image -> image
     4692:       390:   val (<|>) : image -> image -> image
     4693:       391:   val (</>) : image -> image -> image
     4694:       392: 
     4695:       393:   (** {2 [A]}
     4696:       394: 
     4697:       395:       See {{!A}[A]}. *)
     4698:       396: 
     4699:       397:   val (++)  : attr -> attr -> attr
     4700:       398: end
     4701:       399: 
     4702:       400: (** {1 Low-level interface}
     4703:       401: 
     4704:       402:     You can ignore it, unless you are porting [Notty] to a new platform not
     4705:       403:     supported by the existing IO backends. *)
     4706:       404: 
     4707:       405: (** Terminal capabilities.
     4708:       406: 
     4709:       407:     This module describes how to output things so that a terminal understands
     4710:       408:     them. *)
     4711:       409: module Cap : sig
     4712:       410: 
     4713:       411:   type t
     4714:       412:   (** A set of capabilities that distinguish terminals from one another.
     4715:       413: 
     4716:       414:       A bundle of magic strings, really. *)
     4717:       415: 
     4718:       416:   val ansi : t
     4719:       417:   (** The usual ANSI terminal, with colors, text styles and cursor
     4720:       418:       positioning. *)
     4721:       419: 
     4722:       420:   val dumb : t
     4723:       421:   (** Pure text output. Text attributes are stripped and positioning is done
     4724:       422:       with the character [U+0020], SPACE. *)
     4725:       423: end
     4726:       424: 
     4727:       425: (** Dump images to string buffers. *)
     4728:       426: module Render : sig
     4729:       427: 
     4730:       428:   val to_buffer : Buffer.t -> Cap.t -> int * int -> int * int -> image -> unit
     4731:       429:   (** [to_buffer buf cap (x, y) (w, h) i] writes the string representation of
     4732:       430:       [i] to [buf], as interpreted by [cap].
     4733:       431: 
     4734:       432:       It renders the [w * h] rectangle of [i], offset by [(x, y)] from the top
     4735:       433:       left. *)
     4736:       434: 
     4737:       435:   val pp : Cap.t -> Format.formatter -> image -> unit
     4738:       436:   (** [pp cap ppf i] renders [i] to the pretty-printer [ppf].
     4739:       437: 
     4740:       438:       {b Note} [pp] is generally meant for development and debugging. It tries
     4741:       439:       to be reasonable, but dedicated IO modules handle the actual output
     4742:       440:       better. *)
     4743:       441: 
     4744:       442:   (**/**)
     4745:       443:   (* Toplevel. *)
     4746:       444:   val pp_image : Format.formatter -> image -> unit
     4747:       445:   val pp_attr : Format.formatter -> attr -> unit
     4748:       446:   (**/**)
     4749:       447: end
     4750:       448: 
     4751:       449: (** Parse and decode escape sequences in character streams. *)
     4752:       450: module Unescape : sig
     4753:       451: 
     4754:       452:   (** {1 Input events} *)
     4755:       453: 
     4756:       454:   type special = [
     4757:       455:     `Escape
     4758:       456:   | `Enter
     4759:       457:   | `Tab
     4760:       458:   | `Backspace
     4761:       459:   | `Insert
     4762:       460:   | `Delete
     4763:       461:   | `Home | `End
     4764:       462:   | `Arrow of [ `Up | `Down | `Left | `Right ]
     4765:       463:   | `Page of [ `Up | `Down ]
     4766:       464:   | `Function of int
     4767:       465:   ]
     4768:       466:   (** A selection of extra keys on the keyboard. *)
     4769:       467: 
     4770:       468:   type button = [ `Left | `Middle | `Right | `Scroll of [ `Up | `Down ] ]
     4771:       469:   (** Mouse buttons. *)
     4772:       470: 
     4773:       471:   type mods = [ `Meta | `Ctrl | `Shift ] list
     4774:       472:   (** Modifier state. *)
     4775:       473: 
     4776:       474:   type key = [ special | `Uchar of Uchar.t | `ASCII of char ] * mods
     4777:       475:   (** Keypress event. *)
     4778:       476: 
     4779:       477:   type mouse = [ `Press of button | `Drag | `Release ] * (int * int) * mods
     4780:       478:   (** Mouse event. *)
     4781:       479: 
     4782:       480:   type paste = [ `Start | `End ]
     4783:       481:   (** Paste event. *)
     4784:       482: 
     4785:       483:   type event = [ `Key of key | `Mouse of mouse | `Paste of paste ]
     4786:       484:   (** Things that terminals say to applications.
     4787:       485: 
     4788:       486:       {ul
     4789:       487:       {- [`Key (k, mods)] is keyboard input.
     4790:       488: 
     4791:       489:          [k] is a {{!key}key}, one of:
     4792:       490:          {ul
     4793:       491:          {- [`ASCII c] where [c] is a [char] in the
     4794:       492:             {{: https://tools.ietf.org/html/rfc20}ASCII} range;}
     4795:       493:          {- [`Uchar u] where [u] is any other {{!Uchar.t}unicode character}; or}
     4796:       494:          {- a {{!special}special key}.}}
     4797:       495: 
     4798:       496:          [`ASCII] and [`Uchar] together represent the textual part of the input.
     4799:       497:          These characters are guaranteed not to be {{!ctrls}control
     4800:       498:          characters}, and are safe to use when constructing images. ASCII is
     4801:       499:          separated from the rest of Unicode for convenient pattern-matching.
     4802:       500: 
     4803:       501:          [mods] are the extra {{!mods}modifier keys}.
     4804:       502: 
     4805:       503:          }
     4806:       504:       {- [`Mouse (event, (x, y), mods)] is mouse input.
     4807:       505: 
     4808:       506:          [event] is the actual mouse event: {{!button}[button]} press, release,
     4809:       507:          or motion of the mouse with buttons depressed.
     4810:       508: 
     4811:       509:          [(x, y)] are column and row position of the mouse. The origin is
     4812:       510:          [(0,0)], the upper-left corner.
     4813:       511: 
     4814:       512:          {b Note} Every [`Press (`Left|`Middle|`Right)] generates a corresponding
     4815:       513:          [`Release], but there is no portable way to detect which button was
     4816:       514:          released. [`Scroll (`Up|`Down)] presses are not followed by releases.
     4817:       515: 
     4818:       516:          }
     4819:       517:       {- [`Paste (`Start|`End)] are {e bracketed paste} events, signalling the
     4820:       518:          beginning and end of a sequence of events pasted into the terminal.
     4821:       519: 
     4822:       520:          {b Note} This mechanism is useful, but not reliable. The pasted text
     4823:       521:          could contain spurious start-of-paste or end-of-paste markers, or they
     4824:       522:          could be entered by hand. }}
     4825:       523: 
     4826:       524:       Terminal input protocols are historical cruft, and heavily overload the
     4827:       525:       ASCII range. For instance:
     4828:       526:       {ul
     4829:       527:       {- It is impossible to distinguish lower- and upper-case ASCII characters
     4830:       528:          if {b Ctrl} is pressed;}
     4831:       529:       {- several combinations of key-presses are aliased as special keys; and}
     4832:       530:       {- in a UTF-8 encoded stream, there is no representation for non-ASCII
     4833:       531:          characters with modifier keys.}}
     4834:       532: 
     4835:       533:       This means that many values that inhabit the [event] type are impossible,
     4836:       534:       while some reflect multiple different user actions. Limitations include:
     4837:       535: 
     4838:       536:       {ul
     4839:       537:       {- [`Shift] is reported only with special keys, and not all of them.}
     4840:       538:       {- [`Meta] and [`Control] are reported with mouse events, key events with
     4841:       539:          special keys, and key events with values in the ranges [0x40-0x5f]
     4842:       540:          ([@] to [_]) and [0x60-0x7e] ([`] to [~]). If {b Ctrl} is pressed, the higher
     4843:       541:          range is mapped into the lower range.}
     4844:       542:       {- Terminals will variously under-report modifier key state.}}
     4845:       543: 
     4846:       544:       Perform own experiments before relying on elaborate key combinations. *)
     4847:       545: 
     4848:       546:   val uchar : [< `Uchar of Uchar.t | `ASCII of char ] -> Uchar.t
     4849:       547:   (** [uchar x] is the {!Uchar.t} corresponding to [x]. This operations merges
     4850:       548:       the ASCII and Unicode variants of {{!key}key}. *)
     4851:       549: 
     4852:       550:   (** {1 Decoding filter}
     4853:       551: 
     4854:       552:       Simple IO-less terminal input processor. It can be used for building
     4855:       553:       custom terminal input abstractions. *)
     4856:       554: 
     4857:       555:   type t
     4858:       556:   (** Input decoding filter.
     4859:       557: 
     4860:       558:       The filter should be {{!input}fed} strings, which it first decodes from
     4861:       559:       UTF-8, and then extracts the input events.
     4862:       560: 
     4863:       561:       Malformed UTF-8 input bytes and unrecognized escape sequences are silently
     4864:       562:       discarded. *)
     4865:       563: 
     4866:       564:   val create : unit -> t
     4867:       565:   (** [create ()] is a new, empty filter. *)
     4868:       566: 
     4869:       567:   val input : t -> bytes -> int -> int -> unit
     4870:       568:   (** [input t buffer i len] feeds [len] bytes of [string] into [t], starting
     4871:       569:       from position [len].
     4872:       570: 
     4873:       571:       [len = 0] signals the end of input.
     4874:       572: 
     4875:       573:       [buffer] is immediately processed and can be reused after the call
     4876:       574:       returns. *)
     4877:       575: 
     4878:       576:   val next : t -> [ event | `Await | `End ]
     4879:       577:   (** [next t] is the next event in the filter's input stream:
     4880:       578: 
     4881:       579:       {ul
     4882:       580:       {- [#event], an input {{!event}[event]}.}
     4883:       581:       {- [`Await] if the filter needs more {{!input}input}.}
     4884:       582:       {- [`End] if the input had ended.}} *)
     4885:       583: 
     4886:       584:   val pending : t -> bool
     4887:       585:   (** [pending t] is [true] if a call to [next], without any intervening input,
     4888:       586:       would {e not} return [`Await]. *)
     4889:       587: 
     4890:       588:   (** {1 Low-level parsing}
     4891:       589: 
     4892:       590:       {b Warning} The parsing interface is subject to change.
     4893:       591: 
     4894:       592:       Implementation of small parts of
     4895:       593:       {{: http://www.ecma-international.org/publications/standards/Ecma-035.htm}ECMA-35}
     4896:       594:       and
     4897:       595:       {{: http://www.ecma-international.org/publications/standards/Ecma-048.htm}ECMA-48},
     4898:       596:       as needed by terminal emulators in common use. *)
     4899:       597: 
     4900:       598:   val decode : Uchar.t list -> event list
     4901:       599:   (** [decode us] are the events encoded by [us].
     4902:       600: 
     4903:       601:       [us] are assumed to have been generated in a burst, and the end of the
     4904:       602:       list is taken to mean a pause.
     4905:       603:       Therefore, [decode us1 @ decode us2 <> decode (us1 @ us2)] if [us1] ends
     4906:       604:       with a partial escape sequence, including a lone [\x1b].
     4907:       605: 
     4908:       606:       Unsupported escape sequences are silently discarded. *)
     4909:       607: end
     4910:       608: 
     4911:       609: (**/**)
     4912:       610: (** {1 Private}
     4913:       611: 
     4914:       612:     These are private interfaces, prone to breakage. Don't use them. *)
     4915:       613: 
     4916:       614: module Operation : sig
     4917:       615:   type t
     4918:       616:   val of_image : (int * int) -> int * int -> image -> t list
     4919:       617: end
     4920:       618: 
     4921:       619: module Tmachine : sig
     4922:       620: 
     4923:       621:   type t
     4924:       622: 
     4925:       623:   val create  : mouse:bool -> bpaste:bool -> Cap.t -> t
     4926:       624:   val release : t -> bool
     4927:       625:   val output  : t -> Buffer.t -> unit
     4928:       626: 
     4929:       627:   val refresh  : t -> unit
     4930:       628:   val cursor   : t -> (int * int) option -> unit
     4931:       629:   val image    : t -> image -> unit
     4932:       630: 
     4933:       631:   val set_size : t -> int * int -> unit
     4934:       632: 
     4935:       633:   val size : t -> int * int
     4936:       634:   val dead : t -> bool
     4937:       635: end
     4938:       636: 
     4939:       637: module Direct : sig
     4940:       638:   val move_cursor : Buffer.t -> Cap.t -> [ `Home | `By of int * int | `To of int * int ] -> unit
     4941:       639:   val show_cursor : Buffer.t -> Cap.t -> bool -> unit
     4942:       640: end
     4943:       641: (**/**)
     4944:       642: 
     4945:       643: (** {1:basics Basics}
     4946:       644: 
     4947:       645:     Print a red-on-black ["Wow!"] above its right-shifted copy:
     4948:       646: {[
     4949:       647: let wow = I.string A.(fg red ++ bg black) "Wow!" in
     4950:       648: I.(wow <-> (void 2 0 <|> wow)) |> Notty_unix.output_image
     4951:       649: ]}
     4952:       650: 
     4953:       651:     {2:meaning The meaning of images}
     4954:       652: 
     4955:       653:     An {{!image}[image]} value is a rectangle of styled character cells. It has a
     4956:       654:     width and height, but is not anchored to an origin. A single character with
     4957:       655:     associated display attributes, or a short fragment of text, are simple
     4958:       656:     examples of images.
     4959:       657: 
     4960:       658:     Images are created by combining text fragments with {{!attributes}display
     4961:       659:     attributes}, and composed by placing them {{!I.(<|>)}beside} each other,
     4962:       660:     {{!I.(<->)}above} each other, and {{!I.(</>)}over} each other.
     4963:       661: 
     4964:       662:     Once constructed, an image can be rendered, and only at that point it obtains
     4965:       663:     absolute placement.
     4966:       664: 
     4967:       665:     Consult {{!I}[I]} for more details.
     4968:       666: 
     4969:       667:     {2:attributes Display attributes}
     4970:       668: 
     4971:       669:     {{!attr}[attr]} values describe the styling characteristics of fragments of
     4972:       670:     text.
     4973:       671: 
     4974:       672:     They combine a foreground and a background {{!A.color}[color]} with a
     4975:       673:     set of {{!A.style}[styles]}. Either color can be {e unset}, which corresponds to
     4976:       674:     the terminal's default foreground (resp. background) color.
     4977:       675: 
     4978:       676:     Attributes are used to construct primitive images.
     4979:       677: 
     4980:       678:     Consult {{!A}[A]} for more details.
     4981:       679: 
     4982:       680:     {2:ctrls Control characters}
     4983:       681: 
     4984:       682:     These are taken to be characters in the ranges [0x00-0x1f] ({b C0}), [0x7f]
     4985:       683:     (BACKSPACE), [0x80-0x9f] ({b C1}). This is the
     4986:       684:     {{: http://unicode.org/reports/tr44/#General_Category_Values}Unicode
     4987:       685:     general category} {b Cc}.
     4988:       686: 
     4989:       687:     As control characters directly influence the cursor positioning, they
     4990:       688:     cannot be used to create images.
     4991:       689: 
     4992:       690:     This, in particular, means that images cannot contain [U+000a] (NEWLINE).
     4993:       691: 
     4994:       692:     {1:limitations Limitations}
     4995:       693: 
     4996:       694:     [Notty] does not use Terminfo. If your terminal is particularly
     4997:       695:     idiosyncratic, things might fail to work. Get in touch with the author to
     4998:       696:     expand support.
     4999:       697: 
     5000:       698:     [Notty] assumes that the terminal is using UTF-8 for input and output.
     5001:       699:     Things might break arbitrarily if this is not the case.
     5002:       700: 
     5003:       701:     For performance considerations, consult the {{!perf}performance model}.
     5004:       702: 
     5005:       703:     {2:cwidth Unicode vs. Text geometry}
     5006:       704: 
     5007:       705:     [Notty] uses [Uucp.Break.tty_width_hint] to guess the width of text
     5008:       706:     fragments when computing geometry, and it suffers from the same
     5009:       707:     shortcomings:
     5010:       708: 
     5011:       709:     {ul
     5012:       710:     {- Geometry in general works for alphabets and east Asian scripts, mostly
     5013:       711:         works for abjad scripts, and is a matter of luck for abugidas.}
     5014:       712:     {- East Asian scripts work better when in
     5015:       713:         {{:http://unicode.org/glossary/#normalization_form_c}NFC}.}
     5016:       714:     {- For proper emoji display, [Uucp] and the terminal have to agree on the
     5017:       715:        Unicode version.}}
     5018:       716: 
     5019:       717:     When in doubt, see
     5020:       718:     {{: http://erratique.ch/software/uucp/doc/Uucp.Break.html#VALtty_width_hint}
     5021:       719:     [Uucp.Break.tty_width_hint]}.
     5022:       720: 
     5023:       721:     Unicode has special interaction with {{!I.hcrop}horizontal cropping}:
     5024:       722:     {ul
     5025:       723:     {- Strings within images are cropped at {{:
     5026:       724:         http://unicode.org/reports/tr29/#Grapheme_Cluster_Boundaries}grapheme
     5027:       725:         cluster} boundaries. This means that scalar value sequences that are
     5028:       726:         rendered combined, or overlaid, stay unbroken.}
     5029:       727:     {- When a crop splits a wide character in two, the remaining half is
     5030:       728:         replaced by [U+0020] (SPACE). Hence, character-cell-accurate cropping is
     5031:       729:         possible even in the presence of characters that horizontally occupy
     5032:       730:         more than one cell.}}
     5033:       731: 
     5034:       732:     {1:examples Examples}
     5035:       733: 
     5036:       734:     We assume a toplevel with [Notty] support ([#require "notty.top"]).
     5037:       735: 
     5038:       736:     {2 Hello}
     5039:       737: 
     5040:       738:     ["Rad!"] with default foreground and background:
     5041:       739: 
     5042:       740:     {[I.string A.empty "Rad!"]}
     5043:       741: 
     5044:       742:     Everything has to start somewhere.
     5045:       743: 
     5046:       744:     {2 Colors}
     5047:       745: 
     5048:       746:     ["Rad!"] in rad letters:
     5049:       747: 
     5050:       748:     {[I.string A.(fg lightred) "Rad!"]}
     5051:       749: 
     5052:       750:     {2 Padding and spacing}
     5053:       751: 
     5054:       752: {[
     5055:       753: let a1 = A.(fg lightwhite ++ bg red)
     5056:       754: and a2 = A.(fg red)
     5057:       755: ]}
     5058:       756: 
     5059:       757:     ["Rad"] and [" stuff!"] in different colors:
     5060:       758: 
     5061:       759:     {[I.(string a1 "Rad" <|> string a2 " stuff!")]}
     5062:       760: 
     5063:       761:     The second word hanging on a line below:
     5064:       762: 
     5065:       763:     {[I.(string a1 "Rad" <|> (string a2 "stuff!" |> vpad 1 0))]}
     5066:       764: 
     5067:       765:     {2 More geometry}
     5068:       766: 
     5069:       767:     Sierpinski triangle:
     5070:       768: 
     5071:       769: {[
     5072:       770: let square = "\xe2\x96\xaa"
     5073:       771: 
     5074:       772: let rec sierp n =
     5075:       773:   if n > 1 then
     5076:       774:     let ss = sierp (pred n) in I.(ss <-> (ss <|> ss))
     5077:       775:   else I.(string A.(fg magenta) square |> hpad 1 0)
     5078:       776: ]}
     5079:       777: 
     5080:       778:     {[sierp 8]}
     5081:       779: 
     5082:       780:     A triangle overlaid over its shifted copy:
     5083:       781: 
     5084:       782:     {[let s = sierp 6 in I.(s </> vpad 1 0 s)]}
     5085:       783: 
     5086:       784:     Blinkenlights:
     5087:       785: 
     5088:       786: {[
     5089:       787: let rad n color =
     5090:       788:   let a1 = A.fg color in
     5091:       789:   let a2 = A.(st blink ++ a1) in
     5092:       790:   I.((string a2 "Rad" |> hpad n 0) <->
     5093:       791:      (string a1 "(⌐■_■)" |> hpad (n + 7) 0))
     5094:       792: 
     5095:       793: let colors = A.[red; green; yellow; blue; magenta; cyan]
     5096:       794: ]}
     5097:       795: 
     5098:       796: {[
     5099:       797: colors |> List.mapi I.(fun i c -> rad i c |> pad ~t:i ~l:(2 * i))
     5100:       798:        |> I.zcat
     5101:       799: ]}
     5102:       800: 
     5103:       801:     {b Note} Usage of {{!A.blink}[blink]} might be regulated by law in some
     5104:       802:     jurisdictions.
     5105:       803: 
     5106:       804:     {2 Pretty-printing}
     5107:       805: 
     5108:       806:     Images can be pretty-printed into:
     5109:       807: 
     5110:       808:     {[I.strf "(%d)" 42]}
     5111:       809: 
     5112:       810:     Attributes can be applied to the entire format string, or by decorating
     5113:       811:     {e user-defined printers} that are supplied with [%a] conversions:
     5114:       812: 
     5115:       813:     {[let pp = Format.pp_print_int]}
     5116:       814: 
     5117:       815:     {[I.strf ~attr:A.(fg lightwhite) "(%a)" (I.pp_attr A.(fg green) pp) 42]}
     5118:       816: 
     5119:       817:     {2 Now with output}
     5120:       818: 
     5121:       819:     The core module has no real IO. Examples above are simple [image]-valued
     5122:       820:     expressions, displayed by the pretty-printer that is installed by the
     5123:       821:     toplevel support. Self-contained programs need a separate IO module:
     5124:       822: 
     5125:       823:     {[#require "notty.unix"]}
     5126:       824: 
     5127:       825:     {[sierp 8 |> Notty_unix.output_image]}
     5128:       826: 
     5129:       827:     (Note the difference in cropping behavior.)
     5130:       828: 
     5131:       829:     Computations can be adapted to the current terminal size. A line can stretch
     5132:       830:     end-to-end:
     5133:       831: 
     5134:       832: {[
     5135:       833: Notty_unix.output_image_size @@ fun (w, _) ->
     5136:       834:   let i1 = I.string A.(fg green) "very"
     5137:       835:   and i2 = I.string A.(fg yellow) "melon" in
     5138:       836:   I.(i1 <|> void (w - width i1 - width i2) 1 <|> i2)
     5139:       837: ]}
     5140:       838: 
     5141:       839:     The largest triangle that horizontally fits into the terminal:
     5142:       840: 
     5143:       841: {[
     5144:       842: Notty_unix.output_image_size @@ fun (w, _) ->
     5145:       843:   let steps = int_of_float ((log (float w)) /. log 2.) in
     5146:       844:   sierp steps |> I.vpad 0 1
     5147:       845: ]}
     5148:       846: 
     5149:       847:     {2 Simple interaction}
     5150:       848: 
     5151:       849:     Interactive Sierpinski:
     5152:       850: 
     5153:       851:     {[open Notty_unix]}
     5154:       852: 
     5155:       853: {[
     5156:       854: let img (double, n) =
     5157:       855:   let s = sierp n in
     5158:       856:   if double then I.(s </> vpad 1 0 s) else s
     5159:       857: in
     5160:       858: let rec update t state = Term.image t (img state); loop t state
     5161:       859: and loop t (double, n as state) =
     5162:       860:   match Term.event t with
     5163:       861:   | `Key (`Enter,_)        -> ()
     5164:       862:   | `Key (`Arrow `Left,_)  -> update t (double, max 1 (n - 1))
     5165:       863:   | `Key (`Arrow `Right,_) -> update t (double, min 8 (n + 1))
     5166:       864:   | `Key (`ASCII ' ', _)   -> update t (not double, n)
     5167:       865:   | `Resize _              -> update t state
     5168:       866:   | _                      -> loop t state
     5169:       867: in
     5170:       868: let t = Term.create ()
     5171:       869: in
     5172:       870: update t (false, 1); Term.release t
     5173:       871: ]}
     5174:       872: 
     5175:       873:     The program uses a fullscreen {{!Notty_unix.Term}terminal} and loops reading
     5176:       874:     the {{!Notty_unix.Term.event}input}. LEFT and RIGHT control the iteration
     5177:       875:     count, and SPACE toggles double-drawing. Resizing the window causes a
     5178:       876:     redraw. When the loop exits on ENTER, the terminal is
     5179:       877:     {{!Notty_unix.Term.release}cleaned up}.
     5180:       878: 
     5181:       879:     {1:perf Performance model}
     5182:       880: 
     5183:       881:     This section is only relevant if using [Notty] becomes your bottleneck.
     5184:       882: 
     5185:       883:     {b TL;DR} Shared sub-expressions do not share work, so operators stick with
     5186:       884:     you.
     5187:       885: 
     5188:       886:     The main performance parameter is {e image complexity}. This roughly
     5189:       887:     corresponds to the number of image {{!I.imgcomp}composition} and
     5190:       888:     {{!I.imgcrop}cropping} operators in the fully expanded [image] term,
     5191:       889:     {b ignoring all sharing}.
     5192:       890: 
     5193:       891:     Outline numbers:
     5194:       892: 
     5195:       893:     {ul
     5196:       894:     {- Highly complex images can be rendered and pushed out to a full-screen
     5197:       895:        terminal more than 1000 times per second.}
     5198:       896:     {- With more realistic images, this number is closer to 30,000.}
     5199:       897:     {- Input processing is somewhere around 50MB/s.}}
     5200:       898: 
     5201:       899: 
     5202:       900:     Image complexity [cplx] of an image [i] is:
     5203:       901:     {ul
     5204:       902:     {- For a {{!I.imgprims}primitive} [i], [cplx i = 1].}
     5205:       903:     {- For a {{!I.imgcomp}composition} operator [op],
     5206:       904:        [cplx (op i1 i2) = 1 + cplx i1 + cplx i2].}
     5207:       905:     {- For a {{!I.imgcomp}crop} [cr],
     5208:       906:        [cplx (cr i1) = 1 + cplx i1 - k], where [k] is the combined complexity of
     5209:       907:        all the {e maximal} sub-terms that do not contribute to the output.}}
     5210:       908: 
     5211:       909:     For example (assuming an image [i]):
     5212:       910: 
     5213:       911: {[
     5214:       912:   let img1 = I.((i <|> i) <-> (i <|> i))
     5215:       913:   let img2 = I.(let x = i <|> i in x <-> x)
     5216:       914:   let img3 = I.(((i <|> i) <|> i) <|> i)
     5217:       915: ]}
     5218:       916: 
     5219:       917:     Complexity of each of these is [4 * cplx i + 3]. This might be surprising
     5220:       918:     for [img2].
     5221:       919: 
     5222:       920:     If [width i = 1], [cplx (hcrop 1 0 img1) = 3 + 2 * cplx i], and
     5223:       921:     [cplx (hcrop 2 0 img3) = 2 + 2 * cplx i].
     5224:       922: 
     5225:       923:     While [Notty] strives to be accommodating to all usage scenarios, these are
     5226:       924:     the things to keep in mind if the rendering becomes slow:
     5227:       925: 
     5228:       926:     {ol
     5229:       927:     {- Image composition is cheap.
     5230:       928: 
     5231:       929:        Combining images performs a negligible amount of computation.
     5232:       930: 
     5233:       931:        Constructing primitive images that contain scalar values outside of the
     5234:       932:        ASCII range does a little more work upfront and is worth holding onto.
     5235:       933: 
     5236:       934:        }
     5237:       935:     {- {{!Render}Rendering} depends on image complexity.
     5238:       936: 
     5239:       937:        As a consequence, this real-world example of wrapping renders in time
     5240:       938:        O(n{^ 2}) in the number of lines:
     5241:       939: 
     5242:       940: {[
     5243:       941: let wrap1 width img =
     5244:       942:   let rec go img = img ::
     5245:       943:     if I.width img > width then go (I.hcrop width 0 img) else []
     5246:       944:   in go img |> I.vcat |> I.hsnap ~align:`Left width
     5247:       945: ]}
     5248:       946: 
     5249:       947:        Although [crop] is applied only [lines] times, the image complexity of
     5250:       948:        each line depends on the number of preceding lines.
     5251:       949: 
     5252:       950:        An O(n) version does not iterate [crop]:
     5253:       951: 
     5254:       952: {[
     5255:       953: let wrap2 width img =
     5256:       954:   let rec go off = I.hcrop off 0 img ::
     5257:       955:     if I.width img - off > width then go (off + width) else []
     5258:       956:   in go 0 |> I.vcat |> I.hsnap ~align:`Left width
     5259:       957: ]}
     5260:       958:        }
     5261:       959:     {- Rendering depends on the {e output} dimensions, but not on the {e image}
     5262:       960:        dimensions.
     5263:       961: 
     5264:       962:        Rendering an image to [w * h] implicitly crops it to its leftmost [w]
     5265:       963:        columns and topmost [h] rows. While [w] and [h] will have an impact on
     5266:       964:        the rendering performance, the complexity of the (cropped) image tends to
     5267:       965:        be more important.}}
     5268:       966: 
     5269:       967: *)
     5270: Added regular file ../notty/src/notty_top.ml:
     5271:         1: (* Copyright (c) 2017 David Kaloper Meršinjak. All rights reserved.
     5272:         2:    See LICENSE.md. *)
     5273:         3: 
     5274:         4: (* Force linking with Notty for e.g. Omod. *)
     5275:         5: let _ = Sys.opaque_identity Notty.I.empty
     5276:         6: 
     5277:         7: #if OCAML_VERSION >= (4,14,0)
     5278:         8: let _ = Toploop.use_silently Format.err_formatter (Toploop.File "notty_top_init.ml")
     5279:         9: #else
     5280:        10: let _ = Toploop.use_silently Format.err_formatter "notty_top_init.ml"
     5281:        11: #endif
     5282: Added regular file ../notty/src/notty_top_init.ml:
     5283:         1: (* Copyright (c) 2017 David Kaloper Meršinjak. All rights reserved.
     5284:         2:    See LICENSE.md. *)
     5285:         3: 
     5286:         4: open Notty;;
     5287:         5: 
     5288:         6: #install_printer Notty.Render.pp_image;;
     5289:         7: #install_printer Notty.Render.pp_attr;;
     5290: Added regular file ../notty/src-lwt/dune:
     5291:         1: (library
     5292:         2:   (public_name notty.lwt)
     5293:         3:   (synopsis "Notty Lwt+Unix IO")
     5294:         4:   (name notty_lwt)
     5295:         5:   (wrapped false)
     5296:         6:   (optional)
     5297:         7:   (libraries notty notty.unix lwt lwt.unix))
     5298: Added regular file ../notty/src-lwt/notty_lwt.ml:
     5299:         1: (* Copyright (c) 2016-2017 David Kaloper Meršinjak. All rights reserved.
     5300:         2:    See LICENSE.md. *)
     5301:         3: 
     5302:         4: open Lwt.Infix
     5303:         5: 
     5304:         6: open Notty
     5305:         7: open Notty_unix
     5306:         8: open Private
     5307:         9: 
     5308:        10: 
     5309:        11: type ('a, 'b) either = Left of 'a | Right of 'b
     5310:        12: let left  x = Left x
     5311:        13: let right y = Right y
     5312:        14: 
     5313:        15: let (</>) a b = Lwt.pick [(a >|= left); (b >|= right)]
     5314:        16: let (<??>) a b = (a >|= left) <?> (b >|= right)
     5315:        17: 
     5316:        18: let whenopt f = function Some x -> f x | None -> ()
     5317:        19: 
     5318:        20: let rec write fd buf off = function
     5319:        21:   | 0 -> Lwt.return_unit
     5320:        22:   | n -> Lwt_unix.write fd buf off n >>= fun w -> write fd buf (off + w) (n - w)
     5321:        23: 
     5322:        24: module Lwt_condition = struct
     5323:        25: 
     5324:        26:   include Lwt_condition
     5325:        27: 
     5326:        28:   let map f c =
     5327:        29:     let d = create () in
     5328:        30:     let rec go () = wait c >>= fun x -> broadcast d (f x); go ()
     5329:        31:     in (Lwt.async go; d)
     5330:        32: 
     5331:        33:   let unburst ~t c =
     5332:        34:     let d = create () in
     5333:        35:     let rec delay x = Lwt_unix.sleep t </> wait c >>= function
     5334:        36:       | Left () -> broadcast d x; start ()
     5335:        37:       | Right x -> delay x
     5336:        38:     and start () = wait c >>= delay in
     5337:        39:     Lwt.async start; d
     5338:        40: end
     5339:        41: 
     5340:        42: module Term = struct
     5341:        43: 
     5342:        44:   let winches = lazy (
     5343:        45:     let c = Lwt_condition.create () in
     5344:        46:     let `Revert _ = set_winch_handler (Lwt_condition.broadcast c) in
     5345:        47:     c
     5346:        48:   )
     5347:        49: 
     5348:        50:   let winch () = Lazy.force winches |> Lwt_condition.wait
     5349:        51: 
     5350:        52:   let bsize = 1024
     5351:        53: 
     5352:        54:   let input_stream ~nosig fd stop =
     5353:        55:     let `Revert f = setup_tcattr ~nosig (Lwt_unix.unix_file_descr fd) in
     5354:        56:     let stream =
     5355:        57:       let flt  = Unescape.create ()
     5356:        58:       and ibuf = Bytes.create bsize in
     5357:        59:       let rec next () =
     5358:        60:         match Unescape.next flt with
     5359:        61:         | #Unescape.event as r -> Lwt.return_some r
     5360:        62:         | `End   -> Lwt.return_none
     5361:        63:         | `Await ->
     5362:        64:             (Lwt_unix.read fd ibuf 0 bsize <??> stop) >>= function
     5363:        65:               | Left n  -> Unescape.input flt ibuf 0 n; next ()
     5364:        66:               | Right _ -> Lwt.return_none
     5365:        67:       in Lwt_stream.from next in
     5366:        68:     Lwt.async (fun () -> Lwt_stream.closed stream >|= f);
     5367:        69:     stream
     5368:        70: 
     5369:        71:   type t = {
     5370:        72:     ochan  : Lwt_io.output_channel
     5371:        73:   ; trm    : Tmachine.t
     5372:        74:   ; buf    : Buffer.t
     5373:        75:   ; fds    : Lwt_unix.file_descr * Lwt_unix.file_descr
     5374:        76:   ; events : [ Unescape.event | `Resize of (int * int) ] Lwt_stream.t
     5375:        77:   ; stop   : (unit -> unit)
     5376:        78:   }
     5377:        79: 
     5378:        80:   let write t =
     5379:        81:     Tmachine.output t.trm t.buf;
     5380:        82:     let out = Buffer.contents t.buf in (* XXX There goes 0copy. :/ *)
     5381:        83:     Buffer.clear t.buf; Lwt_io.write t.ochan out
     5382:        84: 
     5383:        85:   let refresh t      = Tmachine.refresh t.trm; write t
     5384:        86:   let image t image  = Tmachine.image t.trm image; write t
     5385:        87:   let cursor t curs  = Tmachine.cursor t.trm curs; write t
     5386:        88:   let set_size t dim = Tmachine.set_size t.trm dim
     5387:        89:   let size t         = Tmachine.size t.trm
     5388:        90: 
     5389:        91:   let release t =
     5390:        92:     if Tmachine.release t.trm then
     5391:        93:       ( t.stop (); write t >>= fun () -> Lwt_io.flush t.ochan )
     5392:        94:     else Lwt.return_unit
     5393:        95: 
     5394:        96:   let resizef fd stop on_resize =
     5395:        97:     if Unix.isatty fd then
     5396:        98:       let rcond = Lwt_condition.(
     5397:        99:         Lazy.force winches |> unburst ~t:0.1 |> map (fun () -> winsize fd)) in
     5398:       100:       let rec monitor () =
     5399:       101:         (Lwt_condition.wait rcond <?> stop) >>= function
     5400:       102:           | Some dim -> on_resize dim; monitor ()
     5401:       103:           | None     -> Lwt.return_unit in
     5402:       104:       Lwt.async monitor;
     5403:       105:       Lwt_stream.from (fun () -> Lwt_condition.wait rcond <?> stop)
     5404:       106:         |> Lwt_stream.map (fun dim -> `Resize dim)
     5405:       107:     else Lwt_stream.of_list []
     5406:       108: 
     5407:       109:   let create ?(dispose=true) ?(nosig=true) ?(mouse=true) ?(bpaste=true)
     5408:       110:              ?(input=Lwt_unix.stdin) ?(output=Lwt_unix.stdout) () =
     5409:       111:     let fd = Lwt_unix.unix_file_descr output in
     5410:       112:     let (stop, stopw) = Lwt.wait () in
     5411:       113:     let rec t = lazy {
     5412:       114:         trm    = Tmachine.create ~mouse ~bpaste (cap_for_fd fd)
     5413:       115:       ; ochan  = Lwt_io.(of_fd ~mode:output) output
     5414:       116:       ; buf    = Buffer.create 4096
     5415:       117:       ; fds    = (input, output)
     5416:       118:       ; stop   = (fun () -> Lwt.wakeup stopw None)
     5417:       119:       ; events = Lwt_stream.choose
     5418:       120:           [ input_stream ~nosig input stop
     5419:       121:           ; resizef fd stop @@ fun dim ->
     5420:       122:               let t = Lazy.force t in Buffer.reset t.buf; set_size t dim ]
     5421:       123:       } in
     5422:       124:     let t = Lazy.force t in
     5423:       125:     winsize fd |> whenopt (set_size t);
     5424:       126:     Lwt.async (fun () -> write t); (* XXX async? *)
     5425:       127:     if dispose then Lwt_main.at_exit (fun () -> release t);
     5426:       128:     t
     5427:       129: 
     5428:       130:   let events t = t.events
     5429:       131:   let fds    t = t.fds
     5430:       132: end
     5431:       133: 
     5432:       134: let winsize fd = winsize (Lwt_unix.unix_file_descr fd)
     5433:       135: 
     5434:       136: include Gen_output (struct
     5435:       137:   type fd = Lwt_unix.file_descr and k = unit Lwt.t
     5436:       138:   let (def, to_fd) = Lwt_unix.(stdout, unix_file_descr)
     5437:       139:   and write fd buf = Buffer.(write fd (to_bytes buf) 0 (length buf))
     5438:       140: end)
     5439: Added regular file ../notty/src-lwt/notty_lwt.mli:
     5440:         1: (* Copyright (c) 2016-2017 David Kaloper Meršinjak. All rights reserved.
     5441:         2:    See LICENSE.md. *)
     5442:         3: 
     5443:         4: (** [Notty] IO [Lwt] on [Unix].
     5444:         5: 
     5445:         6:     This is an IO module for {!Notty}.
     5446:         7: 
     5447:         8:     It mirrors {!Notty_unix} and the corresponding operations behave
     5448:         9:     analogously. Consult its documentation for more info.
     5449:        10: 
     5450:        11:     {e %%VERSION%% — {{:%%PKG_HOMEPAGE%% }homepage}} *)
     5451:        12: 
     5452:        13: open Notty
     5453:        14: 
     5454:        15: (** {1:fullscreen Fullscreen input and output}. *)
     5455:        16: 
     5456:        17: (** Terminal IO with concurrency.
     5457:        18: 
     5458:        19:     For more info, see {!Notty_unix.Term}. *)
     5459:        20: module Term : sig
     5460:        21: 
     5461:        22:   type t
     5462:        23: 
     5463:        24:   (** {1 Construction and destruction} *)
     5464:        25: 
     5465:        26:   val create : ?dispose:bool ->
     5466:        27:                ?nosig:bool ->
     5467:        28:                ?mouse:bool ->
     5468:        29:                ?bpaste:bool ->
     5469:        30:                ?input:Lwt_unix.file_descr ->
     5470:        31:                ?output:Lwt_unix.file_descr ->
     5471:        32:                unit -> t
     5472:        33:   (** [create ~dispose ~nosig ~mouse ~input ~output ()] creates a new
     5473:        34:       {{!t}terminal}.
     5474:        35: 
     5475:        36:       {b Note} [~dispose] arranges for the terminal to be disposed of at the end
     5476:        37:       of the [Lwt] main loop, and not at process exit.
     5477:        38: 
     5478:        39:       See {!Notty_unix.Term.create}. *)
     5479:        40: 
     5480:        41:   val release : t -> unit Lwt.t
     5481:        42: 
     5482:        43:   (** {1 Commands} *)
     5483:        44: 
     5484:        45:   val image   : t -> image -> unit Lwt.t
     5485:        46:   val refresh : t -> unit Lwt.t
     5486:        47:   val cursor  : t -> (int * int) option -> unit Lwt.t
     5487:        48: 
     5488:        49:   (** {1 Events} *)
     5489:        50: 
     5490:        51:   val events : t -> [ Unescape.event | `Resize of (int * int) ] Lwt_stream.t
     5491:        52:   (** [events t] is the stream of incoming events.
     5492:        53: 
     5493:        54:       Invoking {{!release}release} will terminate this stream.
     5494:        55: 
     5495:        56:       Events are:
     5496:        57:       {ul
     5497:        58:       {- [#Unescape.event], an {{!Notty.Unescape.event}event} from the input
     5498:        59:          fd; or}
     5499:        60:       {- [`Resize (cols, rows)] whenever the terminal size changes.}}
     5500:        61: 
     5501:        62:       {b Note} This stream is unique; for the same [t], [events t] always
     5502:        63:       returns the same stream. *)
     5503:        64: 
     5504:        65:   (** {1 Properties} *)
     5505:        66: 
     5506:        67:   val size : t -> int * int
     5507:        68: 
     5508:        69:   val fds : t -> Lwt_unix.file_descr * Lwt_unix.file_descr
     5509:        70: 
     5510:        71:   (** {1 Window size change notifications}
     5511:        72: 
     5512:        73:       {{!create}Creating} a terminal will install a [SIGWINCH] handler.
     5513:        74:       The handler should not be replaced directly. This API allows the user to
     5514:        75:       monitor deliveries of the signal.
     5515:        76: 
     5516:        77:       See {!Notty_unix.Term.Winch}. *)
     5517:        78: 
     5518:        79:   val winch : unit -> unit Lwt.t
     5519:        80:   (** [winch ()] is a thread completing after the next [SIGWINCH]. A single
     5520:        81:       signal delivery will cause the completion of all waiting [winch] threads. *)
     5521:        82: end
     5522:        83: 
     5523:        84: (** {1:inline Inline output} *)
     5524:        85: 
     5525:        86: val winsize : Lwt_unix.file_descr -> (int * int) option
     5526:        87: 
     5527:        88: val eol : image -> image
     5528:        89: 
     5529:        90: val output_image :
     5530:        91:   ?cap:Cap.t -> ?fd:Lwt_unix.file_descr -> image -> unit Lwt.t
     5531:        92: 
     5532:        93: val output_image_size :
     5533:        94:   ?cap:Cap.t -> ?fd:Lwt_unix.file_descr -> (int * int -> image) -> unit Lwt.t
     5534:        95: 
     5535:        96: val show_cursor : ?cap:Cap.t -> ?fd:Lwt_unix.file_descr -> bool -> unit Lwt.t
     5536:        97: 
     5537:        98: val move_cursor :
     5538:        99:   ?cap:Cap.t -> ?fd:Lwt_unix.file_descr ->
     5539:       100:     [ `Home | `By of int * int | `To of int * int ] -> unit Lwt.t
     5540: Added regular file ../notty/src-unix/dune:
     5541:         1: (library
     5542:         2:   (public_name notty.unix)
     5543:         3:   (synopsis "Notty Unix IO")
     5544:         4:   (name notty_unix)
     5545:         5:   (wrapped false)
     5546:         6:   (c_names winsize)
     5547:         7:   (c_flags (-Wall -Wextra -O3))
     5548:         8:   (optional)
     5549:         9:   (libraries notty unix))
     5550:        10: 
     5551:        11: (include_subdirs unqualified)
     5552: Added regular file ../notty/src-unix/native/winsize.c:
     5553:         1: #include <sys/ioctl.h>
     5554:         2: #include <signal.h>
     5555:         3: #include <caml/mlvalues.h>
     5556:         4: 
     5557:         5: CAMLprim value caml_notty_winsize (value vfd) {
     5558:         6:   int fd = Int_val (vfd);
     5559:         7:   struct winsize w;
     5560:         8:   if (ioctl (fd, TIOCGWINSZ, &w) >= 0)
     5561:         9:     return Val_int ((w.ws_col << 16) + ((w.ws_row & 0x7fff) << 1));
     5562:        10:   return Val_int (0);
     5563:        11: }
     5564:        12: 
     5565:        13: #define __unit() value unit __attribute__((unused))
     5566:        14: 
     5567:        15: CAMLprim value caml_notty_winch_number (__unit()) {
     5568:        16:   return Val_int (SIGWINCH);
     5569:        17: }
     5570: Added regular file ../notty/src-unix/notty_unix.ml:
     5571:         1: (* Copyright (c) 2016-2017 David Kaloper Meršinjak. All rights reserved.
     5572:         2:    See LICENSE.md. *)
     5573:         3: 
     5574:         4: open Notty
     5575:         5: 
     5576:         6: external c_winsize : Unix.file_descr -> int = "caml_notty_winsize" [@@noalloc]
     5577:         7: external winch_number : unit -> int = "caml_notty_winch_number" [@@noalloc]
     5578:         8: 
     5579:         9: let iter f = function Some x -> f x | _ -> ()
     5580:        10: let value x = function Some a -> a | _ -> x
     5581:        11: 
     5582:        12: let winsize fd = match c_winsize fd with
     5583:        13:   | 0  -> None
     5584:        14:   | wh -> Some (wh lsr 16, wh lsr 1 land 0x7fff)
     5585:        15: 
     5586:        16: module Private = struct
     5587:        17: 
     5588:        18:   let once f = let v = lazy (f ()) in fun () -> Lazy.force v
     5589:        19: 
     5590:        20:   let cap_for_fd =
     5591:        21:     let open Cap in
     5592:        22:     match Sys.getenv "TERM" with
     5593:        23:     | exception Not_found -> fun _ -> dumb
     5594:        24:     | (""|"dumb")         -> fun _ -> dumb
     5595:        25:     | _                   -> fun fd -> if Unix.isatty fd then ansi else dumb
     5596:        26: 
     5597:        27:   let setup_tcattr ~nosig fd =
     5598:        28:     let open Unix in try
     5599:        29:       let tc = tcgetattr fd in
     5600:        30:       let tc1 = { tc with c_icanon = false; c_echo = false } in
     5601:        31:       tcsetattr fd TCSANOW
     5602:        32:         ( if nosig then { tc1 with c_isig = false; c_ixon = false } else tc1 );
     5603:        33:       `Revert (once @@ fun _ -> tcsetattr fd TCSANOW tc)
     5604:        34:     with Unix_error (ENOTTY, _, _) -> `Revert ignore
     5605:        35: 
     5606:        36:   let set_winch_handler f =
     5607:        37:     let signum = winch_number () in
     5608:        38:     let old_hdl = Sys.(signal signum (Signal_handle (fun _ -> f ()))) in
     5609:        39:     `Revert (once @@ fun () -> Sys.set_signal signum old_hdl)
     5610:        40: 
     5611:        41:   module Gen_output (O : sig
     5612:        42:     type fd
     5613:        43:     type k
     5614:        44:     val def   : fd
     5615:        45:     val to_fd : fd -> Unix.file_descr
     5616:        46:     val write : fd -> Buffer.t -> k
     5617:        47:   end) = struct
     5618:        48: 
     5619:        49:     let scratch = lazy (Buffer.create 4096)
     5620:        50: 
     5621:        51:     let output ?cap ?(fd = O.def) f =
     5622:        52:       let cap = cap |> value (cap_for_fd (O.to_fd fd)) in
     5623:        53:       let buf = Lazy.force scratch in
     5624:        54:       Buffer.reset buf; f buf cap fd; O.write fd buf
     5625:        55: 
     5626:        56:     let output_image_size ?cap ?fd f =
     5627:        57:       output ?cap ?fd @@ fun buf cap fd ->
     5628:        58:         let size = winsize (O.to_fd fd) in
     5629:        59:         let i = f (value (80, 24) size) in
     5630:        60:         let dim = match size with
     5631:        61:           | Some (w, _) -> I.(w, height i)
     5632:        62:           | None        -> I.(width i, height i) in
     5633:        63:         Render.to_buffer buf cap (0, 0) dim i
     5634:        64: 
     5635:        65:     let show_cursor ?cap ?fd x =
     5636:        66:       output ?cap ?fd @@ fun buf cap _ -> Direct.show_cursor buf cap x
     5637:        67: 
     5638:        68:     let move_cursor ?cap ?fd x =
     5639:        69:       output ?cap ?fd @@ fun buf cap _ -> Direct.move_cursor buf cap x
     5640:        70: 
     5641:        71:     let output_image ?cap ?fd i = output_image_size ?cap ?fd (fun _ -> i)
     5642:        72: 
     5643:        73:     let eol i = I.(i <-> void 0 1)
     5644:        74:   end
     5645:        75: end
     5646:        76: 
     5647:        77: open Private
     5648:        78: 
     5649:        79: module Term = struct
     5650:        80: 
     5651:        81:   module Winch = struct
     5652:        82: 
     5653:        83:     let h  = Hashtbl.create 3
     5654:        84:     and id = ref 0
     5655:        85: 
     5656:        86:     let add fd f =
     5657:        87:       let n = !id in
     5658:        88:       set_winch_handler (fun () -> Hashtbl.iter (fun _ f -> f ()) h) |> ignore;
     5659:        89:       Hashtbl.add h n (fun () -> winsize fd |> iter f); incr id;
     5660:        90:       `Revert (fun () -> Hashtbl.remove h n)
     5661:        91:   end
     5662:        92: 
     5663:        93:   module Input = struct
     5664:        94: 
     5665:        95:     type t = {
     5666:        96:       fd      : Unix.file_descr
     5667:        97:     ; flt     : Unescape.t
     5668:        98:     ; ibuf    : bytes
     5669:        99:     ; cleanup : unit -> unit
     5670:       100:     }
     5671:       101: 
     5672:       102:     let bsize = 1024
     5673:       103: 
     5674:       104:     let create ~nosig fd =
     5675:       105:       let flt  = Unescape.create ()
     5676:       106:       and ibuf = Bytes.create bsize
     5677:       107:       and `Revert cleanup = setup_tcattr ~nosig fd in
     5678:       108:       { fd; flt; ibuf; cleanup }
     5679:       109: 
     5680:       110:     let rec event t =
     5681:       111:       match Unescape.next t.flt with
     5682:       112:       | #Unescape.event | `End as r -> r
     5683:       113:       | `Await ->
     5684:       114:           let n = Unix.read t.fd t.ibuf 0 bsize in
     5685:       115:           Unescape.input t.flt t.ibuf 0 n; event t
     5686:       116:   end
     5687:       117: 
     5688:       118:   type t = {
     5689:       119:     output   : out_channel
     5690:       120:   ; trm      : Tmachine.t
     5691:       121:   ; buf      : Buffer.t
     5692:       122:   ; input    : Input.t
     5693:       123:   ; fds      : Unix.file_descr * Unix.file_descr
     5694:       124:   ; unwinch  : (unit -> unit) Lazy.t
     5695:       125:   ; mutable winched : bool
     5696:       126:   }
     5697:       127: 
     5698:       128:   let write t =
     5699:       129:     Buffer.clear t.buf;
     5700:       130:     Tmachine.output t.trm t.buf;
     5701:       131:     Buffer.output_buffer t.output t.buf; flush t.output
     5702:       132: 
     5703:       133:   let set_size t dim = Tmachine.set_size t.trm dim
     5704:       134:   let refresh t      = Tmachine.refresh t.trm; write t
     5705:       135:   let image t image  = Tmachine.image t.trm image; write t
     5706:       136:   let cursor t curs  = Tmachine.cursor t.trm curs; write t
     5707:       137:   let size t         = Tmachine.size t.trm
     5708:       138: 
     5709:       139:   let release t =
     5710:       140:     if Tmachine.release t.trm then
     5711:       141:       ( Lazy.force t.unwinch ();
     5712:       142:         t.input.Input.cleanup ();
     5713:       143:         write t )
     5714:       144: 
     5715:       145:   let create ?(dispose=true) ?(nosig=true) ?(mouse=true) ?(bpaste=true)
     5716:       146:              ?(input=Unix.stdin) ?(output=Unix.stdout) () =
     5717:       147:     let rec t = {
     5718:       148:         output  = Unix.out_channel_of_descr output
     5719:       149:       ; trm     = Tmachine.create ~mouse ~bpaste (cap_for_fd input)
     5720:       150:       ; buf     = Buffer.create 4096
     5721:       151:       ; input   = Input.create ~nosig input
     5722:       152:       ; fds     = (input, output)
     5723:       153:       ; winched = false
     5724:       154:       ; unwinch = lazy (
     5725:       155:           let `Revert f = Winch.add output @@ fun dim ->
     5726:       156:             Buffer.reset t.buf; t.winched <- true; set_size t dim in f)
     5727:       157:     } in
     5728:       158:     winsize output |> iter (set_size t);
     5729:       159:     (Lazy.force t.unwinch |> ignore) [@ocaml.warning "-5"];
     5730:       160:     if dispose then at_exit (fun () -> release t);
     5731:       161:     write t;
     5732:       162:     t
     5733:       163: 
     5734:       164:   let rec event = function
     5735:       165:     | t when Tmachine.dead t.trm -> `End
     5736:       166:     | t when t.winched -> t.winched <- false; `Resize (size t)
     5737:       167:     | t -> Unix.(try Input.event t.input with Unix_error (EINTR, _, _) -> event t)
     5738:       168: 
     5739:       169:   let pending t =
     5740:       170:     not (Tmachine.dead t.trm) &&
     5741:       171:     (t.winched || Unescape.pending t.input.Input.flt)
     5742:       172: 
     5743:       173:   let fds t = t.fds
     5744:       174: end
     5745:       175: 
     5746:       176: include Gen_output (struct
     5747:       177:   type fd = out_channel and k = unit
     5748:       178:   let def   = stdout
     5749:       179:   and to_fd = Unix.descr_of_out_channel
     5750:       180:   and write = Buffer.output_buffer
     5751:       181: end)
     5752: Added regular file ../notty/src-unix/notty_unix.mli:
     5753:         1: (* Copyright (c) 2016-2017 David Kaloper Meršinjak. All rights reserved.
     5754:         2:    See LICENSE.md. *)
     5755:         3: 
     5756:         4: (** [Notty] IO for pure [Unix].
     5757:         5: 
     5758:         6:     This is an IO module for {!Notty}.
     5759:         7: 
     5760:         8:     {e %%VERSION%% — {{:%%PKG_HOMEPAGE%% }homepage}} *)
     5761:         9: 
     5762:        10: open Notty
     5763:        11: 
     5764:        12: (** {1:fullscreen Fullscreen input and output}. *)
     5765:        13: 
     5766:        14: (** Terminal IO abstraction for fullscreen, interactive applications.
     5767:        15: 
     5768:        16:     This module provides both input and output. It assumes exclusive ownership of
     5769:        17:     the IO streams between {{!create}initialization} and {{!release}shutdown}. *)
     5770:        18: module Term : sig
     5771:        19: 
     5772:        20:   type t
     5773:        21:   (** Representation of the terminal, giving structured access to IO. *)
     5774:        22: 
     5775:        23:   (** {1 Construction and destruction} *)
     5776:        24: 
     5777:        25:   val create : ?dispose:bool ->
     5778:        26:                ?nosig:bool ->
     5779:        27:                ?mouse:bool ->
     5780:        28:                ?bpaste:bool ->
     5781:        29:                ?input:Unix.file_descr ->
     5782:        30:                ?output:Unix.file_descr ->
     5783:        31:                unit -> t
     5784:        32:   (** [create ~dispose ~nosig ~mouse ~input ~output ()] creates a fresh
     5785:        33:       {{!t}terminal}. It has the following side effects:
     5786:        34:       {ul
     5787:        35:       {- [Unix.tcsetattr] is applied to [input] to disable {e echo} and
     5788:        36:          {e canonical mode}.}
     5789:        37:       {- [output] is set to {e alternate screen mode}, and the cursor is
     5790:        38:          hidden. Mouse and {e bracketed paste} reporting are (optionally)
     5791:        39:          enabled.}
     5792:        40:       {- [SIGWINCH] signal, normally ignored, is handled.}}
     5793:        41: 
     5794:        42:       [~dispose] arranges for automatic {{!release}cleanup} of the terminal
     5795:        43:       before the process terminates. The downside is that a reference to this
     5796:        44:       terminal is retained until the program exits. Defaults to [true].
     5797:        45: 
     5798:        46:       [~nosig] additionally turns off signal delivery and flow control
     5799:        47:       ({e isig} and {e ixon}) on input. Inhibits automatic handling of
     5800:        48:       {e CTRL-\{C,Z,\,S,Q\}}. Defaults to [true].
     5801:        49: 
     5802:        50:       [~mouse] activates mouse reporting. Defaults to [true].
     5803:        51: 
     5804:        52:       [~bpaste] activates bracketed paste reporting. Defaults to [true].
     5805:        53: 
     5806:        54:       [~input] is the input file descriptor. Defaults to [stdin].
     5807:        55: 
     5808:        56:       [~output] is the output file descriptor. Defaults to [stdout]. *)
     5809:        57: 
     5810:        58:   val release : t -> unit
     5811:        59:   (** Dispose of this terminal. Original behavior of input fd is reinstated,
     5812:        60:       cursor is restored, mouse reporting disabled, and alternate mode is
     5813:        61:       terminated.
     5814:        62: 
     5815:        63:       It is an error to use the {{!cmds}commands} on a released terminal, and
     5816:        64:       will raise [Invalid_argument], while [release] itself is idempotent. *)
     5817:        65: 
     5818:        66:   (** {1:cmds Commands} *)
     5819:        67: 
     5820:        68:   val image : t -> image -> unit
     5821:        69:   (** [image t i] sets [i] as [t]'s current image and redraws the terminal. *)
     5822:        70: 
     5823:        71:   val refresh : t -> unit
     5824:        72:   (** [refresh t] redraws the terminal using the current image.
     5825:        73: 
     5826:        74:       Useful if the output might have become garbled. *)
     5827:        75: 
     5828:        76:   val cursor : t -> (int * int) option -> unit
     5829:        77:   (** [cursor t pos] sets and redraws the cursor.
     5830:        78: 
     5831:        79:       [None] hides it. [Some (x, y)] places it at column [x] and row [y], with
     5832:        80:       the origin at [(0, 0)], mapping to the upper-left corner. *)
     5833:        81: 
     5834:        82:   (** {1 Events} *)
     5835:        83: 
     5836:        84:   val event : t -> [ Unescape.event | `Resize of (int * int) | `End ]
     5837:        85:   (** Wait for a new event. [event t] can be:
     5838:        86:       {ul
     5839:        87:       {- [#Unescape.event], an {{!Notty.Unescape.event}[event]} from the input fd;}
     5840:        88:       {- [`End] if the input fd is closed, or the terminal was released; or}
     5841:        89:       {- [`Resize (cols, rows)] giving the current size of the output tty, if a
     5842:        90:          [SIGWINCH] was delivered before or during this call to [event].}}
     5843:        91: 
     5844:        92:       {b Note} [event] is buffered. Calls can either block or immediately
     5845:        93:       return. Use {{!pending}[pending]} to detect when the next call would not
     5846:        94:       block. *)
     5847:        95: 
     5848:        96:   val pending : t -> bool
     5849:        97:   (** [pending t] is [true] if the next call to {{!event}[event]} would not
     5850:        98:       block and the terminal has not yet been released. *)
     5851:        99: 
     5852:       100:   (** {1 Properties} *)
     5853:       101: 
     5854:       102:   val size : t -> int * int
     5855:       103:   (** [size t] is the current size of the terminal's output tty. *)
     5856:       104: 
     5857:       105:   val fds : t -> Unix.file_descr * Unix.file_descr
     5858:       106:   (** [fds t] are [t]'s input and output file descriptors. *)
     5859:       107: 
     5860:       108:   (** {1 Window size change notifications} *)
     5861:       109: 
     5862:       110:   (** Manual [SIGWINCH] handling.
     5863:       111: 
     5864:       112:       Unix delivers notifications about tty size changes through the [SIGWINCH]
     5865:       113:       signal. A handler for this signal is installed as soon as a new terminal
     5866:       114:       is {{!create}created}. Replacing the global [SIGWINCH] handler using
     5867:       115:       the [Sys] module will cause this module to malfunction, as the size change
     5868:       116:       notifications will no longer be delivered.
     5869:       117: 
     5870:       118:       You might still want to ignore resizes reported by {{!event}[event]} and
     5871:       119:       directly listen to [SIGWINCH]. This module allows installing such
     5872:       120:       listeners without conflicting with the rest of the machinery. *)
     5873:       121:   module Winch : sig
     5874:       122: 
     5875:       123:     val add : Unix.file_descr -> ((int * int) -> unit) -> [`Revert of unit -> unit]
     5876:       124:     (** [add fd f] registers a [SIGWINCH] handler. Every time the signal is
     5877:       125:         delivered, [f] is called with the current size of the tty backing [fd].
     5878:       126:         If [fd] is not a tty, [f] is never called.
     5879:       127: 
     5880:       128:         Return value is a function that removes the handler [f].
     5881:       129: 
     5882:       130:         Handlers are called in an unspecified order. *)
     5883:       131: 
     5884:       132:   end
     5885:       133: end
     5886:       134: 
     5887:       135: (** {1:inline Inline output}
     5888:       136: 
     5889:       137:     These operations do not assume exclusive access to the output. This means
     5890:       138:     that they can be combined with other means of producing output. At the same
     5891:       139:     time, it means that they are affected by the current terminal state, and
     5892:       140:     that this state is not tracked. *)
     5893:       141: 
     5894:       142: val winsize : Unix.file_descr -> (int * int) option
     5895:       143: (** [winsize fd] is [Some (columns, rows)], the current dimensions of [fd]'s
     5896:       144:     backing tty, or [None], when [fd] is not backed by a tty. *)
     5897:       145: 
     5898:       146: val eol : image -> image
     5899:       147: (** [eol image] is [image], producing an extra newline when printed. *)
     5900:       148: 
     5901:       149: val output_image :
     5902:       150:   ?cap:Cap.t -> ?fd:out_channel -> image -> unit
     5903:       151: (** [output_image ?cap ?fd image] writes [image] to [fd].
     5904:       152: 
     5905:       153:     The image is displayed in its full height. If the output is a tty, image
     5906:       154:     width is clipped to the output width. Otherwise, full width is used.
     5907:       155: 
     5908:       156:     [~cap] is the {{!caps}optional} terminal capability set.
     5909:       157: 
     5910:       158:     [~fd] defaults to [stdout]. *)
     5911:       159: 
     5912:       160: val output_image_size : ?cap:Cap.t -> ?fd:out_channel -> (int * int -> image) -> unit
     5913:       161: (** [output_image_size ?cap ?fd f] is
     5914:       162:     [output_image ?cap ?fd (f size)] where [size] are [fd]'s current
     5915:       163:     {{!winsize}output dimensions}.
     5916:       164: 
     5917:       165:     If [fd] is not backed by a tty, as a matter of convenience, [f] is applied
     5918:       166:     to [(80, 24)]. Use {!Unix.isatty} or {{!winsize}[winsize]} to detect whether
     5919:       167:     the output has a well-defined size. *)
     5920:       168: 
     5921:       169: val show_cursor : ?cap:Cap.t -> ?fd:out_channel -> bool -> unit
     5922:       170: (** [show_cursor ?cap ?fd visible] toggles the cursor visibility on [fd]. *)
     5923:       171: 
     5924:       172: val move_cursor :
     5925:       173:   ?cap:Cap.t -> ?fd:out_channel ->
     5926:       174:     [ `Home | `By of int * int | `To of int * int ] -> unit
     5927:       175: (** [move_cursor ?cap ?fd motion] moves the cursor on [fd].
     5928:       176: 
     5929:       177:     [motion] is one of:
     5930:       178:     {ul
     5931:       179:     {- [`To (column, line)], positioning the cursor to [(column, line)]. Origin
     5932:       180:        is [(0, 0)], the upper-left corner of the screen.}
     5933:       181:     {- [`Home], moving the cursor the beginning of line.}
     5934:       182:     {- [`By (columns, lines)], moving the cursor [columns] to the right (left if
     5935:       183:        negative) and [lines] down (up if negative).
     5936:       184: 
     5937:       185:        {b Note} Behavior is terminal dependent if the movement overshoots the
     5938:       186:        output size.}} *)
     5939:       187: 
     5940:       188: (** {1:caps Capability detection}
     5941:       189: 
     5942:       190:     All [image] output requires {{!Notty.Cap.t}terminal capabilities}.
     5943:       191: 
     5944:       192:     When not provided, capabilities are auto-detected, by checking that the
     5945:       193:     output is a tty, that the environment variable [$TERM] is set, and that it
     5946:       194:     is not set to either [""] or ["dumb"]. If these conditions hold,
     5947:       195:     {{!Notty.Cap.ansi}ANSI} escapes are used. Otherwise, {{!Notty.Cap.dumb}no}
     5948:       196:     escapes are used. *)
     5949:       197: 
     5950:       198: (**/**)
     5951:       199: (** {1 Private}
     5952:       200: 
     5953:       201:     These are private interfaces, prone to breakage. Don't use them. *)
     5954:       202: module Private : sig
     5955:       203: 
     5956:       204:   val cap_for_fd        : Unix.file_descr -> Cap.t
     5957:       205:   val setup_tcattr      : nosig:bool -> Unix.file_descr -> [ `Revert of (unit -> unit) ]
     5958:       206:   val set_winch_handler : (unit -> unit) -> [ `Revert of (unit -> unit) ]
     5959:       207: 
     5960:       208:   module Gen_output (O : sig
     5961:       209:     type fd
     5962:       210:     type k
     5963:       211:     val def   : fd
     5964:       212:     val to_fd : fd -> Unix.file_descr
     5965:       213:     val write : fd -> Buffer.t -> k
     5966:       214:   end ) : sig
     5967:       215:     val output_image : ?cap:Cap.t -> ?fd:O.fd -> image -> O.k
     5968:       216:     val output_image_size : ?cap:Cap.t -> ?fd:O.fd -> (int * int -> image) -> O.k
     5969:       217:     val show_cursor : ?cap:Cap.t -> ?fd:O.fd -> bool -> O.k
     5970:       218:     val move_cursor : ?cap:Cap.t -> ?fd:O.fd -> [ `Home | `By of int * int | `To of int * int ] -> O.k
     5971:       219:     val eol : image -> image
     5972:       220:   end
     5973:       221: end
     5974:       222: (**/**)
     5975: Added executable file ../notty/support/gen_unicode_props.ml:
     5976:         1: #!/usr/bin/env ocaml
     5977:         2: (* Copyright (c) 2020 David Kaloper Meršinjak. All rights reserved.
     5978:         3:    See LICENSE.md. *)
     5979:         4: 
     5980:         5: #use "topfind"
     5981:         6: #require "uucp"
     5982:         7: 
     5983:         8: let filter p seq i = seq (fun x -> if p x then i x)
     5984:         9: let map f seq i = seq (fun x -> i (f x))
     5985:        10: let uchars it =
     5986:        11:   let rec go it u = it u; go it (Uchar.succ u) in
     5987:        12:   try go it Uchar.min with Invalid_argument _ -> ()
     5988:        13: let to_list seq =
     5989:        14:   let xs = ref [] in
     5990:        15:   seq (fun x -> xs := x :: !xs);
     5991:        16:   List.rev !xs
     5992:        17: 
     5993:        18: let intervals_kv seq i =
     5994:        19:   let s = ref None in
     5995:        20:   let f (x, v) = match !s with
     5996:        21:   | None -> s := Some (x, x, v)
     5997:        22:   | Some (a, b, v0) when v = v0 && x = Uchar.succ b -> s := Some (a, x, v0)
     5998:        23:   | Some e -> i e; s := Some (x, x, v) in
     5999:        24:   seq f;
     6000:        25:   match !s with Some e -> i e | _ -> ()
     6001:        26: 
     6002:        27: let intervals_p seq =
     6003:        28:   map (fun x -> x, ()) seq |> intervals_kv |> map (fun (a, b, _) -> a, b)
     6004:        29: 
     6005:        30: (* Condenses code points into continuous range. *)
     6006:        31: let pack_u u = let i = Uchar.to_int u in if i > 0xd7ff then i - 0x800 else i
     6007:        32: let unpack_u i = Uchar.of_int (if i < 0xd800 then i else i + 0x800)
     6008:        33: 
     6009:        34: (* 12-6-6-bit (0xfff-0x3f-0x3f) trie, 3 levels, array-array-string.
     6010:        35:    Root is variable; lower levels are either empty or complete.
     6011:        36: 
     6012:        37:    At the moment, packed Uchar.max is 0x10f7ff; this can map up to 0xffffff
     6013:        38:    distinct code points.  *)
     6014:        39: let trie ~default f =
     6015:        40:   let xs = List.init ((pack_u Uchar.max lsr 12) + 1) @@ fun b0 ->
     6016:        41:     let mask = b0 lsl 12 in
     6017:        42:     let arr = Array.init 0x40 @@ fun b1 ->
     6018:        43:       let mask = mask lor (b1 lsl 6) in
     6019:        44:       let v b2 = match unpack_u (mask lor b2) with
     6020:        45:       | x -> f x
     6021:        46:       | exception Invalid_argument _ -> default in
     6022:        47:       match (for b2 = 0 to 0x3f do if v b2 <> default then raise Exit done) with
     6023:        48:       | exception Exit -> String.init 0x40 (fun b2 -> Char.chr (v b2))
     6024:        49:       | () -> ""
     6025:        50:     in
     6026:        51:     if Array.for_all ((=) "") arr then [||] else arr
     6027:        52:   in
     6028:        53:   let rec trim = function [||]::xs -> trim xs | xs -> xs in
     6029:        54:   List.rev (trim (List.rev xs)) |> Array.of_list
     6030:        55: 
     6031:        56: let pf = Format.fprintf
     6032:        57: let strf = Format.sprintf
     6033:        58: let pp_iter ?(sep = fun _ _ -> ()) iter pp ppf x =
     6034:        59:   let fst = ref true in
     6035:        60:   let f x = (if !fst then fst := false else sep ppf ()); pp ppf x in
     6036:        61:   iter f x
     6037:        62: let pp_u ppf u = pf ppf "0x%04x" (Uchar.to_int u)
     6038:        63: let pp_as_array iter pp ppf x =
     6039:        64:   let sep ppf () = pf ppf ";@ " in
     6040:        65:   pf ppf "@[<2>[|%a|]@]" (pp_iter ~sep iter pp) x
     6041:        66: 
     6042:        67: let intern ppf_ml iter =
     6043:        68:   let t = Hashtbl.create 16 in
     6044:        69:   let n = ref 0 in
     6045:        70:   iter (fun s -> if not (Hashtbl.mem t s) then begin
     6046:        71:     let name = strf "s%03d" !n in
     6047:        72:     Hashtbl.add t s name; incr n;
     6048:        73:     pf ppf_ml "let %s = %S@." name s
     6049:        74:   end);
     6050:        75:   pf ppf_ml "@.";
     6051:        76:   (fun ppf s -> match Hashtbl.find_opt t s with
     6052:        77:    | Some name -> pf ppf "%s" name
     6053:        78:    | None -> pf ppf "%S" s)
     6054:        79: 
     6055:        80: let dump_interval_map (ppf_mli, ppf_ml) ~name ~desc seq =
     6056:        81:   pf ppf_mli "(* %s *)@.val %s: int array * int array * int array@.@." desc name;
     6057:        82:   let xs = to_list (intervals_kv seq) in
     6058:        83:   let aa = List.map (fun (a, _, _) -> a) xs
     6059:        84:   and bb = List.map (fun (_, b, _) -> b) xs
     6060:        85:   and cc = List.map (fun (_, _, c) -> c) xs in
     6061:        86:   let pp_arr pp = pp_as_array List.iter pp in
     6062:        87:   let pp_arr_u = pp_arr pp_u and pp_arr_i = pp_arr Format.pp_print_int in
     6063:        88:   pf ppf_ml "@[<2>let %s =@ @[<1>(%a,@ %a,@ %a)@]@]@.@."
     6064:        89:      name pp_arr_u aa pp_arr_u bb pp_arr_i cc
     6065:        90: 
     6066:        91: let dump_trie_map (ppf_mli, ppf_ml) ~name ~desc ~default f =
     6067:        92:   pf ppf_mli "(* %s *)@.val %s: string array array@.@." desc name;
     6068:        93:   let xs = trie ~default f in
     6069:        94:   let pp_s = intern ppf_ml Array.(fun i -> i ""; iter (iter i) xs) in
     6070:        95:   pf ppf_ml "@[<2>let %s =@ %a@]" name
     6071:        96:     Array.(pp_as_array iter (pp_as_array iter pp_s)) xs
     6072:        97: 
     6073:        98: let pp_header ppf = Format.fprintf ppf
     6074:        99: "(* Do not edit.
     6075:       100:  *
     6076:       101:  * This module contains select unicode properties extracted from Uucp,
     6077:       102:  * using `%s`.
     6078:       103:  *
     6079:       104:  * Unicode version %s.
     6080:       105:  *)
     6081:       106: 
     6082:       107: " Sys.argv.(0) Uucp.unicode_version
     6083:       108: 
     6084:       109: let extract (ppmli, ppml as ppfs) =
     6085:       110: 
     6086:       111:   pp_header ppmli; pp_header ppml;
     6087:       112: 
     6088:       113:   dump_interval_map ppfs
     6089:       114:     ~name:"tty_width_hint"
     6090:       115:     ~desc:"Uucp.Break.tty_width_hint"
     6091:       116:     (* w = -1 is easy to detect.
     6092:       117:        w = 1 covers the most intervals, so we default it. *)
     6093:       118:     (uchars |> map (fun u -> u, Uucp.Break.tty_width_hint u)
     6094:       119:             |> filter (fun (_, w) -> w <> -1 && w <> 1));
     6095:       120: 
     6096:       121:   (* dump_interval_map ppfs *)
     6097:       122:   (*   ~name:"grapheme_cluster_boundary" *)
     6098:       123:   (*   ~desc:"Uucp.Break.Low.grapheme_cluster." *)
     6099:       124:   (*   (1* No single value dominates the histogram. *1) *)
     6100:       125:   (*   (uchars |> map (fun u -> u, Uucp.Break.Low.grapheme_cluster u)); *)
     6101:       126: 
     6102:       127:   dump_trie_map ppfs
     6103:       128:     ~name:"grapheme_cluster_boundary"
     6104:       129:     ~desc:"Uucp.Break.Low.grapheme_cluster."
     6105:       130:     ~default:16 (* 16 - `XX - is by far the most prevalent value *)
     6106:       131:     Uucp.Break.Low.grapheme_cluster;
     6107:       132: 
     6108:       133:   ()
     6109:       134: 
     6110:       135: let file = "src/no-uucp/notty_uucp_data"
     6111:       136: 
     6112:       137: let with_new name f =
     6113:       138:   let o = open_out_gen [Open_trunc; Open_creat; Open_wronly] 0o664 name in
     6114:       139:   let ppf = Format.formatter_of_out_channel o in
     6115:       140:   f ppf; Format.pp_print_flush ppf (); close_out o
     6116:       141: 
     6117:       142: let () =
     6118:       143:   Format.printf "Dumping Unicode v%s data to %s.@." Uucp.unicode_version file;
     6119:       144:   with_new (file ^ ".mli") @@ fun ppmli ->
     6120:       145:     with_new (file ^ ".ml") @@ fun ppml ->
     6121:       146:       extract (ppmli, ppml)
     6122: Removed regular file ../test/dune:
     6123:    1     : (test
     6124:    2     :  (name jj_tui))
     6125: Removed regular file ../test/jj_tui.ml:
     6126:     (empty)
Added regular file test/dune:
        1: (test
        2:  (name jj_tui)
        3:  (libraries jj_tui)
        4:  (preprocess
        5:   (pps ppx_jane ppx_expect)))
Added regular file test/jj_tui.ml:
    (empty)
Added regular file testing/hi:
        1: hiiiiiii
        2: hiiiiiiiiiiii
        3: hiiiiiiiiiiii
Added regular file testing/other/file:
        1: hello Im other
Removed regular file ../jj_tui.install:
   1     : lib: [
   2     :   "_build/install/default/lib/jj_tui/META"
   3     :   "_build/install/default/lib/jj_tui/dune-package"
   4     :   "_build/install/default/lib/jj_tui/opam"
   5     : ]
   6     : bin: [
   7     :   "_build/install/default/bin/jj_tui"
   8     : ]
Removed regular file ../jj_tui.opam:
   1     : # This file is generated by dune, edit dune-project instead
   2     : opam-version: "2.0"
   3     : synopsis: "A short synopsis"
   4     : description: "A longer description"
   5     : maintainer: ["Maintainer Name"]
   6     : authors: ["Author Name"]
   7     : license: "LICENSE"
   8     : tags: ["topics" "to describe" "your" "project"]
   9     : homepage: "https://github.com/username/reponame"
  10     : doc: "https://url/to/documentation"
  11     : bug-reports: "https://github.com/username/reponame/issues"
  12     : depends: [
  13     :   "ocaml"
  14     :   "dune" {>= "3.9"}
  15     :   "odoc" {with-doc}
  16     : ]
  17     : build: [
  18     :   ["dune" "subst"] {dev}
  19     :   [
  20     :     "dune"
  21     :     "build"
  22     :     "-p"
  23     :     name
  24     :     "-j"
  25     :     jobs
  26     :     "@install"
  27     :     "@runtest" {with-test}
  28     :     "@doc" {with-doc}
  29     :   ]
  30     : ]
  31     : dev-repo: "git+https://github.com/username/reponame.git"
Removed regular file ../lib/dune:
   1     : (library
   2     :  (name jj_tui)
   3     :  (libraries core stdio core_unix.command_unix )
   4     :  )
   5     : 
Removed regular file ../lib/process.ml:
   1     : 
   2     : let mk_home_cmd cmd =
   3     :   let home_dir = Unix.getenv "HOME" in
   4     :   Printf.sprintf "HOME=%s %s" home_dir cmd
   5     : 
   6     : let proc_silent cmd =
   7     :   let _exit_code = Unix.system (mk_home_cmd cmd) in
   8     :   ()
   9     : 
  10     : let proc cmd =
  11     :   Printf.eprintf "🐚  %s\n%!" cmd;
  12     :   proc_silent cmd
  13     : 
  14     : let collect_chan (channel : in_channel) : string =
  15     :   let rec loop acc =
  16     :     match input_line channel with
  17     :     | exception End_of_file -> acc
  18     :     | line -> loop (acc ^ line ^ "\n")
  19     :   in
  20     :   loop ""
  21     : 
  22     : let proc_stdout cmd =
  23     :   let ((proc_stdout, _proc_stdin, _proc_stderr) as process) =
  24     :     Unix.open_process_full (mk_home_cmd cmd) [||]
  25     :   in
  26     :   let stdout_result = collect_chan proc_stdout in
  27     :   let _ = Unix.close_process_full process in
  28     :   String.trim stdout_result
  29     : 
  30     : let proc_stdOutAndErr cmd =
  31     :   let ((proc_stdout, _proc_stdin, proc_stderr) as process) =
  32     :     Unix.open_process_full (mk_home_cmd cmd) [||]
  33     :   in
  34     :   let stdout_result = collect_chan proc_stdout in
  35     :   let stderr_result = collect_chan proc_stderr in
  36     :   let _ = Unix.close_process_full process in
  37     :   String.trim (stdout_result^stderr_result)
Removed regular file ../minttea/leaves.install:
   1     : lib: [
   2     :   "_build/install/default/lib/leaves/META"
   3     :   "_build/install/default/lib/leaves/cursor.ml"
   4     :   "_build/install/default/lib/leaves/cursor.mli"
   5     :   "_build/install/default/lib/leaves/dune-package"
   6     :   "_build/install/default/lib/leaves/filtered_list.ml"
   7     :   "_build/install/default/lib/leaves/filtered_list.mli"
   8     :   "_build/install/default/lib/leaves/forms.ml"
   9     :   "_build/install/default/lib/leaves/fps.ml"
  10     :   "_build/install/default/lib/leaves/fps.mli"
  11     :   "_build/install/default/lib/leaves/leaves.a"
  12     :   "_build/install/default/lib/leaves/leaves.cma"
  13     :   "_build/install/default/lib/leaves/leaves.cmi"
  14     :   "_build/install/default/lib/leaves/leaves.cmt"
  15     :   "_build/install/default/lib/leaves/leaves.cmx"
  16     :   "_build/install/default/lib/leaves/leaves.cmxa"
  17     :   "_build/install/default/lib/leaves/leaves.ml"
  18     :   "_build/install/default/lib/leaves/leaves__Cursor.cmi"
  19     :   "_build/install/default/lib/leaves/leaves__Cursor.cmt"
  20     :   "_build/install/default/lib/leaves/leaves__Cursor.cmti"
  21     :   "_build/install/default/lib/leaves/leaves__Cursor.cmx"
  22     :   "_build/install/default/lib/leaves/leaves__Filtered_list.cmi"
  23     :   "_build/install/default/lib/leaves/leaves__Filtered_list.cmt"
  24     :   "_build/install/default/lib/leaves/leaves__Filtered_list.cmti"
  25     :   "_build/install/default/lib/leaves/leaves__Filtered_list.cmx"
  26     :   "_build/install/default/lib/leaves/leaves__Forms.cmi"
  27     :   "_build/install/default/lib/leaves/leaves__Forms.cmt"
  28     :   "_build/install/default/lib/leaves/leaves__Forms.cmx"
  29     :   "_build/install/default/lib/leaves/leaves__Fps.cmi"
  30     :   "_build/install/default/lib/leaves/leaves__Fps.cmt"
  31     :   "_build/install/default/lib/leaves/leaves__Fps.cmti"
  32     :   "_build/install/default/lib/leaves/leaves__Fps.cmx"
  33     :   "_build/install/default/lib/leaves/leaves__Paginator.cmi"
  34     :   "_build/install/default/lib/leaves/leaves__Paginator.cmt"
  35     :   "_build/install/default/lib/leaves/leaves__Paginator.cmti"
  36     :   "_build/install/default/lib/leaves/leaves__Paginator.cmx"
  37     :   "_build/install/default/lib/leaves/leaves__Progress.cmi"
  38     :   "_build/install/default/lib/leaves/leaves__Progress.cmt"
  39     :   "_build/install/default/lib/leaves/leaves__Progress.cmti"
  40     :   "_build/install/default/lib/leaves/leaves__Progress.cmx"
  41     :   "_build/install/default/lib/leaves/leaves__Spinner.cmi"
  42     :   "_build/install/default/lib/leaves/leaves__Spinner.cmt"
  43     :   "_build/install/default/lib/leaves/leaves__Spinner.cmti"
  44     :   "_build/install/default/lib/leaves/leaves__Spinner.cmx"
  45     :   "_build/install/default/lib/leaves/leaves__Sprite.cmi"
  46     :   "_build/install/default/lib/leaves/leaves__Sprite.cmt"
  47     :   "_build/install/default/lib/leaves/leaves__Sprite.cmti"
  48     :   "_build/install/default/lib/leaves/leaves__Sprite.cmx"
  49     :   "_build/install/default/lib/leaves/leaves__Table.cmi"
  50     :   "_build/install/default/lib/leaves/leaves__Table.cmt"
  51     :   "_build/install/default/lib/leaves/leaves__Table.cmx"
  52     :   "_build/install/default/lib/leaves/leaves__Text_input.cmi"
  53     :   "_build/install/default/lib/leaves/leaves__Text_input.cmt"
  54     :   "_build/install/default/lib/leaves/leaves__Text_input.cmti"
  55     :   "_build/install/default/lib/leaves/leaves__Text_input.cmx"
  56     :   "_build/install/default/lib/leaves/opam"
  57     :   "_build/install/default/lib/leaves/paginator.ml"
  58     :   "_build/install/default/lib/leaves/paginator.mli"
  59     :   "_build/install/default/lib/leaves/progress.ml"
  60     :   "_build/install/default/lib/leaves/progress.mli"
  61     :   "_build/install/default/lib/leaves/spinner.ml"
  62     :   "_build/install/default/lib/leaves/spinner.mli"
  63     :   "_build/install/default/lib/leaves/sprite.ml"
  64     :   "_build/install/default/lib/leaves/sprite.mli"
  65     :   "_build/install/default/lib/leaves/table.ml"
  66     :   "_build/install/default/lib/leaves/text_input.ml"
  67     :   "_build/install/default/lib/leaves/text_input.mli"
  68     : ]
  69     : libexec: [
  70     :   "_build/install/default/lib/leaves/leaves.cmxs"
  71     : ]
  72     : doc: [
  73     :   "_build/install/default/doc/leaves/CHANGES.md"
  74     :   "_build/install/default/doc/leaves/LICENSE.md"
  75     :   "_build/install/default/doc/leaves/README.md"
  76     : ]
Removed regular file ../minttea/minttea.install:
   1     : lib: [
   2     :   "_build/install/default/lib/minttea/META"
   3     :   "_build/install/default/lib/minttea/app.ml"
   4     :   "_build/install/default/lib/minttea/command.ml"
   5     :   "_build/install/default/lib/minttea/dune-package"
   6     :   "_build/install/default/lib/minttea/event.ml"
   7     :   "_build/install/default/lib/minttea/io_loop.ml"
   8     :   "_build/install/default/lib/minttea/minttea.a"
   9     :   "_build/install/default/lib/minttea/minttea.cma"
  10     :   "_build/install/default/lib/minttea/minttea.cmi"
  11     :   "_build/install/default/lib/minttea/minttea.cmt"
  12     :   "_build/install/default/lib/minttea/minttea.cmti"
  13     :   "_build/install/default/lib/minttea/minttea.cmx"
  14     :   "_build/install/default/lib/minttea/minttea.cmxa"
  15     :   "_build/install/default/lib/minttea/minttea.ml"
  16     :   "_build/install/default/lib/minttea/minttea.mli"
  17     :   "_build/install/default/lib/minttea/minttea__.cmi"
  18     :   "_build/install/default/lib/minttea/minttea__.cmt"
  19     :   "_build/install/default/lib/minttea/minttea__.cmx"
  20     :   "_build/install/default/lib/minttea/minttea__.ml"
  21     :   "_build/install/default/lib/minttea/minttea__App.cmi"
  22     :   "_build/install/default/lib/minttea/minttea__App.cmt"
  23     :   "_build/install/default/lib/minttea/minttea__App.cmx"
  24     :   "_build/install/default/lib/minttea/minttea__Command.cmi"
  25     :   "_build/install/default/lib/minttea/minttea__Command.cmt"
  26     :   "_build/install/default/lib/minttea/minttea__Command.cmx"
  27     :   "_build/install/default/lib/minttea/minttea__Event.cmi"
  28     :   "_build/install/default/lib/minttea/minttea__Event.cmt"
  29     :   "_build/install/default/lib/minttea/minttea__Event.cmx"
  30     :   "_build/install/default/lib/minttea/minttea__Io_loop.cmi"
  31     :   "_build/install/default/lib/minttea/minttea__Io_loop.cmt"
  32     :   "_build/install/default/lib/minttea/minttea__Io_loop.cmx"
  33     :   "_build/install/default/lib/minttea/minttea__Program.cmi"
  34     :   "_build/install/default/lib/minttea/minttea__Program.cmt"
  35     :   "_build/install/default/lib/minttea/minttea__Program.cmx"
  36     :   "_build/install/default/lib/minttea/minttea__Renderer.cmi"
  37     :   "_build/install/default/lib/minttea/minttea__Renderer.cmt"
  38     :   "_build/install/default/lib/minttea/minttea__Renderer.cmti"
  39     :   "_build/install/default/lib/minttea/minttea__Renderer.cmx"
  40     :   "_build/install/default/lib/minttea/opam"
  41     :   "_build/install/default/lib/minttea/program.ml"
  42     :   "_build/install/default/lib/minttea/renderer.ml"
  43     :   "_build/install/default/lib/minttea/renderer.mli"
  44     : ]
  45     : libexec: [
  46     :   "_build/install/default/lib/minttea/minttea.cmxs"
  47     : ]
  48     : doc: [
  49     :   "_build/install/default/doc/minttea/CHANGES.md"
  50     :   "_build/install/default/doc/minttea/LICENSE.md"
  51     :   "_build/install/default/doc/minttea/README.md"
  52     : ]
Removed regular file ../minttea/spices.install:
   1     : lib: [
   2     :   "_build/install/default/lib/spices/META"
   3     :   "_build/install/default/lib/spices/border.ml"
   4     :   "_build/install/default/lib/spices/dune-package"
   5     :   "_build/install/default/lib/spices/formatter.ml"
   6     :   "_build/install/default/lib/spices/gradient.ml"
   7     :   "_build/install/default/lib/spices/opam"
   8     :   "_build/install/default/lib/spices/spices.a"
   9     :   "_build/install/default/lib/spices/spices.cma"
  10     :   "_build/install/default/lib/spices/spices.cmi"
  11     :   "_build/install/default/lib/spices/spices.cmt"
  12     :   "_build/install/default/lib/spices/spices.cmti"
  13     :   "_build/install/default/lib/spices/spices.cmx"
  14     :   "_build/install/default/lib/spices/spices.cmxa"
  15     :   "_build/install/default/lib/spices/spices.ml"
  16     :   "_build/install/default/lib/spices/spices.mli"
  17     :   "_build/install/default/lib/spices/spices__.cmi"
  18     :   "_build/install/default/lib/spices/spices__.cmt"
  19     :   "_build/install/default/lib/spices/spices__.cmx"
  20     :   "_build/install/default/lib/spices/spices__.ml"
  21     :   "_build/install/default/lib/spices/spices__Border.cmi"
  22     :   "_build/install/default/lib/spices/spices__Border.cmt"
  23     :   "_build/install/default/lib/spices/spices__Border.cmx"
  24     :   "_build/install/default/lib/spices/spices__Formatter.cmi"
  25     :   "_build/install/default/lib/spices/spices__Formatter.cmt"
  26     :   "_build/install/default/lib/spices/spices__Formatter.cmx"
  27     :   "_build/install/default/lib/spices/spices__Gradient.cmi"
  28     :   "_build/install/default/lib/spices/spices__Gradient.cmt"
  29     :   "_build/install/default/lib/spices/spices__Gradient.cmx"
  30     : ]
  31     : libexec: [
  32     :   "_build/install/default/lib/spices/spices.cmxs"
  33     : ]
  34     : doc: [
  35     :   "_build/install/default/doc/spices/CHANGES.md"
  36     :   "_build/install/default/doc/spices/LICENSE.md"
  37     :   "_build/install/default/doc/spices/README.md"
  38     : ]
Added regular file ../notty/.gitignore:
        1: _build
        2: *.install
        3: *.native
        4: *.byte
        5: .merlin
        6: 
        7: tmp
        8: *~
        9: \.\#*
       10: \#*#
       11: 
       12: *.json
       13: gmon.out
       14: rondom
Added regular file ../notty/.ocamlinit:
        1: #require "uucp,uuseg,uutf"
        2: 
        3: #directory "_build/default/src"
        4: #directory "_build/default/src/.notty.objs/byte"
        5: #directory "_build/default/src-unix"
        6: #directory "_build/default/src-unix/.notty_unix.objs/byte"
        7: #directory "_build/default/src-lwt"
        8: #directory "_build/default/src-lwt/.notty_lwt.objs/byte"
        9: 
       10: #load "notty.cma"
       11: #load "notty_unix.cma"
       12: #load "notty_lwt.cma"
       13: 
       14: #use "src/notty_top_init.ml"
Added regular file ../notty/CHANGES.md:
        1: ## v0.2.3 (2022-09-02)
        2: 
        3: * Moved to Dune.
        4: * Renders faster, uses less memory.
        5: * Nested uses of `I.pp_attr` within `I.strf` now stack, instead of replacing.
        6: * Removed dependency on Uucp. Uses internal data instead (Unicode 13).
        7: * Support OCaml 4.08 - 4.14. Thanks to @kit-ty-kate for the 4.14 fixes.
        8: 
        9: ## v0.2.2 (2019-02-19)
       10: 
       11: * Fix a long-standing terminal cleanup bug. Reported by @ttamttam, fix by @cfcs.
       12: 
       13: ## v0.2.1 (2017-11-06)
       14: 
       15: * OCaml 4.06 compatible.
       16: * Cache the internal representation of Unicode strings.
       17: * Remove `I.ichar`. **breaking**
       18: 
       19: ## v0.2.0 (2017-10-31)
       20: 
       21: * All-around speed and memory improvements.
       22: * Draw over lines cell-by-cell instead of using erase-and-skip.
       23:   Slower, but flicker-free drawing.
       24: * `Term.create`: optionally inhibit synthetic TTY signals.
       25: * Cursor origin moved from `(1, 1)` to `(0, 0)`. **breaking**
       26: * `#key` renamed to `#special`. **breaking**
       27: * Added `Term.fds` to get connected file descriptors.
       28: * Added `A.equal` and `I.equal`.
       29: * Switched over to `Uchar.t`. **breaking**
       30: * Separated ASCII from the rest of Unicode input. **breaking**
       31: * Added image pretty-printer `I.pp`.
       32: * Added `notty.top` for use in the toplevel.
       33: * Removed `I.tile`. **breaking**
       34: * Added `I.tabulate`, generalizing `I.tile`.
       35: * Added support for 24-bit color.
       36: * Added `Notty_*.show_cursor` and `Notty_*.move_cursor` for manual cursor
       37:   positioning in inline mode.
       38: * Removed `output_image_endline`. Can be replaced by `eol`. **breaking**
       39: * `Notty_*.output_image` lost the `~clear` parameter. Can be replaced in various
       40:   ways by cursor positioning.
       41: * `Notty_unix.output_image ~chan` renamed to `~fd`. **breaking**
       42: * Added support for bracketed paste.
       43: * More example programs.
       44: 
       45: ## v0.1.1 (2016-02-09)
       46: * `Term.input` -> `Term.event`
       47: * Option to redraw the line
       48: 
       49: ## v0.1.0 (2016-02-09)
       50: * Initial release
Added regular file ../notty/LICENSE.md:
        1: Copyright (c) 2016-2017 David Kaloper Meršinjak
        2: 
        3: Permission to use, copy, modify, and/or distribute this software for any
        4: purpose with or without fee is hereby granted, provided that the above
        5: copyright notice and this permission notice appear in all copies.
        6: 
        7: THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
        8: WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
        9: MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
       10: ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
       11: WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
       12: ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
       13: OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
Added regular file ../notty/README.md:
        1: # Notty — Declaring terminals
        2: 
        3: <a href="https://asciinema.org/a/ZIXzn2ZmIxK39qoT3eJla5OyO" alt="dumper"><img src="https://asciinema.org/a/ZIXzn2ZmIxK39qoT3eJla5OyO.png" width="400"/></a>
        4: <a href="https://asciinema.org/a/TsIhDJv5S00AB2biVmhHRzZ8I" alt="input"><img src="https://asciinema.org/a/TsIhDJv5S00AB2biVmhHRzZ8I.png" width="400"/></a>
        5: <a href="https://asciinema.org/a/z1Pc0Mppg2JFzteZzdeigLwYc" alt="microdots"><img src="https://asciinema.org/a/z1Pc0Mppg2JFzteZzdeigLwYc.png" width="400"/></a>
        6: <a href="https://asciinema.org/a/NgpF9Im8qfUICC39GDDAe9Ede" alt="rain"><img src="https://asciinema.org/a/R94gnHTQhCFJAsWpRfVlZWcUB.png" width="400"/></a>
        7: 
        8: Notty is a declarative terminal library for OCaml structured around a notion
        9: of composable images. It tries to abstract away the basic terminal programming
       10: model, providing something simpler and more expressive.
       11: 
       12: The core layout engine and IO codecs are pure platform-independent OCaml.
       13: Distribution includes modules with input and output facilities for Unix, and Lwt
       14: on Unix.
       15: 
       16: As an attempt to redefine terminal programming, Notty has to be
       17: _opinionated_. It assumes Unicode throughout, does not have universal support
       18: for various terminals out there, and has a peculiar programming and rendering
       19: model.
       20: 
       21: Notty's core API was heavily influenced by Haskell's [Vty][vty].
       22: 
       23: ## Where to start
       24: 
       25: Check out the [documentation], [examples], or peek directly into the [interface]
       26: file.
       27: 
       28: Building with `dune build @ex` will produce several little example programs that
       29: also double as tests.
       30: 
       31: ```OCaml
       32: (* Game of Life with ZX Spectrum kitsch. *)
       33: 
       34: let dot : image = I.uchar A.(fg lightred) (Uchar.of_int 0x25cf) 1 1
       35: 
       36: let background step (n, m) =
       37:   let k = 24. *. sin (float (step + m + n) /. 10.) |> truncate in
       38:   if k > 0 then I.char A.(fg (gray k)) '.' 1 1 else I.void 1 1
       39: 
       40: let render (w, h) step life : image =
       41:   I.tabulate w (h - 1) @@ fun x y ->
       42:     let pt = (x, y) in
       43:     if CSet.mem pt life then dot else background step pt
       44: ```
       45: 
       46: [documentation]: https://pqwy.github.io/notty/doc
       47: [examples]: http://pqwy.github.io/notty/doc/Notty.html#examples
       48: [interface]: https://github.com/pqwy/notty/blob/master/src/notty.mli
       49: [vty]: https://hackage.haskell.org/package/vty
       50: 
       51: ## What?
       52: 
       53: - _Notty?_
       54:   
       55:   Terminals are tedious to program for. Notty tries to abstract the tedium away,
       56:   leaving you with a more pleasant programming surface that's quite unlike a TTY.
       57:   Hence, _No-TTY_.
       58: 
       59: - A new kind of Rust terminal?
       60: 
       61:   This Notty has no connection to any other body of code named Notty.
       62: 
       63: - Why make yet another terminal output library?
       64:   
       65:   Because:
       66:   * It allows one to *describe* what should be seen, as opposed to *commanding*
       67:     a terminal.
       68:   * It's pretty compact. Both bells and whistles can be implemented separately.
       69:   * Core is easy to glue onto various IO backends.
       70:   * Pure platform-independent OCaml.
Added regular file ../notty/benchmarks/dune:
        1: (executable
        2:   (name speed)
        3:   (libraries notty notty.unix common unmark unmark.cli))
Added regular file ../notty/benchmarks/speed.ml:
        1: (* Copyright (c) 2016-2019 David Kaloper Meršinjak. All rights reserved.
        2:    See LICENSE.md. *)
        3: 
        4: open Notty
        5: open Common
        6: open Common.Images
        7: 
        8: 
        9: let decode ?(n=1) str =
       10:   let f cs _ = function `Uchar c -> c::cs | _ -> cs in
       11:   let us = str |> Uutf.String.fold_utf_8 f [] |> List.rev in
       12:   for _ = 1 to n do Unescape.decode us |> ignore done
       13: 
       14: let input ?(n=1) str =
       15:   let buf = Bytes.unsafe_of_string str in
       16:   let rec go f n = match Unescape.next f with
       17:     | #Unescape.event -> go f n
       18:     | `Await when n > 0 ->
       19:         Unescape.input f buf 0 (Bytes.length buf); go f (pred n)
       20:     | `Await -> ()
       21:     | `End   -> assert false in
       22:   go (Unescape.create ()) n
       23: 
       24: let escapes =
       25:   "\027[5~\027[6~\027[1~\027[4~\027OP\027OQ\027OR\027OS\027[15~\027[17~" ^
       26:   "\027[18~\027[19~\027[20~\027[21~\027[23~\027[24~"
       27: 
       28: let escapes_m =
       29:   "\027[<0;59;7M\027[<32;58;7M\027[<32;57;7M\027[<32;56;7M\027[<32;54;7M" ^
       30:   "\027[<32;53;8M\027[<32;52;8M\027[<32;51;8M\027[<32;50;8M\027[<32;49;8M" ^
       31:   "\027[<32;47;9M\027[<32;46;9M\027[<32;44;9M\027[<32;42;10M\027[<32;41;10M" ^
       32:   "\027[<32;41;11M\027[<32;40;11M\027[<32;41;12M\027[<32;42;12M" ^
       33:   "\027[<32;42;13M\027[<32;43;13M\027[<32;44;13M\027[<0;44;13m"
       34: 
       35: let chars = String.(make (length escapes) 'x')
       36: 
       37: let buf = Buffer.create 1024
       38: let buf_render off dim image =
       39:   Buffer.clear buf; Render.to_buffer buf Cap.ansi off dim image
       40: 
       41: 
       42: open Unmark
       43: 
       44: let strf = Format.asprintf
       45: let group_of name xs f = group name (List.map f xs)
       46: let bench_fmt fmt = Format.kasprintf bench fmt
       47: let group_fmt fmt = Format.kasprintf group fmt
       48: 
       49: let render =
       50: 
       51:   let clip i = I.(width i |> min 200, height i |> min 200) in
       52:   let ops i = Operation.of_image (0, 0) (clip i) i
       53:   and render i = buf_render (0, 0) (clip i) i in
       54: 
       55:   group "render" [
       56:     group "rasterize" [
       57:       bench "i2" (fun () -> ops i2)
       58:     ; bench "i3" (fun () -> ops i3)
       59:     ; bench "i4" (fun () -> ops i4)
       60:     ; bench "i5" (fun () -> ops i5)
       61:     ];
       62:     group "render" [
       63:       bench "i2" (fun () -> render i2)
       64:     ; bench "i3" (fun () -> render i3)
       65:     ; bench "i4" (fun () -> render i4)
       66:     ; bench "i5" (fun () -> render i5)
       67:     ];
       68:     group_f "draw" (fun t -> [
       69:       bench "i3" (fun () -> Term.image t i3)
       70:     ; bench "i5" (fun () -> Term.image t i5)
       71:     ]) ~init:Term.create ~fini:Term.release
       72: ]
       73: 
       74: let input = group "input" [
       75:   group "decode" [
       76:     bench "escapes"     (fun () -> decode ~n:100 escapes);
       77:     bench "CSI escapes" (fun () -> decode ~n:100 escapes_m);
       78:     bench "chars"       (fun () -> decode ~n:100 chars);
       79:   ];
       80:   group "input" [
       81:     bench "escapes"     (fun () -> input ~n:100 escapes);
       82:     bench "CSI escapes" (fun () -> input ~n:100 escapes_m);
       83:     bench "chars"       (fun () -> input ~n:100 chars);
       84:   ]
       85: ]
       86: 
       87: let construct =
       88: 
       89:   let strings = [
       90:       "s1", "a"
       91:     ; "s2", "abcdefghij"
       92:     ; "s3", String.repeat 10 "abcdefghij"
       93:     ; "s4", String.repeat 100 "abcdefghij"
       94:     ; "u1", "☭"
       95:     ; "u2", String.repeat 10 "☭"
       96:     ; "u3", String.repeat 100 "☭"
       97:     ; "u4", String.repeat 1000 "☭" ] in
       98: 
       99:   group "construct" [
      100: 
      101:     group "make" (strings |> List.map @@ fun (n, s) ->
      102:       bench n (fun () -> I.string A.empty s))
      103: 
      104:   ; group "repeat" ([0x40; 0x262d] |> List.map @@ fun x ->
      105:       let u = Uchar.of_int x in
      106:       group_fmt "U+%04x" x ([1; 10; 100] |> List.map @@ fun n ->
      107:         bench_fmt "%dx" n (fun () -> I.uchar A.empty u n 1)))
      108: 
      109:   ; bench "pxmatrix" (fun () -> pxmatrix 200 200 @@ fun _ _ -> A.black)
      110:   ]
      111: 
      112: 
      113: let _ = Unmark_cli.main "Notty" [ render; input; construct ]
Added regular file ../notty/dune-project:
        1: (lang dune 1.7)
        2: (name notty)
        3: (version %%VERSION_NUM%%)
Added regular file ../notty/examples/almondbread.ml:
        1: open Notty
        2: open Common
        3: 
        4: let iter = 200
        5: 
        6: let member x y =
        7:   let rec go cx cy x y n =
        8:     let xx = x *. x and yy = y *. y in
        9:     if n = 0 || xx +. yy > 4. then n else
       10:       go cx cy (xx -. yy +. cx) (2. *. x *. y +. cy) (n - 1) in
       11:   float (iter - go x y 0. 0. iter) /. float iter
       12: 
       13: let pi2   = 2. *. 3.14159
       14: let pi2_3 = pi2 /. 3.
       15: 
       16: let mandelbrot x y =
       17:   (* let esc = 1. -. member x y in *)
       18:   (* 23. *. esc *. esc |> truncate |> A.gray *)
       19:   match member x y with
       20:   | 1.  -> A.gray 0
       21:   | esc ->
       22:       let t = esc *. pi2 in
       23:       let f d = (sin (t +. d) *. 128. +. 128.) |> truncate in
       24:       A.rgb_888 ~b:(f (-.pi2_3)) ~g:(f 0.) ~r:(f pi2_3)
       25: 
       26: let xlate dx dy f x y = f (x -. dx) (y -. dy)
       27: let scale k f = let k1 = 1./.k in fun x y -> f (x *. k1) (y *. k1)
       28: let rot a f =
       29:   let sina = sin a and cosa = cos a in fun x y ->
       30:     f (x *. cosa -. y *. sina) (x *. sina +. cosa *. y)
       31: 
       32: let render_unit f (w, h) =
       33:   let sw = 1. /. float w
       34:   and sh = 1. /. float (2 * h) in
       35:   pxmatrix w h (fun x y -> f (float x *. sw) (float y *. sh))
       36: 
       37: let () =
       38:   let pix =
       39:     render_unit @@
       40:     rot (-1.570795) @@ xlate (1.6) (-0.5) @@
       41:     mandelbrot in
       42:   Notty_unix.(output_image_size @@ fun (w, h) -> pix (w, h - 1) |> eol)
Added regular file ../notty/examples/colors.ml:
        1: (* Copyright (c) 2016-2017 David Kaloper Meršinjak. All rights reserved.
        2:    See LICENSE.md. *)
        3: 
        4: (**
        5:  * Demonstrates text attributes.
        6:  *)
        7: open Notty
        8: open Common
        9: 
       10: let colors = A.[
       11:   "black"        , black
       12: ; "red"          , red
       13: ; "green"        , green
       14: ; "yellow"       , yellow
       15: ; "blue"         , blue
       16: ; "magenta"      , magenta
       17: ; "cyan"         , cyan
       18: ; "white"        , white
       19: ; "lightblack"   , lightblack
       20: ; "lightred"     , lightred
       21: ; "lightgreen"   , lightgreen
       22: ; "lightyellow"  , lightyellow
       23: ; "lightblue"    , lightblue
       24: ; "lightmagenta" , lightmagenta
       25: ; "lightcyan"    , lightcyan
       26: ; "lightwhite"   , lightwhite
       27: ]
       28: 
       29: let styles = A.[
       30:   "empty"      , empty
       31: ; "bold"       , st bold
       32: ; "italic"     , st italic
       33: ; "underline"  , st underline
       34: ; "blink"      , st blink
       35: ; "reverse"    , st reverse
       36: ; "bold/italic", st bold ++ st italic
       37: ; "rev/underln", st underline ++ st reverse
       38: ; "bold/rev"   , st reverse ++ st bold
       39: ]
       40: 
       41: let image w =
       42:   let open List in
       43:   let core16 =
       44:     let c1  = map (fun (n, c) -> I.string A.(fg c) n) colors
       45:     and c2  = map (fun (n, c) -> I.string A.(fg black ++ bg c) n) colors
       46:     in I.(vcat c1 <|> void 1 0 <|> vcat c2)
       47:   and attr =
       48:     I.( styles |> map (fun (n, s) -> hpad 0 1 (string s n)) |> hcat) in
       49:   let combine imgs =
       50:     List.map I.(fun (n, i) -> string A.empty n <-> i <-> void 0 1) imgs
       51:     |> I.vcat |> I.pad ~l:1 ~t:1 in
       52:   combine [
       53:     "System colors:",     core16;
       54:     "Color cube, 6x6x6:", Images.c_cube_ix;
       55:     "Grayscale ramp:",    Images.c_gray_ramp;
       56:     "24bit:",             Images.c_rainbow (w - 2) 1;
       57:     "Text styles:",       attr
       58:   ]
       59: 
       60: let () = Notty_unix.output_image_size @@ fun (w, _) -> image w
Added regular file ../notty/examples/common.ml:
        1: (* Copyright (c) 2016-2017 David Kaloper Meršinjak. All rights reserved.
        2:    See LICENSE.md. *)
        3: 
        4: open Notty
        5: open Notty.Infix
        6: 
        7: let pow n e = int_of_float (float n ** float e)
        8: 
        9: module List = struct
       10: 
       11:   include List
       12: 
       13:   let rec replicate n a = if n < 1 then [] else a :: replicate (n - 1) a
       14: 
       15:   let rec range a b = if a > b then [] else a :: range (a + 1) b
       16: 
       17:   let rec intersperse a = function
       18:     | [] | [_] as t -> t
       19:     | x::xs         -> x :: a :: intersperse a xs
       20: 
       21:   let rec take n = function
       22:     | x::xs when n > 0 -> x :: take (pred n) xs
       23:     | _ -> []
       24: 
       25:   let rec splitat n = function
       26:     | x::xs when n > 0 ->
       27:         let (a, b) = splitat (pred n) xs in (x::a, b)
       28:     | xs -> ([], xs)
       29: 
       30:   let rec chunks n xs =
       31:     match splitat n xs with
       32:     | (a, []) -> [a]
       33:     | (a, b)  -> a :: chunks n b
       34: 
       35:   let rec zip xs ys = match (xs, ys) with
       36:     | ([], _) | (_, []) -> []
       37:     | (x::xs, y::ys) -> (x, y) :: zip xs ys
       38: 
       39: end
       40: 
       41: module String = struct
       42: 
       43:   include String
       44: 
       45:   let repeat n str =
       46:     let b = Buffer.create 16 in
       47:     for _ = 1 to n do Buffer.add_string b str done;
       48:     Buffer.contents b
       49: end
       50: 
       51: let tile w h i = I.tabulate w h (fun _ _ -> i)
       52: 
       53: (** A few images used in several places. *)
       54: module Images = struct
       55: 
       56:   let i1 =
       57:     I.(string A.(fg lightblack) "omgbbq" <->
       58:        string A.(fg white ++ bg red) "@")
       59:     <|> I.(pad ~t:2 @@ string A.(fg green) "xo")
       60: 
       61:   let i2 = I.(hpad 1 1 (hcrop 1 1 @@ tile 3 3 i1) <|> i1)
       62: 
       63:   let i3 = tile 5 5 i2
       64: 
       65:   let i4 =
       66:     let i = I.(i3 <|> crop ~t:1 i3 <|> i3) in
       67:     I.(crop ~l:1 i <-> crop ~r:1 i <-> crop ~b:2 i)
       68: 
       69:   let i5 =
       70:     tile 5 1 List.(
       71:       range 0 15 |> map (fun i -> I.pad ~t:i ~l:(i*2) i2) |> I.zcat
       72:     )
       73: 
       74:   let c_gray_ramp =
       75:     I.tabulate 24 1 (fun g _ -> I.string A.(bg (gray g)) " ")
       76: 
       77:   let c_cube_ix =
       78:     I.tabulate 6 1 @@ fun r _ ->
       79:       I.hpad 0 1 @@ I.tabulate 6 6 @@ fun b g ->
       80:         I.string A.(bg (rgb ~r ~g ~b)) " "
       81: 
       82:   let c_cube_rgb =
       83:     let f x = [| 0x00; 0x5f; 0x87; 0xaf; 0xd7; 0xff |].(x) in
       84:     I.tabulate 6 1 @@ fun r _ ->
       85:       I.hpad 0 1 @@ I.tabulate 6 6 @@ fun b g ->
       86:         I.string A.(bg (rgb_888 ~r:(f r) ~g:(f g) ~b:(f b))) " "
       87: 
       88:   let c_rainbow w h =
       89:     let pi2     = 2. *. 3.14159 in
       90:     let pi2_3   = pi2 /. 3.
       91:     and f t off = sin (t +. off) *. 128. +. 128. |> truncate in
       92:     let color t = A.rgb_888 ~r:(f t (-.pi2_3)) ~g:(f t 0.) ~b:(f t pi2_3) in
       93:     I.tabulate (w - 1) 1 @@ fun x _ ->
       94:       let t = (pi2 *. float x /. float w) +. 3.7 in
       95:       I.char A.(bg (color t)) ' ' 1 h
       96: 
       97:   (* U+25CF BLACK CIRCLE *)
       98:   let dot color = I.string (A.fg color) "●"
       99:   (* U+25AA BLACK SMALL SQUARE *)
      100:   let square color = I.string (A.fg color) "▪"
      101: 
      102:   let rec cantor = function
      103:     | 0 -> square A.lightblue
      104:     | n ->
      105:         let sub = cantor (pred n) in
      106:         I.hcat (List.replicate (pow 3 n) (square A.lightblue)) <->
      107:         (sub <|> I.void (pow 3 (n - 1)) 0 <|> sub)
      108: 
      109:   let checker n m i =
      110:     let w = I.width i in
      111:     I.(tile (n/2) (m/2) (hpad 0 w i <-> hpad w 0 i))
      112: 
      113:   let checker1 = checker 20 20 I.(char A.(bg magenta) ' ' 2 1)
      114: 
      115:   let rec sierp c n = I.(
      116:     if n > 1 then
      117:       let ss = sierp c (pred n) in ss <-> (ss <|> ss)
      118:     else hpad 1 0 (square c)
      119:   )
      120: 
      121:   let grid xxs = xxs |> List.map I.hcat |> I.vcat
      122: 
      123:   let outline attr i =
      124:     let (w, h) = I.(width i, height i) in
      125:     let chr x = I.uchar attr (Uchar.of_int x) 1 1
      126:     and hbar  = I.uchar attr (Uchar.of_int 0x2500) w 1
      127:     and vbar  = I.uchar attr (Uchar.of_int 0x2502) 1 h in
      128:     let (a, b, c, d) = (chr 0x256d, chr 0x256e, chr 0x256f, chr 0x2570) in
      129:     grid [ [a; hbar; b]; [vbar; i; vbar]; [d; hbar; c] ]
      130: end
      131: 
      132: let halfblock = "▄"
      133: 
      134: let pxmatrix w h f = I.tabulate w h @@ fun x y ->
      135:   let y = y * 2 in
      136:   I.string A.(bg (f x y) ++ fg (f x (y + 1))) halfblock
      137: 
      138: module Term = Notty_unix.Term
      139: 
      140: let simpleterm ~imgf ~f ~s =
      141:   let term = Term.create () in
      142:   let imgf (w, h) s =
      143:     I.(string A.(fg lightblack) "[ESC quits.]" <-> imgf (w, h - 1) s) in
      144:   let rec go s =
      145:     Term.image term (imgf (Term.size term) s);
      146:     match Term.event term with
      147:     | `End | `Key (`Escape, []) | `Key (`ASCII 'C', [`Ctrl]) -> ()
      148:     | `Resize _ -> go s
      149:     | #Unescape.event as e ->
      150:         match f s e with Some s -> go s | _ -> ()
      151:   in go s
Added regular file ../notty/examples/common_lwt.ml:
        1: (* Copyright (c) 2016-2017 David Kaloper Meršinjak. All rights reserved.
        2:    See LICENSE.md. *)
        3: 
        4: open Notty
        5: open Lwt.Infix
        6: 
        7: include Common
        8: 
        9: module T = Notty_lwt.Term
       10: 
       11: let simpleterm_lwt ~imgf ~f ~s =
       12:   let term = T.create () in
       13:   let imgf (w, h) s =
       14:     I.(string A.(fg lightblack) "[ESC quits.]" <-> imgf (w, h - 1) s) in
       15:   let step e s = match e with
       16:     | `Key (`Escape, []) | `Key (`ASCII 'C', [`Ctrl]) ->
       17:         T.release term >|= fun () -> s
       18:     | `Resize dim -> T.image term (imgf dim s) >|= fun () -> s
       19:     | #Unescape.event as e ->
       20:         match f s e with
       21:         | Some s -> T.image term (imgf (T.size term) s) >|= fun () -> s
       22:         | None   -> T.release term >|= fun () -> s
       23:   in
       24:   ( T.image term (imgf (T.size term) s)
       25:     >>= fun () -> Lwt_stream.fold_s step (T.events term) s )
       26:   |> Lwt_main.run |> ignore
       27: 
       28: 
       29: let timer = function
       30:   | None   -> Lwt.wait () |> fst
       31:   | Some t -> Lwt_unix.sleep t >|= fun _ -> `Timer
       32: 
       33: let event e = Lwt_stream.get (T.events e) >|= function
       34:   | Some (`Resize _ | #Unescape.event as x) -> x
       35:   | None -> `End
       36: 
       37: let simpleterm_lwt_timed ?delay ~f s0 =
       38:   let term = T.create () in
       39:   let rec loop (e, t) dim s =
       40:     (e <?> t) >>= function
       41:     | `End | `Key (`Escape, []) | `Key (`ASCII 'C', [`Ctrl]) ->
       42:         Lwt.return_unit
       43:     | `Resize dim as evt     -> invoke (event term, t) dim s evt
       44:     | #Unescape.event as evt -> invoke (event term, t) dim s evt
       45:     | `Timer as evt          -> invoke (e, timer delay) dim s evt
       46:   and invoke es dim s e =
       47:     match f dim s e with
       48:     | `Continue s    -> loop es dim s
       49:     | `Redraw (s, i) -> T.image term i >>= fun () -> loop es dim s
       50:     | `Stop          -> Lwt.return_unit in
       51:   let size = T.size term in
       52:   loop (event term, timer delay) size s0
Added regular file ../notty/examples/crops.ml:
        1: (* Copyright (c) 2016-2017 David Kaloper Meršinjak. All rights reserved.
        2:    See LICENSE.md. *)
        3: 
        4: (**
        5:  * Demonstrates edge-case behavior of functions that produce rectangle-like
        6:  * things.
        7:  *)
        8: open Notty
        9: open Common
       10: 
       11: let hdistribute ?align w imgs =
       12:   let n = List.length imgs in
       13:   I.(List.map (hsnap ?align (w / n)) imgs |> hcat)
       14: 
       15: let take w h i = I.(vsnap h i |> hsnap w)
       16: 
       17: let () =
       18:   simpleterm ~s:(2, 2)
       19:     ~f:(fun (w, h as s) -> function
       20:         `Key (`Arrow `Left, _) -> Some (w - 1, h)
       21:       | `Key (`Arrow `Right, _) -> Some (w + 1, h)
       22:       | `Key (`Arrow `Up, _) -> Some (w, h - 1)
       23:       | `Key (`Arrow `Down, _) -> Some (w, h + 1)
       24:       | `Key (`ASCII '0', _) -> Some (0, 0)
       25:       | _ -> Some s)
       26:     ~imgf:I.(fun (ow, oh) (w, h) ->
       27:       let (a1, a2, a3) = A.(fg lightmagenta, fg lightred, fg lightblue) in
       28:       strf "Sizing edge behavior. Dim: (%d, %d)" w h <->
       29:       ( hdistribute ow Images.[
       30:           outline a1 (uchar a1 (Uchar.of_int 0x2022) w h)
       31:         ; outline a2 (uchar a2 (Uchar.of_int 0x2022) 300 300 |> take w h)
       32:         ; outline a3 (void w h)
       33:         ] |> vsnap (oh - 4) )
       34:       <->
       35:       hdistribute ow [string a1 "char"; string a2 "crop"; string a3 "void"]
       36:     )
Added regular file ../notty/examples/cursor.ml:
        1: (* Copyright (c) 2016-2017 David Kaloper Meršinjak. All rights reserved.
        2:    See LICENSE.md. *)
        3: 
        4: open Notty
        5: open Common
        6: 
        7: let rec main t (x, y as pos) =
        8:   let img =
        9:     let dot = I.string A.(bg lightred ++ fg black) "✓" |> I.pad ~l:x ~t:y
       10:     and txt = I.strf ~attr:A.(fg lightblack) "@(%d, %d)" x y in
       11:     I.(txt </> dot) in
       12:   Term.image t img;
       13:   Term.cursor t (Some pos);
       14:   match Term.event t with
       15:   | `End | `Key (`Escape, []) | `Key (`ASCII 'C', [`Ctrl]) -> ()
       16:   | `Resize _ -> main t pos
       17:   | `Mouse ((`Press _ | `Drag), pos, _) -> main t pos
       18:   | `Key (`Arrow d, _) ->
       19:     ( main t @@ match d with
       20:       | `Up    -> (x, y - 1)
       21:       | `Down  -> (x, y + 1)
       22:       | `Left  -> (x - 1, y)
       23:       | `Right -> (x + 1, y) )
       24:   | _ -> main t pos
       25: 
       26: let () = main (Term.create ()) (0, 1)
Added regular file ../notty/examples/cuts.ml:
        1: (* Copyright (c) 2016-2017 David Kaloper Meršinjak. All rights reserved.
        2:    See LICENSE.md. *)
        3: 
        4: (**
        5:  * Demonstrates text cropping, particularly of grapheme clusters and wide
        6:  * characters.
        7:  *)
        8: open Notty
        9: open Notty_unix
       10: open Common
       11: 
       12: let hpadwith attr c a b i =
       13:   I.(char attr c a 1 <|> i <|> char attr c b 1)
       14: 
       15: let cuts i =
       16:   let w = I.width i in
       17:   List.(
       18:     range 0 w |> map (fun a ->
       19:       range 0 (w - a) |> map (fun b ->
       20:         i |> I.hcrop a b |> hpadwith A.(fg lightblack) '.' a b
       21:       ) |> I.vcat |> I.hpad 1 1
       22:     ) |> I.hcat |> I.vpad 1 1
       23:   )
       24: 
       25: let colors = A.[red; green; yellow; blue; magenta; cyan]
       26: 
       27: let patterns = [
       28:   "desu"
       29: ; ".▪e\204\129●."
       30: ; "(茶‸茶‶)"
       31: ; "(⌐■_■)"
       32: (* ; "¯\\(ツ)/¯" *)
       33: (* ; "ಠ_ಠ" *)
       34: (* ; "ಡ_ಡ" *)
       35: (* ; "\xe0\xb2\xa0\x5f\xe0\xb1\x83" *)
       36: (* ; "ತಎತ" *)
       37: (* ; "ಥ_ಥ" *)
       38: ; "ᕕ( ᐛ )ᕗ"
       39: (* ; "ᕙ(⇀‸↼‶)ᕗ" *)
       40: (* ; "ᕦ(ò_óˇ)ᕤ" *)
       41: (* ; "(╯ ︵╰ )" *)
       42: (* ; "\x28\x20\xcd\xa1\xc2\xb0\x20\xcd\x9c\xca\x96\x20\xcd\xa1\xc2\xb0\x29" *)
       43: ]
       44: 
       45: 
       46: let () =
       47:   let open I in
       48: 
       49:   patterns |> List.map (fun s ->
       50:     cuts (string A.(fg lightmagenta ++ bg lightblack) s)
       51:   ) |> I.vcat |> eol |> output_image ;
       52: 
       53:   colors |> List.mapi (fun i c ->
       54:     pad ~l:i ~t:i (
       55:       string A.(fg black ++ bg c ++ st blink) "茶" <|>
       56:       pad ~l:2 ~t:1
       57:         (string A.(fg c ++ st blink) "PARTY!"))
       58:   ) |> zcat |> pad ~l:2 ~t:2 ~b:2 |> output_image
Added regular file ../notty/examples/dune:
        1: (library
        2:   (name common)
        3:   (modules common)
        4:   (libraries notty notty.unix))
        5: 
        6: (library
        7:   (name common_lwt)
        8:   (modules common_lwt)
        9:   (libraries common notty.lwt))
       10: 
       11: (executables
       12:   (names testpatterns colors almondbread crops cursor cuts emoji inline keys
       13:          letters mouse thisbig runes sierpinski rain sierpinski_lwt linear
       14:          life)
       15:   (modules testpatterns colors almondbread crops cursor cuts emoji inline keys
       16:            letters mouse thisbig runes sierpinski rain sierpinski_lwt linear
       17:            life)
       18:   (libraries common common_lwt))
       19: 
       20: (alias
       21:   (name ex)
       22:   (package notty)
       23:   (deps testpatterns.exe colors.exe almondbread.exe crops.exe cursor.exe
       24:         cuts.exe emoji.exe inline.exe keys.exe letters.exe mouse.exe
       25:         thisbig.exe runes.exe sierpinski.exe rain.exe sierpinski_lwt.exe
       26:         linear.exe life.exe))
Added regular file ../notty/examples/emoji.ml:
        1: open Notty
        2: open Common
        3: 
        4: let es = [
        5:   [0x2e; 0x2e; 0x2e; 0x2e];
        6:   [0x25aa; 0x25fe; 0x25fc; 0x2b1b];
        7:   [0x1f346; 0x1f351; 0x1f605; 0x1f4a6];
        8:   [0x1f62d; 0x1f52a; 0x1f52a; 0x1f47c];
        9: ]
       10: 
       11: let image =
       12:   es |> List.(map (map @@ fun x ->
       13:     let i = I.uchar A.(fg lightwhite) (Uchar.of_int x) 1 1 in
       14:     I.(pad ~r:(3 - width i) i)
       15:   )) |> Images.grid |> I.pad ~l:1 |> Images.outline A.(fg lightblack)
       16: 
       17: let () = Notty_unix.output_image_size @@ fun (w, _) ->
       18:   I.(pad ~l:((w - width image) / 2) ~b:1 image)
Added regular file ../notty/examples/inline.ml:
        1: (* Copyright (c) 2017 David Kaloper Meršinjak. All rights reserved.
        2:    See LICENSE.md. *)
        3: 
        4: (** Demonstrates manual cursor positioning. *)
        5: 
        6: open Notty
        7: open Notty.Infix
        8: open Notty_unix
        9: 
       10: let sleep n = flush stdout; Unix.select [] [] [] n |> ignore
       11: 
       12: let pp_str attr = I.pp_attr attr Format.pp_print_string
       13: 
       14: let rewind n = move_cursor `Home; move_cursor (`By (0, - (max n 0)))
       15: 
       16: let output_subst ~prev i =
       17:   let h = I.height prev in
       18:   let d = h - I.height i in
       19:   if d > 0 then ( rewind (d - 1); output_image (I.void 0 d) );
       20:   rewind (h - 1); output_image i
       21: 
       22: let cmyk = function
       23:   | 0 -> A.rgb ~r:0 ~g:5 ~b:5
       24:   | 1 -> A.rgb ~r:5 ~g:0 ~b:5
       25:   | 2 -> A.rgb ~r:5 ~g:5 ~b:0
       26:   | 3 -> A.rgb ~r:0 ~g:0 ~b:0
       27:   | _ -> A.rgb ~r:5 ~g:5 ~b:5
       28: 
       29: let () =
       30: 
       31:   let (w, h) = match winsize Unix.stdout with
       32:     Some dim -> dim | _ -> assert false
       33:   and attr = A.(fg lightwhite ++ bg blue) in
       34:   let img1 =
       35:     I.(string attr "THE BLUE STRIPE ABOVE" <->
       36:          tabulate 1 h (fun _ _ -> I.strf "HIDDEN"))
       37:   and img2 =
       38:     I.(strf "Top line. There's a %a above. ^^^"
       39:          (pp_str attr) "blue stripe" |> vpad 0 2) in
       40: 
       41:   output_image img1; output_subst ~prev:img1 img2;
       42: 
       43:   output_image I.(string A.(fg white) "[..]" |> eol);
       44:   for i = 0 to 5 do
       45:     let a  = A.(bg (rgb ~r:i ~b:(5 - i) ~g:0)) in
       46:     let bg = I.tabulate 1 i (fun _ -> I.strf "HIDDEN [%d]") |> eol
       47:     and fg = I.char a ' ' 19 (5 - i) <|> I.char a '-' 1 (5 - i) |> eol in
       48:     output_image bg; output_subst ~prev:bg fg;
       49:   done;
       50:   output_image I.(string A.(fg white) "[..]" |> vpad 0 2);
       51: 
       52:   let rec go prev n =
       53:     if n <= w then
       54:       let h = log (float n) |> truncate in
       55:       let i = prev <|> I.tabulate 1 h (fun _ y -> I.char A.(bg (cmyk y)) ' ' 1 1) in
       56:       output_subst ~prev i; sleep 0.01; go i (n + 1)
       57:     else output_subst ~prev I.empty in
       58:   show_cursor false;
       59:   go I.empty 1;
       60:   show_cursor true;
       61: 
       62:   output_image
       63:     I.(strf "It doesn't say %a anywhere on screen, either."
       64:         (pp_attr A.(fg white) Format.pp_print_string) "hidden" |> eol)
       65: 
Added regular file ../notty/examples/keys.ml:
        1: (* Copyright (c) 2016-2017 David Kaloper Meršinjak. All rights reserved.
        2:    See LICENSE.md. *)
        3: 
        4: (**
        5:  * Demonstrates input parsing.
        6:  *)
        7: open Notty
        8: open Common
        9: 
       10: let pps = Format.pp_print_string
       11: let ppi = Format.pp_print_int
       12: 
       13: let pp_special fmt = function
       14:   | `Escape       -> pps fmt "ESCAPE"
       15:   | `Enter        -> pps fmt "ENTER"
       16:   | `Tab          -> pps fmt "TAB"
       17:   | `Backspace    -> pps fmt "BACKSPACE"
       18:   | `Arrow `Up    -> pps fmt "UP"
       19:   | `Arrow `Down  -> pps fmt "DOWN"
       20:   | `Arrow `Left  -> pps fmt "LEFT"
       21:   | `Arrow `Right -> pps fmt "RIGHT"
       22:   | `Page `Up     -> pps fmt "PAGE UP"
       23:   | `Page `Down   -> pps fmt "PAGE DOWN"
       24:   | `Home         -> pps fmt "HOME"
       25:   | `End          -> pps fmt "END"
       26:   | `Insert       -> pps fmt "INSERT"
       27:   | `Delete       -> pps fmt "DELETE"
       28:   | `Function n   -> pps fmt "FN"; ppi fmt n
       29: 
       30: let pp_mods fmt = function
       31:   | [] -> ()
       32:   | ms -> ms |> List.iter (fun m ->
       33:       pps fmt @@ match m with `Meta -> "M" | `Ctrl -> "C" | `Shift -> "S"
       34:     )
       35: 
       36: let pp_mouse fmt = function
       37:   | `Release -> pps fmt "Release"
       38:   | `Drag    -> pps fmt "Drag"
       39:   | `Move    -> pps fmt "Move"
       40:   | `Press k ->
       41:       pps fmt "Press ";
       42:       pps fmt @@ match k with
       43:         | `Left         -> "Left"
       44:         | `Middle       -> "Middle"
       45:         | `Right        -> "Right"
       46:         | `Scroll `Up   -> "Scroll Up"
       47:         | `Scroll `Down -> "Scroll Down"
       48: 
       49: let pp_u ppf u = Format.fprintf ppf "U+%04X" (Uchar.to_int u)
       50: 
       51: let () =
       52:   let magenta = A.(fg lightmagenta ++ bg black)
       53:   and green   = A.(fg lightgreen   ++ bg black)
       54:   and blue    = A.(fg lightblue    ++ bg black) in
       55:   let pp_mods  = I.pp_attr green pp_mods
       56:   and pp_mouse = I.pp_attr blue pp_mouse in
       57:   simpleterm ~s:[]
       58:     ~f:(fun xs x -> Some (List.take 100 (x::xs)))
       59:     ~imgf:(fun (_, h) xs ->
       60:       let attr = magenta in
       61:       let msg = I.string A.empty "Push keys."
       62:       and ks = List.map (function
       63:         | `Key ((`ASCII _ | `Uchar _) as c, mods) ->
       64:             let u = Unescape.uchar c in
       65:             I.(uchar blue u 1 1 <|> strf ~attr " %a %a" pp_u u pp_mods mods)
       66:         | `Key (#Unescape.special as k, mods) ->
       67:             I.strf ~attr "%a %a" pp_special k pp_mods mods
       68:         | `Mouse (e, (x, y), mods) ->
       69:             I.strf ~attr "MOUSE %a (%d, %d) %a" pp_mouse e x y pp_mods mods
       70:         | `Paste e ->
       71:             I.strf ~attr "PASTE %s" (if e = `Start then "START" else "END")
       72:         ) xs |> I.vcat in
       73:       I.(vsnap ~align:`Top (h - 3) ks <-> void 0 1 <-> msg |> pad ~l:1 ~t:1))
Added regular file ../notty/examples/letters.ml:
        1: (* Copyright (c) 2016-2017 David Kaloper Meršinjak. All rights reserved.
        2:    See LICENSE.md. *)
        3: 
        4: (**
        5:  * Dancing letters.
        6:  *)
        7: open Notty
        8: open Common
        9: 
       10: let nw = 6
       11: and nh = 5
       12: 
       13: let () =
       14:   simpleterm ~s:[]
       15:     ~f:(fun us -> function
       16:       | `Key ((`Delete|`Backspace), _) ->
       17:           Some (match us with _::xs -> xs | _ -> us)
       18:       | `Key ((`ASCII _|`Uchar _ as u), _) ->
       19:           Some (List.take (nw * nh) (Unescape.uchar u :: us))
       20:       | _  -> Some us)
       21:     ~imgf:(fun _ us ->
       22:       let open List in
       23:       let uus = chunks nw (rev us) in
       24:       mapi (fun i us ->
       25:         mapi (fun j u ->
       26:           I.uchar A.(fg white ++ bg (rgb ~r:0 ~g:i ~b:j)) u 1 1
       27:         ) us |> I.hcat
       28:       ) uus |> I.vcat
       29:       |> I.pad ~t:1 ~l:1
       30:       |> I.hsnap ~align:`Left (nw + 1)
       31:       |> tile nw 1)
Added regular file ../notty/examples/life.ml:
        1: (* Copyright (c) 2016-2017 David Kaloper Meršinjak. All rights reserved.
        2:    See LICENSE.md. *)
        3: 
        4: (*
        5:  * Game of Life with some ZX spectrum kitsch.
        6:  *)
        7: 
        8: let flip f a b = f b a
        9: 
       10: (** Live, **)
       11: 
       12: module Coord = struct
       13:   type t = int * int
       14:   let compare ((a, b) : t) (c, d) =
       15:     match compare a c with 0 -> compare b d | r -> r
       16:   let equal ((a, b) : t) (c, d) = a = c && b = d
       17: end
       18: 
       19: module CSet = struct
       20:   include Set.Make (Coord)
       21:   let of_list = List.fold_left (flip add) empty
       22:   let map f s = fold (fun x s -> add (f x) s) s empty
       23: end
       24: 
       25: module CMap = struct
       26:   include Map.Make (Coord)
       27:   let preimg p m =
       28:     fold (fun k v s -> if p v then CSet.add k s else s) m CSet.empty
       29: end
       30: 
       31: let erem x y = (x mod y + y) mod y
       32: let square (w, h) (a, b as ab) =
       33:   if a < 0 || a >= w || b < 0 || b >= h then (-1, -1) else ab
       34: let torus (w, h) (a, b) = (erem a w, erem b h)
       35: let moebius (w, h) (a, b as ab) =
       36:   if a < 0 || a >= w then (erem a w, h - b - 1) else ab
       37: 
       38: let neigh topo (a, b) = [
       39:   (a-1, b); (a+1, b); (a-1, b-1); (a-1, b+1)
       40: ; (a, b-1); (a, b+1); (a+1, b-1); (a+1, b+1)
       41: ] |> List.map topo
       42: 
       43: let step topo life =
       44:   let nlive pt =
       45:     List.(neigh topo pt |> filter (flip CSet.mem life) |> length) in
       46:   let f1 pt acc =
       47:     pt :: neigh topo pt |> List.fold_left (fun acc -> function
       48:       | (-1, -1) -> acc
       49:       | pt when CMap.mem pt acc -> acc
       50:       | pt ->
       51:           let n = nlive pt in
       52:           acc |> CMap.add pt
       53:             (if n = 3 || (n = 2 && CSet.mem pt life) then 0 else 1)
       54:     ) acc in
       55:   CSet.fold f1 life CMap.empty |> CMap.preimg ((=) 0)
       56: 
       57: let glider = CSet.of_list [(2,1); (3,2); (1,3); (2,3); (3,3)]
       58: 
       59: (** ...render, **)
       60: 
       61: open Notty
       62: open Notty.Infix
       63: 
       64: let dot = I.string A.(fg lightred) "●"
       65: 
       66: let background step (n, m) =
       67:   let k = 24. *. sin (float (step + m + n) /. 10.) |> truncate in
       68:   if k > 0 then I.string A.(fg (gray k)) "." else I.void 1 1
       69: 
       70: let render (w, h) step life =
       71:   I.tabulate w (h - 1) (fun x y ->
       72:     let pt = (x, y) in if CSet.mem pt life then dot else background step pt
       73:   ) <->
       74:   I.(strf ~attr:A.(fg lightblack) "[generation %04d]" step |>
       75:       hsnap ~align:`Right w)
       76: 
       77: (** ...and interact. **)
       78: 
       79: open Lwt.Infix
       80: open Notty_lwt
       81: 
       82: let timer () = Lwt_unix.sleep 0.1 >|= fun () -> `Timer
       83: let event term = Lwt_stream.get (Term.events term) >|= function
       84:   | Some (`Resize _ | #Unescape.event as x) -> x
       85:   | None -> `End
       86: 
       87: let rec loop term (e, t) (dim, n, life as st) =
       88:   (e <?> t) >>= function
       89:   | `End | `Key (`Escape, []) | `Key (`ASCII 'C', [`Ctrl]) ->
       90:       Lwt.return_unit
       91:   | `Timer ->
       92:       Term.image term (render dim n life) >>= fun () ->
       93:         loop term (e, timer ())
       94:           (dim, n + 1, step (torus dim) life)
       95:   | `Mouse ((`Press `Left|`Drag), (x, y), _) ->
       96:       loop term (event term, t)
       97:         (dim, n, CSet.add (torus dim (x, y)) life)
       98:   | `Resize dim ->
       99:       let life = CSet.map (torus dim) life in
      100:       Term.image term (render dim n life) >>= fun () ->
      101:         loop term (event term, t) (dim, n, life)
      102:   | _ -> loop term (event term, t) st
      103: 
      104: let main () =
      105:   let t = Term.create () in
      106:   loop t (event t, timer ()) (Term.size t, 0, glider)
      107: 
      108: let () = Lwt_main.run @@ main ()
Added regular file ../notty/examples/linear.ml:
        1: (* Copyright (c) 2016-2017 David Kaloper Meršinjak. All rights reserved.
        2:    See LICENSE.md. *)
        3: 
        4: (*
        5:  * Elementary Cellular Automata
        6:  *)
        7: open Notty
        8: open Notty.Infix
        9: open Common_lwt
       10: 
       11: let flip f a b = f b a
       12: let rec take n = function
       13:   | x::xs when n > 0 -> x :: take (pred n) xs
       14:   | _                -> []
       15: 
       16: let getd arr d i =
       17:   if i < 0 || i >= Array.length arr then d else arr.(i)
       18: 
       19: let f ~rule a b c =
       20:   if rule land (1 lsl (a lsl 2 + b lsl 1 + c)) > 0 then 1 else 0
       21: 
       22: let step ~rule w arr =
       23:   let get = getd arr 0 in
       24:   Array.init w @@ fun i ->
       25:     f ~rule (get (i - 1)) (get i) (get (i + 1))
       26: 
       27: let dot  = I.char A.(bg lightwhite) ' ' 1 1
       28: let void = I.void 1 1
       29: 
       30: let render ~rule ~h xss =
       31:   let cons k = function
       32:     | 0 -> I.void k 1
       33:     | _ -> I.char A.(bg lightwhite) ' ' k 1 in
       34:   let rec rline s k i arr =
       35:     if i >= Array.length arr then
       36:       cons k s
       37:     else if arr.(i) = s then
       38:       rline s (k + 1) (i + 1) arr
       39:     else cons k s <|> rline (1 - s) 1 (i + 1) arr in
       40:   ( xss |> List.rev |> List.map (rline 0 0 0) |> I.vcat
       41:     |> I.vsnap ~align:`Top (h - 2) ) <->
       42:   ( I.strf ~attr:A.(fg lightgreen ++ bg black) " RULE %d " rule
       43:     |> I.vpad 1 0 )
       44: 
       45: let rule = 124 (* 110 mirrored *)
       46: 
       47: let main () =
       48:   simpleterm_lwt_timed ~delay:0.1 ([], rule)
       49:   ~f:(fun (w, h) (lines, rule) -> function
       50:     | `Timer ->
       51:         let prev  = match lines with [] -> [|1|] | h::_ -> h in
       52:         let lines = step ~rule w prev :: lines |> take (h - 2) in
       53:         `Redraw ((lines, rule), render ~rule ~h lines)
       54:     | `Resize _ ->
       55:         let lines = lines |> take h in
       56:         `Redraw ((lines, rule), render ~rule ~h lines)
       57:     | `Key (`Arrow `Left, []) ->
       58:         `Redraw (([], rule - 1), render ~rule ~h lines)
       59:     | `Key (`Arrow `Right, []) ->
       60:         `Redraw (([], rule + 1), render ~rule ~h lines)
       61:     | _ -> `Continue (lines, rule)
       62:   )
       63: 
       64: let () = Lwt_main.run @@ main ()
Added regular file ../notty/examples/mouse.ml:
        1: (* Copyright (c) 2016-2017 David Kaloper Meršinjak. All rights reserved.
        2:    See LICENSE.md. *)
        3: 
        4: (**
        5:  * Demonstrates mouse input.
        6:  *)
        7: open Notty
        8: open Common
        9: 
       10: let lnv = Uchar.of_int 0x2502
       11: and lnh = Uchar.of_int 0x2500
       12: and crs = Uchar.of_int 0x253c
       13: 
       14: let clip a b x = min b (max a x)
       15: 
       16: let () =
       17:   simpleterm ~s:(`Down, (0, 0), [], 11)
       18:     ~f:(fun (st, pos, mods, scr as s) -> function
       19:       | `Mouse ((`Press `Left|`Drag), pos, mods) -> Some (`Drag, pos, mods, scr)
       20:       | `Mouse (`Press (`Scroll s), _, _) ->
       21:           Some (st, pos, mods, clip 0 23 (scr + match s with `Up -> 1 | _ -> -1))
       22:       | `Mouse (`Release, pos, _) -> Some (`Down, pos, [], scr)
       23:       | _ -> Some s)
       24:     ~imgf:I.(fun (w, h) (st, (x, y), mods, scr) ->
       25:       let cross =
       26:         let a  = match st with `Drag -> A.(fg lightgreen) | `Down -> A.(fg green) in
       27:         (uchar a lnh x 1 |> vpad y 0) <|>
       28:         (uchar a lnv 1 y <-> uchar a crs 1 1 <-> uchar a lnv 1 (h - y)) <|>
       29:         (uchar a lnh (w - x - 1) 1 |> vpad y 0)
       30:         |> crop ~t:1 ~l:1 ~r:3
       31:         |> hpad 1 1
       32:         |> vsnap ~align:`Top (h - 1)
       33:       and scroll =
       34:         List.(range 0 scr |> rev |> map @@ fun level ->
       35:           Images.dot A.(gray level)
       36:         ) |> vcat |> vsnap ~align:`Bottom (h - 1)
       37:       and status =
       38:         let a = A.(fg lightblack ++ bg black) in
       39:         let fa m = if List.mem m mods then A.(fg lightgreen ++ bg black) else a in
       40:         string A.empty "Use the mouse." </>
       41:         (hcat [ string a "["
       42:               ; string (fa `Ctrl) "C"
       43:               ; string (fa `Meta) "M"
       44:               ; strf ~attr:a "] @(%03d, %03d)" x y ]
       45:          |> hsnap ~align:`Right w)
       46:       in (cross <|> scroll) <-> status
       47:     )
Added regular file ../notty/examples/rain.ml:
        1: 
        2: let () = Random.self_init ()
        3: 
        4: let rec (--) a b = if a > b then [] else a :: succ a -- b
        5: 
        6: let utf8_of_code_point =
        7:   let buf = Buffer.create 7 in fun cp ->
        8:     Buffer.clear buf;
        9:     Uutf.Buffer.add_utf_8 buf (Uchar.of_int cp);
       10:     Buffer.contents buf
       11: 
       12: let nsym = 4096
       13: let glitch = nsym / 20
       14: let symbols = Array.(concat [
       15:   init 58 (fun x -> utf8_of_code_point (0xff66 + x));
       16:   init 10 (fun x -> utf8_of_code_point (0x30 + x));
       17:   (* init 26 (fun x -> utf8_of_code_point (0x61 + x)); *)
       18:   (* init 14 (fun x -> utf8_of_code_point (0x21 + x)); *)
       19: ])
       20: let sym () = symbols.(Random.int (Array.length symbols))
       21: let syms = Array.init nsym (fun _ -> sym ())
       22: 
       23: let gen_wait h = `Wait Random.(int (h / 2))
       24: and gen_line h =
       25:   `Line Random.(0, int (nsym - h), int (h + h / 2) + 1, int 2 + 1)
       26: let gen (w, h as dim) =
       27:   let lines = 1 -- w |> List.map @@ fun _ ->
       28:     if Random.float 1. < 0.1 then gen_line h else gen_wait h in
       29:   (dim, lines)
       30: 
       31: let step ((_, h as dim), xs) =
       32:   let xs = xs |> List.map @@ function
       33:       `Wait 0 -> gen_line h
       34:     | `Wait n -> `Wait (n - 1)
       35:     | `Line (i, _, win, k) when i - win + k >= h -> gen_wait h
       36:     | `Line (i, s, win, k) -> `Line (i + k, s, win, k) in
       37:   Random.(for _ = 0 to int glitch do syms.(int nsym) <- sym () done);
       38:   (dim, xs)
       39: 
       40: open Notty
       41: open Notty.Infix
       42: 
       43: let bgc = A.(bg @@ rgb ~r:0 ~g:0 ~b:0)
       44: 
       45: let color i n =
       46:   let chan x = x *. 255. |> truncate
       47:   and t  = float i /. float n in
       48:   let t1 = exp (-. t /. 0.02) |> chan
       49:   and t2 = exp (-. t /. 0.45) |> chan in
       50:   A.rgb_888 ~r:t1 ~b:t1 ~g:t2
       51: 
       52: let show ((w, h), xs) =
       53:   let f = function
       54:     `Wait _ -> I.void 1 0
       55:   | `Line (i, sym, win, _) ->
       56:       let last = i - win
       57:       and off = max 0 (i - h + 1) in
       58:       let rec chars w =
       59:         let ix = w + last in
       60:         if 0 <= min ix w then syms.(sym + ix) :: chars (w - 1) else [] in
       61:       let rec images acc i = function
       62:         | []    -> acc
       63:         | x::xs -> let img = I.string A.(fg (color i win) ++ bgc) x in
       64:                    images (img :: acc) (i + 1) xs in
       65:       chars (win - off) |> images [] off
       66:         |> I.vcat |> I.vpad (max 0 (i - win)) 0 in
       67:   (List.map f xs |> I.hcat) </> I.char bgc ' ' w h
       68: 
       69: open Notty_unix
       70: 
       71: type r = [ Unescape.event | `Resize of int * int | `End | `Timer ]
       72: 
       73: let event ~delay t =
       74:   if Term.pending t then (Term.event t :> r) else
       75:     let open Unix in
       76:     match select [Term.fds t |> fst] [] [] delay with
       77:     | ([], _, _) -> `Timer
       78:     | (_::_, _, _) -> (Term.event t :> r)
       79:     | exception Unix_error (EINTR, _, _) -> (Term.event t :> r)
       80: 
       81: let loop t ~frame st =
       82:   let rec go st deadline =
       83:     let now = Unix.gettimeofday () in
       84:     if deadline <= now then
       85:       ( Term.image t (show st); go (step st) (frame +. deadline) )
       86:     else match event ~delay:(deadline -. now) t with
       87:       | `End | `Key (`Escape, _) | `Key (`ASCII 'C', [`Ctrl]) -> ()
       88:       | `Resize _ | `Key (`ASCII ' ', _) -> go (gen (Term.size t)) deadline
       89:       | _ -> go st deadline in
       90:   go st (Unix.gettimeofday ())
       91: 
       92: let () =
       93:   let t = Term.create () in
       94:   loop t ~frame:0.075 (gen (Term.size t));
       95:   Term.release t
Added regular file ../notty/examples/runes.ml:
        1: (* Copyright (c) 2016-2017 David Kaloper Meršinjak. All rights reserved.
        2:    See LICENSE.md. *)
        3: 
        4: (**
        5:  * Demonstrates geometry computation with various scripts. A few of those will
        6:  * usually break.
        7:  *)
        8: open Notty
        9: open Notty.Infix
       10: open Common
       11: 
       12: let hpad_sp attr l r i =
       13:   let h = I.height i in
       14:   I.(char attr ' ' l h <|> i <|> char attr ' ' r h)
       15: 
       16: let vpad_sp attr t b i =
       17:   let w = I.width i in
       18:   I.(char attr ' ' w t <-> i <-> char attr ' ' w b)
       19: 
       20: let grid xxs = xxs |> List.map I.hcat |> I.vcat
       21: 
       22: let centered attr xs =
       23:   let lns = List.map I.(string attr) xs in
       24:   let w   = List.fold_left (fun a i -> max a I.(width i)) 0 lns in
       25:   lns |> List.map I.(fun ln ->
       26:     let d = w - I.width ln in
       27:     char attr ' ' (d / 2) 1 <|> ln <|> char attr ' ' (d - d / 2) 1
       28:   ) |> I.vcat
       29: 
       30: let note xs = I.(
       31:   string A.(st bold) "Note:" <|>
       32:   (xs |> List.map (string A.empty) |> vcat |> hpad 1 0)
       33: )
       34: 
       35: let text = [
       36:     "\225\154\160\225\155\135\225\154\187\225\155\171\225\155\146\225\155\166\225\154\166\225\155\171\225\154\160\225\154\177\225\154\169\225\154\160\225\154\162\225\154\177\225\155\171\225\154\160\225\155\129\225\154\177\225\154\170\225\155\171\225\154\183\225\155\150\225\154\187\225\154\185\225\155\166\225\155\154\225\154\179\225\154\162\225\155\151"
       37:   ; "\225\155\139\225\154\179\225\155\150\225\154\170\225\155\154\225\155\171\225\154\166\225\155\150\225\154\170\225\154\187\225\155\171\225\155\151\225\154\170\225\154\190\225\154\190\225\154\170\225\155\171\225\154\183\225\155\150\225\154\187\225\154\185\225\155\166\225\155\154\225\154\179\225\155\171\225\155\151\225\155\129\225\154\179\225\155\154\225\154\162\225\154\190\225\155\171\225\154\187\225\155\166\225\155\143\225\155\171\225\155\158\225\154\171\225\155\154\225\154\170\225\154\190"
       38:   ; "\225\154\183\225\155\129\225\154\160\225\155\171\225\154\187\225\155\150\225\155\171\225\154\185\225\155\129\225\155\154\225\155\150\225\155\171\225\154\160\225\154\169\225\154\177\225\155\171\225\155\158\225\154\177\225\155\129\225\154\187\225\155\143\225\154\190\225\155\150\225\155\171\225\155\158\225\154\169\225\155\151\225\155\150\225\155\139\225\155\171\225\154\187\225\155\154\225\155\135\225\155\143\225\154\170\225\154\190\225\155\172"
       39:   ; ""
       40:   ; "\227\129\132\227\130\141\227\129\175\227\129\171\227\129\187\227\129\184\227\129\168\227\129\161\227\130\138\227\129\172\227\130\139\227\130\146"
       41:   ; "\227\130\143\227\129\139\227\130\136\227\129\159\227\130\140\227\129\157\227\129\164\227\129\173\227\129\170\227\130\137\227\130\128"
       42:   ; "\227\129\134\227\130\144\227\129\174\227\129\138\227\129\143\227\130\132\227\129\190\227\129\145\227\129\181\227\129\147\227\129\136\227\129\166"
       43:   ; "\227\129\130\227\129\149\227\129\141\227\130\134\227\130\129\227\129\191\227\129\151\227\130\145\227\129\178\227\130\130\227\129\155\227\129\153"
       44:   ; ""
       45:   ; "\227\130\164\227\131\173\227\131\143\227\131\139\227\131\155\227\131\152\227\131\136 \227\131\129\227\131\170\227\131\140\227\131\171\227\131\178 \227\131\175\227\130\171\227\131\168\227\130\191\227\131\172\227\130\189 \227\131\132\227\131\141\227\131\138\227\131\169\227\131\160"
       46:   ; "\227\130\166\227\131\176\227\131\142\227\130\170\227\130\175\227\131\164\227\131\158 \227\130\177\227\131\149\227\130\179\227\130\168\227\131\134 \227\130\162\227\130\181\227\130\173\227\131\166\227\131\161\227\131\159\227\130\183 \227\131\177\227\131\146\227\131\162\227\130\187\227\130\185\227\131\179"
       47:   ; ""
       48:   ; "\237\130\164\236\138\164\236\157\152 \234\179\160\236\156\160\236\161\176\234\177\180\236\157\128 \236\158\133\236\136\160\235\129\188\235\166\172 \235\167\140\235\130\152\236\149\188"
       49:   ; "\237\149\152\234\179\160 \237\138\185\235\179\132\237\149\156 \234\184\176\236\136\160\236\157\128 \237\149\132\236\154\148\236\185\152 \236\149\138\235\139\164"
       50:   ; ""
       51:   ; "\206\158\206\181\207\131\206\186\206\181\207\128\206\172\206\182\207\137 \207\132\225\189\180\206\189 \207\136\207\133\207\135\206\191\207\134\206\184\207\140\207\129\206\177 \206\178\206\180\206\181\206\187\207\133\206\179\206\188\206\175\206\177"
       52:   ; ""
       53:   ; "\208\167\208\181\209\136\209\155\208\181 \209\134e\209\146\208\181\209\154\208\181 \208\188\209\128e\208\182\208\176\209\129\209\130\208\184\208\188 \209\159\208\176\208\186\208\190\208\188 \208\191\208\190\208\177\208\190\209\153\209\136\208\176\208\178\208\176"
       54:   ; "\209\132\208\181\209\128\209\130\208\184\208\187\208\184\208\183\208\176\209\134\208\184\209\152\209\131 \208\179\208\181\208\189\209\129\208\186\208\184\209\133 \209\133\208\184\208\177\209\128\208\184\208\180\208\176!"
       55:   ; ""
       56:   ; "Heiz\195\182lr\195\188cksto\195\159abd\195\164mpfung."
       57:   ; ""
       58:   ; "\208\146 \209\135\208\176\209\137\208\176\209\133 \209\142\208\179\208\176 \208\182\208\184\208\187 \208\177\209\139 \209\134\208\184\209\130\209\128\209\131\209\129? \208\148\208\176, \208\189\208\190 \209\132\208\176\208\187\209\140\209\136\208\184\208\178\209\139\208\185 \209\141\208\186\208\183\208\181\208\188\208\191\208\187\209\143\209\128!"
       59:   ; ""
       60:   ; "\225\131\149\225\131\148\225\131\158\225\131\174\225\131\152\225\131\161 \225\131\162\225\131\167\225\131\144\225\131\157\225\131\161\225\131\144\225\131\156\225\131\152 \225\131\168\225\131\157\225\131\151\225\131\144 \225\131\160\225\131\163\225\131\161\225\131\151\225\131\144\225\131\149\225\131\148\225\131\154\225\131\152"
       61:   ; ""
       62:   ; "Lu\195\173s arg\195\188ia \195\160 J\195\186lia que \194\171bra\195\167\195\181es, f\195\169, ch\195\161,"
       63:   ; "\195\179xido, p\195\180r, z\195\162ng\195\163o\194\187 eram palavras do portugu\195\170s."
       64:   ; ""
       65:   ; "ding ↹ ∀ ⌘ ▓ ◭ ☃ ♠ ♋ ♕ ⚅ ♩ ☭ ✎ 🂡 bats"
       66:   ; ""
       67:   ; "\216\181\217\144\217\129 \216\174\217\142\217\132\217\130\217\142 \216\174\217\142\217\136\216\175\217\144 \217\131\217\142\217\133\217\144\216\171\217\132\217\144 \216\167\217\132\216\180\217\142\217\133\216\179\217\144 \216\165\217\144\216\176 \216\168\217\142\216\178\217\142\216\186\217\142\216\170 \226\128\148 \217\138\217\142\216\173\216\184\217\137 \216\167\217\132\216\182\217\142\216\172\217\138\216\185\217\143 \216\168\217\144\217\135\216\167 \217\134\217\142\216\172\217\132\216\167\216\161\217\142 \217\133\217\144\216\185\216\183\216\167\216\177\217\144"
       68:   ; ""
       69:   ; "\215\147\215\146 \215\161\215\167\215\168\215\159 \215\169\215\152 \215\145\215\153\215\157 \215\158\215\144\215\149\215\155\215\150\215\145 \215\149\215\156\215\164\215\170\215\162 \215\158\215\166\215\144 \215\156\215\149 \215\151\215\145\215\168\215\148 \215\144\215\153\215\154 \215\148\215\167\215\156\215\153\215\152\215\148"
       70:   ; ""
       71:   ; "\224\174\175\224\174\190\224\174\174\224\174\177\224\174\191\224\174\168\224\175\141\224\174\164 \224\174\174\224\175\138\224\174\180\224\174\191\224\174\149\224\174\179\224\174\191\224\174\178\224\175\135 \224\174\164\224\174\174\224\174\191\224\174\180\224\175\141\224\174\174\224\175\138\224\174\180\224\174\191 \224\174\170\224\175\139\224\174\178\224\175\141 \224\174\135\224\174\169\224\174\191\224\174\164\224\174\190\224\174\181\224\174\164\224\175\129 \224\174\142\224\174\153\224\175\141\224\174\149\224\175\129\224\174\174\224\175\141 \224\174\149\224\174\190\224\174\163\224\175\139\224\174\174\224\175\141,"
       72:   ; "\224\174\170\224\174\190\224\174\174\224\174\176\224\174\176\224\174\190\224\174\175\224\175\141 \224\174\181\224\174\191\224\174\178\224\174\153\224\175\141\224\174\149\224\175\129\224\174\149\224\174\179\224\174\190\224\174\175\224\175\141, \224\174\137\224\174\178\224\174\149\224\174\169\224\175\136\224\174\164\224\175\141\224\174\164\224\175\129\224\174\174\224\175\141 \224\174\135\224\174\149\224\174\180\224\175\141\224\174\154\224\175\141\224\174\154\224\174\191\224\174\154\224\175\138\224\174\178\224\174\170\224\175\141 \224\174\170\224\174\190\224\174\169\224\175\141\224\174\174\224\175\136 \224\174\149\224\175\134\224\174\159\224\175\141\224\174\159\224\175\129"
       73:   ; ""
       74:   ; "\224\178\172\224\178\190 \224\178\135\224\178\178\224\179\141\224\178\178\224\178\191 \224\178\184\224\178\130\224\178\173\224\178\181\224\178\191\224\178\184\224\179\129 \224\178\135\224\178\130\224\178\166\224\179\134\224\178\168\224\179\141\224\178\168 \224\178\185\224\179\131\224\178\166\224\178\175\224\178\166\224\178\178\224\178\191"
       75:   ; "\224\178\168\224\178\191\224\178\164\224\179\141\224\178\175\224\178\181\224\179\130 \224\178\133\224\178\181\224\178\164\224\178\176\224\178\191\224\178\170 \224\178\184\224\178\164\224\179\141\224\178\175\224\178\190\224\178\181\224\178\164\224\178\190\224\178\176"
       76:   ; ""
       77:   ; "\224\164\139\224\164\183\224\164\191\224\164\175\224\165\139\224\164\130 \224\164\149\224\165\139 \224\164\184\224\164\164\224\164\190\224\164\168\224\165\135 \224\164\181\224\164\190\224\164\178\224\165\135 \224\164\166\224\165\129\224\164\183\224\165\141\224\164\159 \224\164\176\224\164\190\224\164\149\224\165\141\224\164\183\224\164\184\224\165\139\224\164\130 \224\164\149\224\165\135 \224\164\176\224\164\190\224\164\156\224\164\190 \224\164\176\224\164\190\224\164\181\224\164\163 \224\164\149\224\164\190 \224\164\184\224\164\176\224\165\141\224\164\181\224\164\168\224\164\190\224\164\182 \224\164\149\224\164\176\224\164\168\224\165\135 \224\164\181\224\164\190\224\164\178\224\165\135"
       78:   ; "\224\164\181\224\164\191\224\164\183\224\165\141\224\164\163\224\165\129\224\164\181\224\164\164\224\164\190\224\164\176 \224\164\173\224\164\151\224\164\181\224\164\190\224\164\168 \224\164\182\224\165\141\224\164\176\224\165\128\224\164\176\224\164\190\224\164\174, \224\164\133\224\164\175\224\165\139\224\164\167\224\165\141\224\164\175\224\164\190 \224\164\149\224\165\135 \224\164\174\224\164\185\224\164\190\224\164\176\224\164\190\224\164\156 \224\164\166\224\164\182\224\164\176\224\164\165 \224\164\149\224\165\135 \224\164\172\224\164\161\224\164\188\224\165\135 \224\164\184\224\164\170\224\165\129\224\164\164\224\165\141\224\164\176 \224\164\165\224\165\135\224\165\164"
       79: ]
       80: 
       81: let () =
       82:   let attr = A.(fg lightmagenta) in
       83:   let img = I.(
       84:     centered attr text
       85:     |> vpad_sp attr 1 1 |> hpad_sp attr 2 2
       86:     |> Images.outline attr
       87:     |> pad ~t:1 ~b:1 ~l:2 ~r:2
       88:   ) <->
       89:     note [ "Alignment will usually break on the last few scripts."
       90:          ; "This is at the limit of what terminals can do."
       91:          ; ":(" ]
       92:   in Notty_unix.(eol img |> output_image)
Added regular file ../notty/examples/sierpinski.ml:
        1: (* Copyright (c) 2016-2017 David Kaloper Meršinjak. All rights reserved.
        2:    See LICENSE.md. *)
        3: 
        4: (**
        5:  * A classic example in combinatory graphics.
        6:  *
        7:  * Demonstrates interaction.
        8:  *)
        9: open Notty
       10: open Common
       11: 
       12: let () =
       13:   simpleterm ~s:1
       14:     ~f:(fun s -> function
       15:       | `Key (`ASCII 'q', _) -> None
       16:       | `Key (`Arrow a, _) ->
       17:         ( match a with
       18:           | `Up | `Left -> Some (max 1 (s - 1))
       19:           | `Down | `Right -> Some (min 10 (s + 1)) )
       20:       | _ -> Some s)
       21:     ~imgf:I.(fun _ s ->
       22:       string A.empty (string_of_int s) <->
       23:       pad ~l:2 ~t:1 (Images.sierp A.magenta s)
       24:     )
Added regular file ../notty/examples/sierpinski_lwt.ml:
        1: (* Copyright (c) 2016-2017 David Kaloper Meršinjak. All rights reserved.
        2:    See LICENSE.md. *)
        3: 
        4: (**
        5:  * Demonstrates Lwt interaction.
        6:  *)
        7: open Notty
        8: open Common_lwt
        9: 
       10: let img s = I.(
       11:   string A.empty (string_of_int s) <-> hpad 2 0 (Images.sierp A.magenta s)
       12: )
       13: 
       14: let () =
       15:   simpleterm_lwt ~s:1
       16:     ~f:(fun s -> function
       17:       | `Key (`ASCII 'q', _) -> None
       18:       | `Key (`Arrow a, _) ->
       19:         ( match a with
       20:           | `Up | `Left -> Some (max 1 (s - 1))
       21:           | `Down | `Right -> Some (min 10 (s + 1)) )
       22:       | _ -> Some s)
       23:     ~imgf:I.(fun _ s ->
       24:       string A.empty (string_of_int s) <->
       25:       pad ~l:2 ~t:1 (Images.sierp A.magenta s)
       26:     )
Added regular file ../notty/examples/testpatterns.ml:
        1: (* Copyright (c) 2016-2017 David Kaloper Meršinjak. All rights reserved.
        2:    See LICENSE.md. *)
        3: 
        4: (**
        5:  * A few images that exercise image composition, cropping, and padding. This
        6:  * test is a good canary.
        7:  *)
        8: open Common
        9: open Notty_unix
       10: 
       11: let () = Images.[i3; i5; checker1] |> List.map eol |> List.iter output_image
Added regular file ../notty/examples/thisbig.ml:
        1: (* Copyright (c) 2016-2017 David Kaloper Meršinjak. All rights reserved.
        2:    See LICENSE.md. *)
        3: 
        4: open Notty
        5: open Common
        6: 
        7: let () =
        8:   Notty_unix.output_image_size @@ fun (w, h) ->
        9:     Images.outline A.(fg lightblue)
       10:       I.(hsnap (w - 2) @@
       11:           vsnap (h - 3) @@ (* +1 for the prompt *)
       12:             Images.sierp A.lightblue 5)
Added regular file ../notty/notty.opam:
        1: opam-version: "2.0"
        2: homepage:     "https://github.com/pqwy/notty"
        3: dev-repo:     "git+https://github.com/pqwy/notty.git"
        4: bug-reports:  "https://github.com/pqwy/notty/issues"
        5: doc:          "https://pqwy.github.io/notty/doc"
        6: author:       "David Kaloper <dk505@cam.ac.uk>"
        7: maintainer:   "David Kaloper <dk505@cam.ac.uk>"
        8: license:      "ISC"
        9: synopsis:     "Declaring terminals"
       10: description:
       11:   "Notty is a declarative terminal library for OCaml structured around a notion
       12:   of composable images. It tries to abstract away the basic terminal programming
       13:   model, providing something simpler and more expressive."
       14: 
       15: build: [ [ "dune" "subst" ] {dev}
       16:          [ "dune" "build" "-p" name "-j" jobs ] ]
       17: depends: [
       18:   "ocaml" {>= "4.08.0"}
       19:   "dune" {>= "1.7"}
       20:   "cppo" {build & >= "1.1.0"}
       21:   "uutf" {>= "1.0.0"}
       22: ]
       23: depopts: [ "lwt" ]
       24: conflicts: [ "lwt" {<"2.5.2"} ]
Added regular file ../notty/src/dune:
        1: (include_subdirs unqualified)
        2: 
        3: (library
        4:   (public_name notty)
        5:   (synopsis "Declaring terminals")
        6:   (libraries uutf)
        7:   (wrapped false)
        8:   (modules notty notty_grapheme_cluster notty_uucp notty_uucp_data)
        9:   (private_modules notty_grapheme_cluster notty_uucp notty_uucp_data))
       10: 
       11: (library
       12:   (public_name notty.top)
       13:   (synopsis "Notty toplevel support")
       14:   (name notty_top)
       15:   (wrapped false)
       16:   (modules notty_top)
       17:   (preprocess (action (run %{bin:cppo} -V OCAML:%{ocaml_version} %{input-file})))
       18:   (libraries notty compiler-libs.toplevel))
       19: 
       20: (install
       21:   (section lib)
       22:   (files (notty_top_init.ml as top/notty_top_init.ml)))
Added regular file ../notty/src/no-uucp/README.md:
        1: Cannibalized bits of Uucp:
        2: 
        3: - `Notty_uucp_data` is generated from an actual Uucp installation.
        4: - `Notty_uucp` uses it to provide the few Unicode properties that Notty needs.
        5: - `Notty_grapheme_cluster` is `Grapheme_cluster` from Uuseg, adapted to use the
        6:   above.
        7: 
        8: Compiled size of these is on the order of 70K. Uucp is presently a monolithic 10M.
        9: 
       10: The idea is to remove these in favor of the actual Uucp/Uuseg, as soon as it
       11: becomes possible to depend only on the necessary parts of Uucp.
       12: 
       13: Uucp and Uuseg are Copyright (c) 2014 Daniel C. Bünzli.
Added regular file ../notty/src/no-uucp/notty_grapheme_cluster.ml:
        1: (*---------------------------------------------------------------------------
        2:    Copyright (c) 2014 Daniel C. Bünzli. All rights reserved.
        3:    Distributed under the ISC license, see terms at the end of the file.
        4:    %%NAME%% %%VERSION%%
        5:   ---------------------------------------------------------------------------*)
        6: 
        7: (* These are the rules as found in [1], with property values aliases [2]
        8:    substituted.
        9: 
       10:    GB1.               sot ÷ Any
       11:    GB2.               Any ÷ eot
       12:    GB3.                CR × LF
       13:    GB4.        (CN|CR|LF) ÷
       14:    GB5.                   ÷ (CN|CR|LF)
       15:    GB6.                 L × (L|V|LV|LVT)
       16:    GB7.            (LV|V) × (V|T)
       17:    GB8.           (LVT|T) × T
       18:    GB9.                   × (EX|ZWJ)
       19:    GB9a.                  × SM
       20:    GB9b.               PP ×
       21:    GB10. (v10.0.0) (EB|EBG) EX* × EM
       22:    GB11. (v10.0.0)          ZWJ × (GAZ|EBG)
       23:    GB12.  sot (RI RI)* RI × RI
       24:    GB13.   [^RI] (RI RI)* × RI
       25:    GB999.             Any ÷ Any
       26: 
       27:    [1]: http://www.unicode.org/reports/tr29/#Grapheme_Cluster_Boundaries
       28:    [2]: http://www.unicode.org/Public/7.0.0/ucd/PropertyValueAliases.txt
       29:    [3]: http://www.unicode.org/Public/7.0.0/ucd/auxiliary/GraphemeBreakTest.html
       30: 
       31:    By the structure of the rules we see that grapheme clusters
       32:    boundaries can *mostly* be determined by simply looking at the
       33:    grapheme cluster break property value of the character on the left
       34:    and on the right of a boundary. The exceptions are GB10 and GB12-13
       35:    which are handled specially by enriching the segmenter state in
       36:    a horribly ad-hoc fashion. *)
       37: 
       38: type ret = [ `Await | `Boundary | `End | `Uchar of Uchar.t ]
       39: 
       40: type gcb =
       41:   | CN | CR | EX | EB | EBG | EM | GAZ | L | LF | LV | LVT | PP | RI
       42:   | SM | T | V | XX | ZWJ | Sot
       43: 
       44: (* WARNING. The indexes used here need to be synchronized with those
       45:    assigned by uucp for Uucp.Break.Low.grapheme_cluster. *)
       46: 
       47: let byte_to_gcb =
       48:   [| CN; CR; EX; EB; EBG; EM; GAZ; L; LF; LV; LVT; PP; RI;
       49:      SM; T; V; XX; ZWJ; |]
       50: 
       51: let gcb u = byte_to_gcb.(Notty_uucp.grapheme_cluster_boundary u)
       52: 
       53: type state =
       54: | Fill  (* get next uchar to decide boundary. *)
       55: | Flush (* an uchar is buffered, client needs to get it out with `Await. *)
       56: | End   (* `End was added. *)
       57: 
       58: type t =
       59:   { mutable state : state;                                 (* current state. *)
       60:     mutable left : gcb;            (* break property value left of boundary. *)
       61:     mutable odd_ri : bool;                  (* odd number of RI on the left. *)
       62:     mutable emoji_seq : bool;               (* (EB|EBG) Extend* on the left. *)
       63:     mutable buf : [ `Uchar of Uchar.t ] }                 (* bufferized add. *)
       64: 
       65: let nul_buf = `Uchar (Uchar.unsafe_of_int 0x0000)
       66: 
       67: let create () =
       68:   { state = Fill; left = Sot;
       69:     odd_ri = false; emoji_seq = false;
       70:     buf = nul_buf (* overwritten *); }
       71: 
       72: let break s right = match s.left, right with
       73: | (* GB1 *)   Sot, _ -> true
       74:   (* GB2 is handled by `End *)
       75: | (* GB3 *)   CR, LF -> false
       76: | (* GB4 *)   (CN|CR|LF), _ -> true
       77: | (* GB5 *)   _, (CN|CR|LF) -> true
       78: | (* GB6 *)   L, (L|V|LV|LVT) -> false
       79: | (* GB7 *)   (LV|V), (V|T) -> false
       80: | (* GB8 *)   (LVT|T), T -> false
       81: | (* GB9+a *) _, (EX|ZWJ|SM) -> false
       82: | (* GB9b *)  PP, _ -> false
       83: | (* GB10 *)  _, EM when s.emoji_seq -> false
       84: | (* GB11 *)  ZWJ, (GAZ|EBG) -> false
       85: | (* GB12+13 *) RI, RI when s.odd_ri -> false
       86: | (* GB999 *) _, _ -> true
       87: 
       88: let update_left s right =
       89:   s.left <- right;
       90:   match s.left with
       91:   | EX -> (* keep s.emoji_seq as is *) s.odd_ri <- false
       92:   | EB | EBG -> s.emoji_seq <- true; s.odd_ri <- false
       93:   | RI -> s.emoji_seq <- false; s.odd_ri <- not s.odd_ri
       94:   | _ -> s.emoji_seq <- false; s.odd_ri <- false
       95: 
       96: let add s = function
       97: | `Uchar u as add ->
       98:     begin match s.state with
       99:     | Fill ->
      100:         let right = gcb u in
      101:         let break = break s right in
      102:         update_left s right;
      103:         if not break then add else
      104:         (s.state <- Flush; s.buf <- add; `Boundary)
      105:     | Flush | End -> assert false
      106:     end
      107: | `Await ->
      108:     begin match s.state with
      109:     | Flush -> s.state <- Fill; (s.buf :> ret)
      110:     | End -> `End
      111:     | Fill -> `Await
      112:     end
      113: | `End ->
      114:     begin match s.state with
      115:     | Fill -> s.state <- End; if s.left = Sot then `End else `Boundary
      116:     | Flush | End -> assert false
      117:     end
      118: 
      119: (*---------------------------------------------------------------------------
      120:    Copyright (c) 2014 Daniel C. Bünzli
      121: 
      122:    Permission to use, copy, modify, and/or distribute this software for any
      123:    purpose with or without fee is hereby granted, provided that the above
      124:    copyright notice and this permission notice appear in all copies.
      125: 
      126:    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
      127:    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
      128:    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
      129:    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
      130:    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
      131:    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
      132:    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
      133:   ---------------------------------------------------------------------------*)
Added regular file ../notty/src/no-uucp/notty_grapheme_cluster.mli:
        1: (*---------------------------------------------------------------------------
        2:    Copyright (c) 2014 Daniel C. Bünzli. All rights reserved.
        3:    Distributed under the ISC license, see terms at the end of the file.
        4:    %%NAME%% %%VERSION%%
        5:   ---------------------------------------------------------------------------*)
        6: 
        7: type ret = [ `Await | `Boundary | `End | `Uchar of Uchar.t ]
        8: 
        9: type t
       10: val create : unit -> t
       11: val add : t -> [ `Await | `End | `Uchar of Uchar.t ] -> ret
       12: 
       13: (*---------------------------------------------------------------------------
       14:    Copyright (c) 2014 Daniel C. Bünzli
       15: 
       16:    Permission to use, copy, modify, and/or distribute this software for any
       17:    purpose with or without fee is hereby granted, provided that the above
       18:    copyright notice and this permission notice appear in all copies.
       19: 
       20:    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
       21:    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
       22:    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
       23:    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
       24:    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
       25:    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
       26:    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
       27:   ---------------------------------------------------------------------------*)
Added regular file ../notty/src/no-uucp/notty_uucp.ml:
        1: (* Copyright (c) 2020 David Kaloper Meršinjak. All rights reserved.
        2:    See LICENSE.md. *)
        3: 
        4: (* Unpacked interval lookup table. *)
        5: let find_i ~def k (xs, _, _ as tab) =
        6:   let rec go i j (los, his, vs as tab) (k: int) def =
        7:     if i > j then def else
        8:     let x = (i + j) / 2 in
        9:     if k < Array.unsafe_get los x then go i (x - 1) tab k def else
       10:     if k > Array.unsafe_get his x then go (x + 1) j tab k def else
       11:       Array.unsafe_get vs x in
       12:   go 0 (Array.length xs - 1) tab k def
       13: 
       14: (* 12-6-6-bit (0xfff-0x3f-0x3f) trie, 3 levels, array-array-string.
       15:    Root is variable; lower levels are either empty or complete. *)
       16: let find_t ~def k tab =
       17:   let k = if k > 0xd7ff then k - 0x800 else k in (* Pack to continuous range. *)
       18:   let b0 = (k lsr 12) land 0xfff in
       19:   if Array.length tab <= b0 then def else
       20:   match Array.unsafe_get tab b0 with
       21:   | [||] -> def
       22:   | arr -> match Array.unsafe_get arr ((k lsr 6) land 0x3f) with
       23:     | "" -> def
       24:     | str -> String.unsafe_get str (k land 0x3f) |> Char.code
       25: 
       26: (* We catch w = -1 and default to w = 1 to minimize the table. *)
       27: let tty_width_hint u = match Uchar.to_int u with
       28: | 0 -> 0
       29: | u when u <= 0x001F || 0x007F <= u && u <= 0x009F -> -1
       30: | u when u <= 0x02ff -> 1
       31: | u -> find_i ~def:1 u Notty_uucp_data.tty_width_hint
       32: 
       33: let grapheme_cluster_boundary u =
       34:   find_t ~def:16 (Uchar.to_int u) Notty_uucp_data.grapheme_cluster_boundary
       35: 
       36: (* let check () = *)
       37: (*   let pp_u ppf u = Format.fprintf ppf "u+%04x" (Uchar.to_int u) in *)
       38: (*   let rec go i u = *)
       39: (*     let w1 = tty_width_hint u *)
       40: (*     and w2 = Uucp.Break.tty_width_hint u in *)
       41: (*     if w1 <> w2 then Format.printf "w: %a here: %d there: %d@." pp_u u w1 w2; *)
       42: (*     let gc1 = grapheme_cluster_boundary u *)
       43: (*     and gc2 = Uucp.Break.Low.grapheme_cluster u in *)
       44: (*     if gc1 <> gc2 then Format.printf "gc: %a here: %d there: %d@." pp_u u gc1 gc2; *)
       45: (*     if u = Uchar.max then i else go (i + 1) (Uchar.succ u) in *)
       46: (*   let n = go 1 Uchar.min in *)
       47: (*   Format.printf "Checked equality for %d code points.@." n *)
       48: 
Added regular file ../notty/src/no-uucp/notty_uucp.mli:
        1: (* Copyright (c) 2020 David Kaloper Meršinjak. All rights reserved.
        2:    See LICENSE.md. *)
        3: 
        4: (* This is a local copy of the (very few) relevant [uucp] properties. *)
        5: 
        6: val tty_width_hint : Uchar.t -> int
        7: (* [Uucp.Break.tty_width_hint]. *)
        8: 
        9: val grapheme_cluster_boundary : Uchar.t -> int
       10: (* [Uucp.Break.Low.grapheme_cluster]. *)
       11: 
       12: (* val check : unit -> unit *)
       13: 
Added regular file ../notty/src/no-uucp/notty_uucp_data.ml:
        1: (* Do not edit.
        2:  *
        3:  * This module contains select unicode properties extracted from Uucp,
        4:  * using `./support/gen_unicode_props.ml`.
        5:  *
        6:  * Unicode version 13.0.0.
        7:  *)
        8: 
        9: 
       10: let tty_width_hint =
       11:   ([|0x0000; 0x0300; 0x0483; 0x0591; 0x05bf; 0x05c1; 0x05c4; 0x05c7; 0x0600;
       12:      0x0610; 0x061c; 0x064b; 0x0670; 0x06d6; 0x06df; 0x06e7; 0x06ea; 0x070f;
       13:      0x0711; 0x0730; 0x07a6; 0x07eb; 0x07fd; 0x0816; 0x081b; 0x0825; 0x0829;
       14:      0x0859; 0x08d3; 0x093a; 0x093c; 0x0941; 0x094d; 0x0951; 0x0962; 0x0981;
       15:      0x09bc; 0x09c1; 0x09cd; 0x09e2; 0x09fe; 0x0a01; 0x0a3c; 0x0a41; 0x0a47;
       16:      0x0a4b; 0x0a51; 0x0a70; 0x0a75; 0x0a81; 0x0abc; 0x0ac1; 0x0ac7; 0x0acd;
       17:      0x0ae2; 0x0afa; 0x0b01; 0x0b3c; 0x0b3f; 0x0b41; 0x0b4d; 0x0b55; 0x0b62;
       18:      0x0b82; 0x0bc0; 0x0bcd; 0x0c00; 0x0c04; 0x0c3e; 0x0c46; 0x0c4a; 0x0c55;
       19:      0x0c62; 0x0c81; 0x0cbc; 0x0cbf; 0x0cc6; 0x0ccc; 0x0ce2; 0x0d00; 0x0d3b;
       20:      0x0d41; 0x0d4d; 0x0d62; 0x0d81; 0x0dca; 0x0dd2; 0x0dd6; 0x0e31; 0x0e34;
       21:      0x0e47; 0x0eb1; 0x0eb4; 0x0ec8; 0x0f18; 0x0f35; 0x0f37; 0x0f39; 0x0f71;
       22:      0x0f80; 0x0f86; 0x0f8d; 0x0f99; 0x0fc6; 0x102d; 0x1032; 0x1039; 0x103d;
       23:      0x1058; 0x105e; 0x1071; 0x1082; 0x1085; 0x108d; 0x109d; 0x1100; 0x135d;
       24:      0x1712; 0x1732; 0x1752; 0x1772; 0x17b4; 0x17b7; 0x17c6; 0x17c9; 0x17dd;
       25:      0x180b; 0x1885; 0x18a9; 0x1920; 0x1927; 0x1932; 0x1939; 0x1a17; 0x1a1b;
       26:      0x1a56; 0x1a58; 0x1a60; 0x1a62; 0x1a65; 0x1a73; 0x1a7f; 0x1ab0; 0x1b00;
       27:      0x1b34; 0x1b36; 0x1b3c; 0x1b42; 0x1b6b; 0x1b80; 0x1ba2; 0x1ba8; 0x1bab;
       28:      0x1be6; 0x1be8; 0x1bed; 0x1bef; 0x1c2c; 0x1c36; 0x1cd0; 0x1cd4; 0x1ce2;
       29:      0x1ced; 0x1cf4; 0x1cf8; 0x1dc0; 0x1dfb; 0x200b; 0x202a; 0x2060; 0x2066;
       30:      0x20d0; 0x231a; 0x2329; 0x23e9; 0x23f0; 0x23f3; 0x25fd; 0x2614; 0x2648;
       31:      0x267f; 0x2693; 0x26a1; 0x26aa; 0x26bd; 0x26c4; 0x26ce; 0x26d4; 0x26ea;
       32:      0x26f2; 0x26f5; 0x26fa; 0x26fd; 0x2705; 0x270a; 0x2728; 0x274c; 0x274e;
       33:      0x2753; 0x2757; 0x2795; 0x27b0; 0x27bf; 0x2b1b; 0x2b50; 0x2b55; 0x2cef;
       34:      0x2d7f; 0x2de0; 0x2e80; 0x2e9b; 0x2f00; 0x2ff0; 0x3000; 0x302a; 0x302e;
       35:      0x3041; 0x3099; 0x309b; 0x3105; 0x3131; 0x3190; 0x31f0; 0x3220; 0x3250;
       36:      0x4e00; 0xa490; 0xa66f; 0xa674; 0xa69e; 0xa6f0; 0xa802; 0xa806; 0xa80b;
       37:      0xa825; 0xa82c; 0xa8c4; 0xa8e0; 0xa8ff; 0xa926; 0xa947; 0xa960; 0xa980;
       38:      0xa9b3; 0xa9b6; 0xa9bc; 0xa9e5; 0xaa29; 0xaa31; 0xaa35; 0xaa43; 0xaa4c;
       39:      0xaa7c; 0xaab0; 0xaab2; 0xaab7; 0xaabe; 0xaac1; 0xaaec; 0xaaf6; 0xabe5;
       40:      0xabe8; 0xabed; 0xac00; 0xf900; 0xfb1e; 0xfe00; 0xfe10; 0xfe20; 0xfe30;
       41:      0xfe54; 0xfe68; 0xfeff; 0xff01; 0xffe0; 0xfff9; 0x101fd; 0x102e0;
       42:      0x10376; 0x10a01; 0x10a05; 0x10a0c; 0x10a38; 0x10a3f; 0x10ae5; 0x10d24;
       43:      0x10eab; 0x10f46; 0x11001; 0x11038; 0x1107f; 0x110b3; 0x110b9; 0x110bd;
       44:      0x110cd; 0x11100; 0x11127; 0x1112d; 0x11173; 0x11180; 0x111b6; 0x111c9;
       45:      0x111cf; 0x1122f; 0x11234; 0x11236; 0x1123e; 0x112df; 0x112e3; 0x11300;
       46:      0x1133b; 0x11340; 0x11366; 0x11370; 0x11438; 0x11442; 0x11446; 0x1145e;
       47:      0x114b3; 0x114ba; 0x114bf; 0x114c2; 0x115b2; 0x115bc; 0x115bf; 0x115dc;
       48:      0x11633; 0x1163d; 0x1163f; 0x116ab; 0x116ad; 0x116b0; 0x116b7; 0x1171d;
       49:      0x11722; 0x11727; 0x1182f; 0x11839; 0x1193b; 0x1193e; 0x11943; 0x119d4;
       50:      0x119da; 0x119e0; 0x11a01; 0x11a33; 0x11a3b; 0x11a47; 0x11a51; 0x11a59;
       51:      0x11a8a; 0x11a98; 0x11c30; 0x11c38; 0x11c3f; 0x11c92; 0x11caa; 0x11cb2;
       52:      0x11cb5; 0x11d31; 0x11d3a; 0x11d3c; 0x11d3f; 0x11d47; 0x11d90; 0x11d95;
       53:      0x11d97; 0x11ef3; 0x13430; 0x16af0; 0x16b30; 0x16f4f; 0x16f8f; 0x16fe0;
       54:      0x16fe4; 0x16ff0; 0x17000; 0x18800; 0x18d00; 0x1b000; 0x1b150; 0x1b164;
       55:      0x1b170; 0x1bc9d; 0x1bca0; 0x1d167; 0x1d173; 0x1d185; 0x1d1aa; 0x1d242;
       56:      0x1da00; 0x1da3b; 0x1da75; 0x1da84; 0x1da9b; 0x1daa1; 0x1e000; 0x1e008;
       57:      0x1e01b; 0x1e023; 0x1e026; 0x1e130; 0x1e2ec; 0x1e8d0; 0x1e944; 0x1f004;
       58:      0x1f0cf; 0x1f18e; 0x1f191; 0x1f200; 0x1f210; 0x1f240; 0x1f250; 0x1f260;
       59:      0x1f300; 0x1f32d; 0x1f337; 0x1f37e; 0x1f3a0; 0x1f3cf; 0x1f3e0; 0x1f3f4;
       60:      0x1f3f8; 0x1f440; 0x1f442; 0x1f4ff; 0x1f54b; 0x1f550; 0x1f57a; 0x1f595;
       61:      0x1f5a4; 0x1f5fb; 0x1f680; 0x1f6cc; 0x1f6d0; 0x1f6d5; 0x1f6eb; 0x1f6f4;
       62:      0x1f7e0; 0x1f90c; 0x1f93c; 0x1f947; 0x1f97a; 0x1f9cd; 0x1fa70; 0x1fa78;
       63:      0x1fa80; 0x1fa90; 0x1fab0; 0x1fac0; 0x1fad0; 0x20000; 0x30000; 0xe0001;
       64:      0xe0020; 0xe0100|],
       65:    [|0x0000; 0x036f; 0x0489; 0x05bd; 0x05bf; 0x05c2; 0x05c5; 0x05c7; 0x0605;
       66:      0x061a; 0x061c; 0x065f; 0x0670; 0x06dd; 0x06e4; 0x06e8; 0x06ed; 0x070f;
       67:      0x0711; 0x074a; 0x07b0; 0x07f3; 0x07fd; 0x0819; 0x0823; 0x0827; 0x082d;
       68:      0x085b; 0x0902; 0x093a; 0x093c; 0x0948; 0x094d; 0x0957; 0x0963; 0x0981;
       69:      0x09bc; 0x09c4; 0x09cd; 0x09e3; 0x09fe; 0x0a02; 0x0a3c; 0x0a42; 0x0a48;
       70:      0x0a4d; 0x0a51; 0x0a71; 0x0a75; 0x0a82; 0x0abc; 0x0ac5; 0x0ac8; 0x0acd;
       71:      0x0ae3; 0x0aff; 0x0b01; 0x0b3c; 0x0b3f; 0x0b44; 0x0b4d; 0x0b56; 0x0b63;
       72:      0x0b82; 0x0bc0; 0x0bcd; 0x0c00; 0x0c04; 0x0c40; 0x0c48; 0x0c4d; 0x0c56;
       73:      0x0c63; 0x0c81; 0x0cbc; 0x0cbf; 0x0cc6; 0x0ccd; 0x0ce3; 0x0d01; 0x0d3c;
       74:      0x0d44; 0x0d4d; 0x0d63; 0x0d81; 0x0dca; 0x0dd4; 0x0dd6; 0x0e31; 0x0e3a;
       75:      0x0e4e; 0x0eb1; 0x0ebc; 0x0ecd; 0x0f19; 0x0f35; 0x0f37; 0x0f39; 0x0f7e;
       76:      0x0f84; 0x0f87; 0x0f97; 0x0fbc; 0x0fc6; 0x1030; 0x1037; 0x103a; 0x103e;
       77:      0x1059; 0x1060; 0x1074; 0x1082; 0x1086; 0x108d; 0x109d; 0x115f; 0x135f;
       78:      0x1714; 0x1734; 0x1753; 0x1773; 0x17b5; 0x17bd; 0x17c6; 0x17d3; 0x17dd;
       79:      0x180e; 0x1886; 0x18a9; 0x1922; 0x1928; 0x1932; 0x193b; 0x1a18; 0x1a1b;
       80:      0x1a56; 0x1a5e; 0x1a60; 0x1a62; 0x1a6c; 0x1a7c; 0x1a7f; 0x1ac0; 0x1b03;
       81:      0x1b34; 0x1b3a; 0x1b3c; 0x1b42; 0x1b73; 0x1b81; 0x1ba5; 0x1ba9; 0x1bad;
       82:      0x1be6; 0x1be9; 0x1bed; 0x1bf1; 0x1c33; 0x1c37; 0x1cd2; 0x1ce0; 0x1ce8;
       83:      0x1ced; 0x1cf4; 0x1cf9; 0x1df9; 0x1dff; 0x200f; 0x202e; 0x2064; 0x206f;
       84:      0x20f0; 0x231b; 0x232a; 0x23ec; 0x23f0; 0x23f3; 0x25fe; 0x2615; 0x2653;
       85:      0x267f; 0x2693; 0x26a1; 0x26ab; 0x26be; 0x26c5; 0x26ce; 0x26d4; 0x26ea;
       86:      0x26f3; 0x26f5; 0x26fa; 0x26fd; 0x2705; 0x270b; 0x2728; 0x274c; 0x274e;
       87:      0x2755; 0x2757; 0x2797; 0x27b0; 0x27bf; 0x2b1c; 0x2b50; 0x2b55; 0x2cf1;
       88:      0x2d7f; 0x2dff; 0x2e99; 0x2ef3; 0x2fd5; 0x2ffb; 0x3029; 0x302d; 0x303e;
       89:      0x3096; 0x309a; 0x30ff; 0x312f; 0x318e; 0x31e3; 0x321e; 0x3247; 0x4dbf;
       90:      0xa48c; 0xa4c6; 0xa672; 0xa67d; 0xa69f; 0xa6f1; 0xa802; 0xa806; 0xa80b;
       91:      0xa826; 0xa82c; 0xa8c5; 0xa8f1; 0xa8ff; 0xa92d; 0xa951; 0xa97c; 0xa982;
       92:      0xa9b3; 0xa9b9; 0xa9bd; 0xa9e5; 0xaa2e; 0xaa32; 0xaa36; 0xaa43; 0xaa4c;
       93:      0xaa7c; 0xaab0; 0xaab4; 0xaab8; 0xaabf; 0xaac1; 0xaaed; 0xaaf6; 0xabe5;
       94:      0xabe8; 0xabed; 0xd7a3; 0xfaff; 0xfb1e; 0xfe0f; 0xfe19; 0xfe2f; 0xfe52;
       95:      0xfe66; 0xfe6b; 0xfeff; 0xff60; 0xffe6; 0xfffb; 0x101fd; 0x102e0;
       96:      0x1037a; 0x10a03; 0x10a06; 0x10a0f; 0x10a3a; 0x10a3f; 0x10ae6; 0x10d27;
       97:      0x10eac; 0x10f50; 0x11001; 0x11046; 0x11081; 0x110b6; 0x110ba; 0x110bd;
       98:      0x110cd; 0x11102; 0x1112b; 0x11134; 0x11173; 0x11181; 0x111be; 0x111cc;
       99:      0x111cf; 0x11231; 0x11234; 0x11237; 0x1123e; 0x112df; 0x112ea; 0x11301;
      100:      0x1133c; 0x11340; 0x1136c; 0x11374; 0x1143f; 0x11444; 0x11446; 0x1145e;
      101:      0x114b8; 0x114ba; 0x114c0; 0x114c3; 0x115b5; 0x115bd; 0x115c0; 0x115dd;
      102:      0x1163a; 0x1163d; 0x11640; 0x116ab; 0x116ad; 0x116b5; 0x116b7; 0x1171f;
      103:      0x11725; 0x1172b; 0x11837; 0x1183a; 0x1193c; 0x1193e; 0x11943; 0x119d7;
      104:      0x119db; 0x119e0; 0x11a0a; 0x11a38; 0x11a3e; 0x11a47; 0x11a56; 0x11a5b;
      105:      0x11a96; 0x11a99; 0x11c36; 0x11c3d; 0x11c3f; 0x11ca7; 0x11cb0; 0x11cb3;
      106:      0x11cb6; 0x11d36; 0x11d3a; 0x11d3d; 0x11d45; 0x11d47; 0x11d91; 0x11d95;
      107:      0x11d97; 0x11ef4; 0x13438; 0x16af4; 0x16b36; 0x16f4f; 0x16f92; 0x16fe3;
      108:      0x16fe4; 0x16ff1; 0x187f7; 0x18cd5; 0x18d08; 0x1b11e; 0x1b152; 0x1b167;
      109:      0x1b2fb; 0x1bc9e; 0x1bca3; 0x1d169; 0x1d182; 0x1d18b; 0x1d1ad; 0x1d244;
      110:      0x1da36; 0x1da6c; 0x1da75; 0x1da84; 0x1da9f; 0x1daaf; 0x1e006; 0x1e018;
      111:      0x1e021; 0x1e024; 0x1e02a; 0x1e136; 0x1e2ef; 0x1e8d6; 0x1e94a; 0x1f004;
      112:      0x1f0cf; 0x1f18e; 0x1f19a; 0x1f202; 0x1f23b; 0x1f248; 0x1f251; 0x1f265;
      113:      0x1f320; 0x1f335; 0x1f37c; 0x1f393; 0x1f3ca; 0x1f3d3; 0x1f3f0; 0x1f3f4;
      114:      0x1f43e; 0x1f440; 0x1f4fc; 0x1f53d; 0x1f54e; 0x1f567; 0x1f57a; 0x1f596;
      115:      0x1f5a4; 0x1f64f; 0x1f6c5; 0x1f6cc; 0x1f6d2; 0x1f6d7; 0x1f6ec; 0x1f6fc;
      116:      0x1f7eb; 0x1f93a; 0x1f945; 0x1f978; 0x1f9cb; 0x1f9ff; 0x1fa74; 0x1fa7a;
      117:      0x1fa86; 0x1faa8; 0x1fab6; 0x1fac2; 0x1fad6; 0x2fffd; 0x3fffd; 0xe0001;
      118:      0xe007f; 0xe01ef|],
      119:    [|0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0;
      120:      0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0;
      121:      0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0;
      122:      0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0;
      123:      0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 2; 0; 0; 0; 0;
      124:      0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0;
      125:      0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0;
      126:      0; 0; 0; 0; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2;
      127:      2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 0; 0; 0; 2; 2; 2; 2; 2; 0; 2;
      128:      2; 0; 2; 2; 2; 2; 2; 2; 2; 2; 2; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0;
      129:      0; 2; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 2;
      130:      2; 0; 0; 2; 0; 2; 2; 2; 0; 2; 2; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0;
      131:      0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0;
      132:      0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0;
      133:      0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0;
      134:      0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 2; 0; 2; 2; 2; 2; 2; 2; 2; 2; 0;
      135:      0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 2; 2; 2;
      136:      2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2;
      137:      2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 0; 0; 0|])
      138: 
      139: let s000 = ""
      140: let s001 = "\000\000\000\000\000\000\000\000\000\000\b\000\000\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
      141: let s002 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\000"
      142: let s003 = "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\016\016\016\016\016\016\016\016\016\016\016\016\016\000\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
      143: let s004 = "\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002"
      144: let s005 = "\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
      145: let s006 = "\016\016\016\002\002\002\002\002\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
      146: let s007 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\016\002"
      147: let s008 = "\016\002\002\016\002\002\016\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
      148: let s009 = "\011\011\011\011\011\011\016\016\016\016\016\016\016\016\016\016\002\002\002\002\002\002\002\002\002\002\002\016\000\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
      149: let s010 = "\016\016\016\016\016\016\016\016\016\016\016\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
      150: let s011 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\002\002\002\002\002\011\016\002\002\002\002\002\002\016\016\002\002\016\002\002\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
      151: let s012 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\011\016\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002"
      152: let s013 = "\002\002\002\002\002\002\002\002\002\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
      153: let s014 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\002\002\002\002\002\002\002\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
      154: let s015 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\002\002\002\002\002\002\002\016\016\016\016\016\016\016\016\016\002\016\016"
      155: let s016 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\002\002\016\002\002\002\002\002\002\002\002\002\016\002\002\002\016\002\002\002\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
      156: let s017 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
      157: let s018 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\011\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002"
      158: let s019 = "\002\002\002\r\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\r\002\016\r\r"
      159: let s020 = "\r\002\002\002\002\002\002\002\002\r\r\r\r\002\r\r\016\002\002\002\002\002\002\002\016\016\016\016\016\016\016\016\016\016\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
      160: let s021 = "\016\002\r\r\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\016\002\r"
      161: let s022 = "\r\002\002\002\002\016\016\r\r\016\016\r\r\002\016\016\016\016\016\016\016\016\016\002\016\016\016\016\016\016\016\016\016\016\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\016"
      162: let s023 = "\016\002\002\r\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\016\r\r"
      163: let s024 = "\r\002\002\016\016\016\016\002\002\016\016\002\002\002\016\016\016\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\016\016\016\002\016\016\016\016\016\016\016\016\016\016"
      164: let s025 = "\r\002\002\002\002\002\016\002\002\r\016\r\r\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\002\002\002\002"
      165: let s026 = "\016\002\r\r\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\016\002\002"
      166: let s027 = "\r\002\002\002\002\016\016\r\r\016\016\r\r\002\016\016\016\016\016\016\016\002\002\002\016\016\016\016\016\016\016\016\016\016\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
      167: let s028 = "\016\016\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\r"
      168: let s029 = "\002\r\r\016\016\016\r\r\r\016\r\r\r\002\016\016\016\016\016\016\016\016\016\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
      169: let s030 = "\002\r\r\r\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002"
      170: let s031 = "\002\r\r\r\r\016\002\002\002\016\002\002\002\002\016\016\016\016\016\016\016\002\002\016\016\016\016\016\016\016\016\016\016\016\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
      171: let s032 = "\016\002\r\r\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\016\r\002"
      172: let s033 = "\r\r\002\r\r\016\002\r\r\016\r\r\002\002\016\016\016\016\016\016\016\002\002\016\016\016\016\016\016\016\016\016\016\016\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
      173: let s034 = "\002\002\r\r\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\016\002\r"
      174: let s035 = "\r\002\002\002\002\016\r\r\r\016\r\r\r\002\011\016\016\016\016\016\016\016\016\002\016\016\016\016\016\016\016\016\016\016\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
      175: let s036 = "\016\002\r\r\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
      176: let s037 = "\016\016\016\016\016\016\016\016\016\016\002\016\016\016\016\002\r\r\002\002\002\016\002\016\r\r\r\r\r\r\r\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\r\r\016\016\016\016\016\016\016\016\016\016\016\016"
      177: let s038 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\016\r\002\002\002\002\002\002\002\016\016\016\016\016"
      178: let s039 = "\016\016\016\016\016\016\016\002\002\002\002\002\002\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
      179: let s040 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\016\r\002\002\002\002\002\002\002\002\002\016\016\016"
      180: let s041 = "\016\016\016\016\016\016\016\016\002\002\002\002\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
      181: let s042 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\016\002\016\002\016\016\016\016\r\r"
      182: let s043 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\002\002\002\002\002\002\002\002\002\002\002\002\r"
      183: let s044 = "\002\002\002\002\002\016\002\002\016\016\016\016\016\002\002\002\002\002\002\002\002\002\002\002\016\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\016\016\016"
      184: let s045 = "\016\016\016\016\016\016\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
      185: let s046 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\002\002\r\002\002\002\002\002\002\016\002\002\r\r\002\002\016"
      186: let s047 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\r\r\002\002\016\016\016\016\002\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\002\002\016\016\016\016\016\016\016\016\016\016\016"
      187: let s048 = "\016\016\002\016\r\002\002\016\016\016\016\016\016\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
      188: let s049 = "\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007"
      189: let s050 = "\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\015\015\015\015\015\015\015\015\015\015\015\015\015\015\015\015\015\015\015\015\015\015\015\015\015\015\015\015\015\015\015\015"
      190: let s051 = "\015\015\015\015\015\015\015\015\015\015\015\015\015\015\015\015\015\015\015\015\015\015\015\015\015\015\015\015\015\015\015\015\015\015\015\015\015\015\015\015\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014"
      191: let s052 = "\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014"
      192: let s053 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
      193: let s054 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\002\016\016\016\016\016\016\016\016\016\016\016"
      194: let s055 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\016\016\016\016\016\016\016\016\016\016\016\016"
      195: let s056 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\r\002\002\002\002\002\002\002\r\r"
      196: let s057 = "\r\r\r\r\r\r\002\r\r\002\002\002\002\002\002\002\002\002\002\002\016\016\016\016\016\016\016\016\016\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
      197: let s058 = "\016\016\016\016\016\016\016\016\016\016\016\002\002\002\000\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
      198: let s059 = "\016\016\016\016\016\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
      199: let s060 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\002\r\r\r\r\002\002\r\r\r\016\016\016\016\r\r\002\r\r\r\r\r\r\002\002\002\016\016\016\016"
      200: let s061 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\r\r\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
      201: let s062 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\r\002\r\002\002\002\002\002\002\002\016\002\016\002\016\016\002\002\002\002\002\002\002\002\r\r\r\r\r\r\002\002\002\002\002\002\002\002\002\002\016\016\002"
      202: let s063 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002"
      203: let s064 = "\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
      204: let s065 = "\002\002\002\002\r\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\002\002\002\002\002\r\002\r\r\r"
      205: let s066 = "\r\r\002\r\r\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\002\002\002\002\002\002\002\016\016\016\016\016\016\016\016\016\016\016\016"
      206: let s067 = "\002\002\r\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\r\002\002\002\002\r\r\002\002\r\002\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
      207: let s068 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\r\002\002\r\r\r\002\r\002\002\002\r\r\016\016\016\016\016\016\016\016\016\016\016\016"
      208: let s069 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\r\r\r\r\r\r\r\r\002\002\002\002\002\002\002\002\r\r\002\002\016\016\016\016\016\016\016\016"
      209: let s070 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\002\016\002\002\002\002\002\002\002\002\002\002\002\002\002\r\002\002\002\002\002\002\002\016\016\016\016\002\016\016\016\016\016\016\002\016\016\r\002\002\016\016\016\016\016\016"
      210: let s071 = "\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\016\002\002\002\002\002"
      211: let s072 = "\016\016\016\016\016\016\016\016\016\016\016\000\002\017\000\000\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\000\000\000\000\000\000\000\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
      212: let s073 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
      213: let s074 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
      214: let s075 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
      215: let s076 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002"
      216: let s077 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002"
      217: let s078 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\002\002\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
      218: let s079 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
      219: let s080 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\002\002\016\002\002\002\002\002\002\002\002\002\002\016\016"
      220: let s081 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
      221: let s082 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
      222: let s083 = "\016\016\002\016\016\016\002\016\016\016\016\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\r\r\002\002\r\016\016\016\016\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
      223: let s084 = "\r\r\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\r\r\r\r\r\r\r\r\r\r\r\r"
      224: let s085 = "\r\r\r\r\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\002"
      225: let s086 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\002\002\002\002\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
      226: let s087 = "\016\016\016\016\016\016\016\002\002\002\002\002\002\002\002\002\002\002\r\r\016\016\016\016\016\016\016\016\016\016\016\016\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\007\016\016\016"
      227: let s088 = "\002\002\002\r\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\r\r\002\002\002\002\r\r\002\002\r\r"
      228: let s089 = "\r\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
      229: let s090 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\002\002\002\002\r\r\002\002\r\r\002\002\016\016\016\016\016\016\016\016\016"
      230: let s091 = "\016\016\016\002\016\016\016\016\016\016\016\016\002\r\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\016\016\016"
      231: let s092 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\016\002\002\002\016\016\002\002\016\016\016\016\016\002\002"
      232: let s093 = "\016\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\r\002\002\r\r\016\016\016\016\016\r\002\016\016\016\016\016\016\016\016\016"
      233: let s094 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\r\r\002\r\r\002\r\r\016\r\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
      234: let s095 = "\t\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\t\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\t\n\n\n\n\n\n\n"
      235: let s096 = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\t\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\t\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
      236: let s097 = "\n\n\n\n\n\n\n\n\n\n\n\n\t\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\t\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
      237: let s098 = "\n\n\n\n\t\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\t\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\t\n\n\n"
      238: let s099 = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\t\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\t\n\n\n\n\n\n\n\n\n\n\n"
      239: let s100 = "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\t\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\t\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
      240: let s101 = "\n\n\n\n\n\n\n\n\t\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\t\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
      241: let s102 = "\n\n\n\n\n\n\n\n\t\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\016\016\016\016\016\016\016\016\016\016\016\016\015\015\015\015\015\015\015\015\015\015\015\015\015\015\015\015"
      242: let s103 = "\015\015\015\015\015\015\015\016\016\016\016\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\014\016\016\016\016"
      243: let s104 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
      244: let s105 = "\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
      245: let s106 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\000\000\000\000\000\000\000\000\000\000\000\000\016\016\016\016"
      246: let s107 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\016\016"
      247: let s108 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
      248: let s109 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\002\002\002\016\016\016\016\016"
      249: let s110 = "\016\002\002\002\016\002\002\016\016\016\016\016\002\002\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\002\016\016\016\016\002"
      250: let s111 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
      251: let s112 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
      252: let s113 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
      253: let s114 = "\016\016\016\016\016\016\002\002\002\002\002\002\002\002\002\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
      254: let s115 = "\r\002\r\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\002\002\002\002\002\002"
      255: let s116 = "\002\002\002\002\002\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002"
      256: let s117 = "\002\002\r\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\r\r\r\002\002\002\002\r\r\002\002\016\016\011\016\016"
      257: let s118 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\011\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
      258: let s119 = "\002\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\002\002\002\r\002\002\002\002\002\002\002\002\016\016\016\016\016\016\016\016\016\016\016"
      259: let s120 = "\016\016\016\016\016\r\r\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\016\016\016\016\016\016\016\016\016\016\016\016"
      260: let s121 = "\002\002\r\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\r\r\r\002\002\002\002\002\002\002\002\002\r"
      261: let s122 = "\r\016\011\011\016\016\016\016\016\002\002\002\002\016\r\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
      262: let s123 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\r\r\r\002\002\002\r\r\002\r\002\002\016\016\016\016\016\016\002\016"
      263: let s124 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\r\r\r\002\002\002\002\002\002\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
      264: let s125 = "\002\r\r\r\r\016\016\r\r\016\016\r\r\r\016\016\016\016\016\016\016\016\016\002\016\016\016\016\016\016\016\016\016\016\r\r\016\016\002\002\002\002\002\002\002\016\016\016\002\002\002\002\002\016\016\016\016\016\016\016\016\016\016\016"
      265: let s126 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\r\r\r\002\002\002\002\002\002\002\002"
      266: let s127 = "\r\r\002\002\002\r\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
      267: let s128 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\r\r\002\002\002\002\002\002\r\002\r\r\002\r\002"
      268: let s129 = "\002\r\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
      269: let s130 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\r\r\002\002\002\002\016\016\r\r\r\r\002\002\r\002"
      270: let s131 = "\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
      271: let s132 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\r\r\r\002\002\002\002\002\002\002\002\r\r\002\r\002"
      272: let s133 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\r\002\r\r\002\002\002\002\002\002\r\002\016\016\016\016\016\016\016\016"
      273: let s134 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\002\r\r\002\002\002\002\r\002\002\002\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
      274: let s135 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\r\r\r\002\002\002\002\002\002\002\002\002\r\002\002\016\016\016\016\016"
      275: let s136 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\r\r\r\r\r\016\r\r\016\016\002\002\r\002\011"
      276: let s137 = "\r\011\r\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
      277: let s138 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\r\r\r\002\002\002\002\016\016\002\002\r\r\r\r\002\016\016\016\r\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
      278: let s139 = "\016\002\002\002\002\002\002\002\002\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\002\002\002\002\r\011\002\002\002\002\016"
      279: let s140 = "\016\016\016\016\016\016\016\002\016\016\016\016\016\016\016\016\016\002\002\002\002\002\002\r\r\002\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
      280: let s141 = "\016\016\016\016\011\011\011\011\011\011\002\002\002\002\002\002\002\002\002\002\002\002\002\r\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
      281: let s142 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\r\002\002\002\002\002\002\002\016\002\002\002\002\002\002\r\002"
      282: let s143 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\016\r\002\002\002\002\002\002\002\r\002\002\r\002\002\016\016\016\016\016\016\016\016\016"
      283: let s144 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\002\002\002\002\016\016\016\002\016\002\002\016\002"
      284: let s145 = "\002\002\002\002\002\002\011\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
      285: let s146 = "\016\016\016\016\016\016\016\016\016\016\r\r\r\r\r\016\002\002\016\r\r\002\r\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
      286: let s147 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\r\r\016\016\016\016\016\016\016\016\016"
      287: let s148 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\000\000\000\000\000\000\000\000\000\016\016\016\016\016\016\016"
      288: let s149 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\002\002\002\016\016\016\016\016\016\016\016\016\016\016"
      289: let s150 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\002\002\002\002\002\016\016\016\016\016\016\016\016\016"
      290: let s151 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\016\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r"
      291: let s152 = "\r\r\r\r\r\r\r\r\016\016\016\016\016\016\016\002\002\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
      292: let s153 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\016\016\016\016\016\016\016\016\016\016\016\r\r\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
      293: let s154 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\016\000\000\000\000\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
      294: let s155 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\r\002\002\002\016\016\016\r\002\002\002\002\002\000\000\000\000\000\000\000\000\002\002\002\002\002"
      295: let s156 = "\002\002\002\016\016\002\002\002\002\002\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
      296: let s157 = "\016\016\002\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
      297: let s158 = "\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\016\016\016\016\002\002\002\002\002"
      298: let s159 = "\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\016\016\016\016\016\016\016\016\002\016\016\016\016\016\016\016\016\016\016"
      299: let s160 = "\016\016\016\016\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\002\002\002\016\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
      300: let s161 = "\002\002\002\002\002\002\002\016\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\016\016\002\002\002\002\002\002\002\016\002\002\016\002\002\002\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
      301: let s162 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
      302: let s163 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\002\002\002\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
      303: let s164 = "\016\016\016\016\002\002\002\002\002\002\002\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016"
      304: let s165 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\012\012\012\012\012\012\012\012\012\012\012\012\012\012\012\012\012\012\012\012\012\012\012\012\012\012"
      305: let s166 = "\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\016\002\002\002\002\002"
      306: let s167 = "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002"
      307: let s168 = "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
      308: let s169 = "\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
      309: 
      310: let grapheme_cluster_boundary =
      311:   [|[|s001; s002; s003; s000; s000; s000; s000; s000; s000; s000; s000; s000;
      312:       s004; s005; s000; s000; s000; s000; s006; s000; s000; s000; s007; s008;
      313:       s009; s010; s000; s011; s012; s013; s014; s015; s016; s017; s000; s018;
      314:       s019; s020; s021; s022; s023; s024; s023; s025; s026; s027; s028; s029;
      315:       s030; s031; s032; s033; s034; s035; s036; s037; s038; s039; s040; s041;
      316:       s042; s043; s044; s045|];
      317:     [|s046; s047; s048; s000; s049; s050; s051; s052; s000; s000; s000; s000;
      318:       s000; s053; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000;
      319:       s000; s000; s000; s000; s054; s055; s056; s057; s058; s000; s059; s000;
      320:       s060; s000; s000; s000; s061; s062; s063; s064; s065; s066; s067; s068;
      321:       s069; s000; s000; s070; s000; s000; s000; s071; s000; s000; s000; s000;
      322:       s000; s000; s000; s000|];
      323:     [|s072; s073; s000; s074; s000; s000; s000; s000; s000; s000; s000; s000;
      324:       s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000;
      325:       s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000;
      326:       s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000;
      327:       s000; s000; s000; s075; s000; s076; s000; s077; s000; s000; s000; s000;
      328:       s000; s000; s000; s000|];
      329:     [|s078; s000; s079; s000; s000; s000; s000; s000; s000; s000; s000; s000;
      330:       s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000;
      331:       s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000;
      332:       s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000;
      333:       s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000;
      334:       s000; s000; s000; s000|];
      335:     [||]; [||]; [||]; [||]; [||]; [||];
      336:     [|s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000;
      337:       s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000;
      338:       s000; s080; s081; s082; s000; s000; s000; s000; s083; s000; s084; s085;
      339:       s086; s087; s088; s089; s090; s091; s092; s093; s000; s000; s000; s094;
      340:       s095; s096; s097; s098; s099; s100; s101; s095; s096; s097; s098; s099;
      341:       s100; s101; s095; s096|];
      342:     [|s097; s098; s099; s100; s101; s095; s096; s097; s098; s099; s100; s101;
      343:       s095; s096; s097; s098; s099; s100; s101; s095; s096; s097; s098; s099;
      344:       s100; s101; s095; s096; s097; s098; s099; s100; s101; s095; s096; s097;
      345:       s098; s099; s100; s101; s095; s096; s097; s098; s099; s100; s101; s095;
      346:       s096; s097; s098; s099; s100; s101; s095; s096; s097; s098; s099; s100;
      347:       s101; s095; s096; s097|];
      348:     [|s098; s099; s100; s101; s095; s096; s097; s098; s099; s100; s101; s095;
      349:       s096; s097; s098; s099; s100; s101; s095; s096; s097; s098; s099; s100;
      350:       s101; s095; s096; s097; s098; s099; s100; s101; s095; s096; s097; s098;
      351:       s099; s100; s101; s095; s096; s097; s098; s099; s100; s101; s095; s096;
      352:       s097; s098; s099; s100; s101; s095; s096; s097; s098; s099; s100; s101;
      353:       s095; s096; s097; s098|];
      354:     [|s099; s100; s101; s095; s096; s097; s098; s099; s100; s101; s095; s096;
      355:       s097; s098; s099; s100; s101; s095; s096; s097; s098; s099; s100; s101;
      356:       s095; s096; s097; s098; s099; s100; s102; s103; s000; s000; s000; s000;
      357:       s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000;
      358:       s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000;
      359:       s000; s000; s000; s000|];
      360:     [||];
      361:     [|s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000;
      362:       s104; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000;
      363:       s105; s000; s000; s002; s000; s000; s081; s106; s000; s000; s000; s000;
      364:       s000; s000; s000; s107; s000; s000; s000; s108; s000; s109; s000; s000;
      365:       s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000;
      366:       s000; s000; s000; s000|];
      367:     [|s000; s000; s000; s000; s000; s000; s000; s000; s110; s000; s000; s111;
      368:       s000; s000; s000; s000; s000; s000; s000; s000; s112; s000; s000; s000;
      369:       s000; s000; s113; s000; s000; s114; s000; s000; s115; s116; s117; s118;
      370:       s119; s120; s121; s122; s123; s000; s000; s124; s034; s125; s000; s000;
      371:       s126; s127; s128; s129; s000; s000; s130; s131; s132; s064; s133; s000;
      372:       s134; s000; s000; s000|];
      373:     [|s135; s000; s000; s000; s136; s137; s000; s138; s139; s140; s141; s000;
      374:       s000; s000; s000; s000; s142; s000; s143; s000; s144; s145; s146; s000;
      375:       s000; s000; s000; s147; s000; s000; s000; s000; s000; s000; s000; s000;
      376:       s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000;
      377:       s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000;
      378:       s000; s000; s000; s000|];
      379:     [|s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000;
      380:       s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000;
      381:       s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000;
      382:       s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000;
      383:       s148; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000;
      384:       s000; s000; s000; s000|];
      385:     [||]; [||]; [||];
      386:     [|s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s149;
      387:       s150; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000;
      388:       s000; s000; s000; s000; s000; s151; s152; s153; s000; s000; s000; s000;
      389:       s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000;
      390:       s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000;
      391:       s000; s000; s000; s000|];
      392:     [||]; [||]; [||]; [||];
      393:     [|s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000;
      394:       s000; s000; s000; s000; s000; s000; s154; s000; s000; s000; s000; s000;
      395:       s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000;
      396:       s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000;
      397:       s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000;
      398:       s000; s000; s000; s000|];
      399:     [|s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000;
      400:       s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000;
      401:       s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000;
      402:       s000; s155; s156; s000; s000; s157; s000; s000; s000; s000; s000; s000;
      403:       s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000;
      404:       s000; s000; s000; s000|];
      405:     [|s000; s000; s000; s000; s000; s000; s000; s000; s158; s159; s160; s000;
      406:       s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000;
      407:       s000; s000; s000; s000; s000; s000; s000; s000; s161; s000; s000; s000;
      408:       s150; s000; s000; s000; s000; s000; s000; s162; s000; s000; s000; s000;
      409:       s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000;
      410:       s000; s000; s000; s000|];
      411:     [|s000; s000; s000; s163; s000; s164; s000; s000; s000; s000; s000; s000;
      412:       s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000;
      413:       s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000;
      414:       s000; s000; s000; s165; s000; s000; s000; s000; s000; s000; s000; s166;
      415:       s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000;
      416:       s000; s000; s000; s000|];
      417:     [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; 
      418:     [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; 
      419:     [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; 
      420:     [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; 
      421:     [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; 
      422:     [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; 
      423:     [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; 
      424:     [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; 
      425:     [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; 
      426:     [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; 
      427:     [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; 
      428:     [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; 
      429:     [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; 
      430:     [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; 
      431:     [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; 
      432:     [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; 
      433:     [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; [||]; 
      434:     [||]; [||]; [||]; [||]; [||];
      435:     [|s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000;
      436:       s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000;
      437:       s000; s000; s000; s000; s000; s000; s000; s000; s167; s004; s168; s168;
      438:       s004; s004; s004; s169; s168; s168; s168; s168; s168; s168; s168; s168;
      439:       s168; s168; s168; s168; s168; s168; s168; s168; s168; s168; s168; s168;
      440:       s168; s168; s168; s168|];
      441:     [|s168; s168; s168; s168; s168; s168; s168; s168; s168; s168; s168; s168;
      442:       s168; s168; s168; s168; s168; s168; s168; s168; s168; s168; s168; s168;
      443:       s168; s168; s168; s168; s168; s168; s168; s168; s000; s000; s000; s000;
      444:       s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000;
      445:       s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000; s000;
      446:       s000; s000; s000; s000|]|]
Added regular file ../notty/src/no-uucp/notty_uucp_data.mli:
        1: (* Do not edit.
        2:  *
        3:  * This module contains select unicode properties extracted from Uucp,
        4:  * using `./support/gen_unicode_props.ml`.
        5:  *
        6:  * Unicode version 13.0.0.
        7:  *)
        8: 
        9: (* Uucp.Break.tty_width_hint *)
       10: val tty_width_hint: int array * int array * int array
       11: 
       12: (* Uucp.Break.Low.grapheme_cluster. *)
       13: val grapheme_cluster_boundary: string array array
       14: 
Added regular file ../notty/src/notty.ml:
        1: (* Copyright (c) 2016-2017 David Kaloper Meršinjak. All rights reserved.
        2:    See LICENSE.md. *)
        3: 
        4: let invalid_arg fmt = Format.kasprintf invalid_arg fmt
        5: 
        6: let (&.) f g x = f (g x)
        7: 
        8: let btw (x : int) a b = a <= x && x <= b
        9: let bit n b = b land (1 lsl n) > 0
       10: 
       11: let max (a : int) b = if a > b then a else b
       12: let min (a : int) b = if a < b then a else b
       13: 
       14: let is_C0 x = x < 0x20 || x = 0x7f
       15: and is_C1 x = 0x80 <= x && x < 0xa0
       16: let is_ctrl x = is_C0 x || is_C1 x
       17: and is_ascii x = x < 0x80
       18: 
       19: let rec concatm z (@) xs =
       20:   let rec accum (@) = function
       21:     | []|[_] as xs -> xs
       22:     | a::b::xs -> (a @ b) :: accum (@) xs in
       23:   match xs with [] -> z | [x] -> x | xs -> concatm z (@) (accum (@) xs)
       24: 
       25: let rec linspcm z (@) x n f = match n with
       26:   | 0 -> z
       27:   | 1 -> f x
       28:   | _ -> let m = n / 2 in linspcm z (@) x m f @ linspcm z (@) (x + m) (n - m) f
       29: 
       30: let memo (type a) ?(hash=Hashtbl.hash) ?(eq=(=)) ~size f =
       31:   let module H = Ephemeron.K1.Make
       32:     (struct type t = a let (hash, equal) = (hash, eq) end) in
       33:   let t = H.create size in fun x ->
       34:     try H.find t x with Not_found -> let y = f x in H.add t x y; y
       35: 
       36: module Buffer = struct
       37:   include Buffer
       38:   let buf = Buffer.create 1024
       39:   let mkstring f = f buf; let res = contents buf in reset buf; res
       40:   let add_decimal b = function
       41:     | x when btw x 0 999 ->
       42:         let d1 = x / 100 and d2 = (x mod 100) / 10 and d3 = x mod 10 in
       43:         if d1 > 0 then 0x30 + d1 |> Char.unsafe_chr |> add_char b;
       44:         if (d1 + d2) > 0 then 0x30 + d2 |> Char.unsafe_chr |> add_char b;
       45:         0x30 + d3 |> Char.unsafe_chr |> add_char b
       46:     | x -> string_of_int x |> add_string b
       47:   let add_chars b c n = for _ = 1 to n do add_char b c done
       48: end
       49: 
       50: module String = struct
       51:   include String
       52:   let sub0cp s i len = if i > 0 || len < length s then sub s i len else s
       53:   let of_chars_rev = function
       54:     | []  -> ""
       55:     | [c] -> String.make 1 c
       56:     | cs  ->
       57:         let n = List.length cs in
       58:         let rec go bs i = Bytes.(function
       59:           | []    -> unsafe_to_string bs
       60:           | x::xs -> unsafe_set bs i x; go bs (pred i) xs
       61:         ) in go (Bytes.create n) (n - 1) cs
       62: end
       63: 
       64: module Option = struct
       65: 
       66:   let map f = function Some x -> Some (f x) | _ -> None
       67:   let get def = function Some x -> x | _ -> def
       68:   let to_list = function Some x -> [x] | _ -> []
       69:   let (>>|) a f = map f a
       70:   let (>>=) a f = match a with Some x -> f x | _ -> None
       71: end
       72: 
       73: module Text = struct
       74: 
       75:   let err_ctrl u = invalid_arg "Notty: control char: U+%02X, %S" (Char.code u)
       76:   let err_malformed = invalid_arg "Notty: malformed UTF-8: %s, %S"
       77: 
       78:   type t =
       79:     | Ascii of string * int * int
       80:     | Utf8  of string * int array * int * int
       81: 
       82:   let equal t1 t2 = match (t1, t2) with
       83:     | (Utf8 (s1, _, i1, n1), Utf8 (s2, _, i2, n2))
       84:     | (Ascii (s1, i1, n1), Ascii (s2, i2, n2)) -> i1 = i2 && n1 = n2 && s1 = s2
       85:     | _ -> false
       86: 
       87:   let width = function Utf8 (_, _, _, w) -> w | Ascii (_, _, w)   -> w
       88: 
       89:   let empty = Ascii ("", 0, 0)
       90: 
       91:   let is_empty t = width t = 0
       92: 
       93:   let graphemes str =
       94:     let module Uuseg = Notty_grapheme_cluster in
       95:     let seg = Uuseg.create () in
       96:     let rec f (is, w as acc) i evt =
       97:       match Uuseg.add seg evt with
       98:       | `Await | `End -> acc
       99:       | `Uchar u      -> f (is, w + Notty_uucp.tty_width_hint u) i `Await
      100:       | `Boundary     ->
      101:           let is = match w with 0 -> is | 1 -> i::is | _ -> i::(-1)::is in
      102:           f (is, 0) i `Await in
      103:     let acc = Uutf.String.fold_utf_8 (fun acc i -> function
      104:       | `Malformed err -> err_malformed err str
      105:       | `Uchar _ as u  -> f acc i u
      106:       ) ([0], 0) str in
      107:     f acc (String.length str) `End |> fst |> List.rev |> Array.of_list (*XXX*)
      108: 
      109:   let dead = ' '
      110: 
      111:   let to_buffer buf = function
      112:     | Ascii (s, off, w)    -> Buffer.add_substring buf s off w
      113:     | Utf8 (s, ix, off, w) ->
      114:         let x1 = match ix.(off) with
      115:           | -1 -> Buffer.add_char buf dead; ix.(off + 1) | x -> x
      116:         and x2 = ix.(off + w) in
      117:         Buffer.add_substring buf s x1 @@
      118:           (if x2 = -1 then ix.(off + w - 1) else x2) - x1;
      119:         if x2 = -1 then Buffer.add_char buf dead
      120: 
      121:   let sub t x w =
      122:     let w1 = width t in
      123:     if w = 0 || x >= w1 then empty else
      124:       let w = min w (w1 - x) in
      125:       if w = w1 then t else match t with
      126:         Ascii (s, off, _) -> Ascii (s, off + x, w)
      127:       | Utf8 (s, ix, off, _) -> Utf8 (s, ix, off + x, w)
      128: 
      129:   let is_ascii_or_raise_ctrl s =
      130:     let (@!) s i = String.unsafe_get s i |> Char.code in
      131:     let rec go s acc i n =
      132:       if n = 0 then acc else
      133:         let x = s @! i in
      134:         if is_C0 x then
      135:           err_ctrl s.[i] s
      136:         else if x = 0xc2 && n > 1 && is_C1 (s @! (i + 1)) then
      137:           err_ctrl s.[i + 1] s
      138:         else go s (acc && is_ascii x) (i + 1) (n - 1) in
      139:     go s true 0 (String.length s)
      140: 
      141:   let of_ascii s = Ascii (s, 0, String.length s)
      142:   and of_unicode s = let x = graphemes s in Utf8 (s, x, 0, Array.length x - 1)
      143:   let of_unicode = memo ~eq:String.equal ~size:128 of_unicode
      144: 
      145:   let of_string = function
      146:     | "" -> empty
      147:     | s  -> if is_ascii_or_raise_ctrl s then of_ascii s else of_unicode s
      148: 
      149:   let of_uchars ucs = of_string @@ Buffer.mkstring @@ fun buf ->
      150:     Array.iter (Buffer.add_utf_8_uchar buf) ucs
      151: 
      152:   let replicateu w u =
      153:     if is_ctrl (Uchar.to_int u) then
      154:       err_ctrl (Uchar.unsafe_to_char u) "<repeated character>"
      155:     else if w < 1 then empty
      156:     else if is_ascii (Uchar.to_int u) then
      157:       of_ascii (String.make w (Uchar.unsafe_to_char u))
      158:     else of_unicode @@ Buffer.mkstring @@ fun buf ->
      159:       for _ = 1 to w do Buffer.add_utf_8_uchar buf u done
      160: 
      161:   let replicatec w c = replicateu w (Uchar.of_char c)
      162: end
      163: 
      164: module A = struct
      165: 
      166:   type color = int
      167:   type style = int
      168:   type t = { fg : color; bg : color; st : style }
      169: 
      170:   let equal t1 t2 = t1.fg = t2.fg && t1.bg = t2.bg && t1.st = t2.st
      171:   let unsafe_color_of_int int= int
      172:   let unsafe_style_of_int int= int
      173: 
      174:   let black        = 0x01000000
      175:   and red          = 0x01000001
      176:   and green        = 0x01000002
      177:   and yellow       = 0x01000003
      178:   and blue         = 0x01000004
      179:   and magenta      = 0x01000005
      180:   and cyan         = 0x01000006
      181:   and white        = 0x01000007
      182:   and lightblack   = 0x01000008
      183:   and lightred     = 0x01000009
      184:   and lightgreen   = 0x0100000a
      185:   and lightyellow  = 0x0100000b
      186:   and lightblue    = 0x0100000c
      187:   and lightmagenta = 0x0100000d
      188:   and lightcyan    = 0x0100000e
      189:   and lightwhite   = 0x0100000f
      190: 
      191:   let tag c = (c land 0x03000000) lsr 24
      192: 
      193:   let rgb ~r ~g ~b =
      194:     if r < 0 || g < 0 || b < 0 || r > 5 || g > 5 || b > 5 then
      195:       invalid_arg "Notty.A.rgb %d %d %d: channel out of range" r g b
      196:     else 0x01000000 lor (r * 36 + g * 6 + b + 16)
      197: 
      198:   let gray level =
      199:     if level < 0 || level > 23 then
      200:       invalid_arg "Notty.A.gray %d: level out of range" level
      201:     else 0x01000000 lor (level + 232)
      202: 
      203:   let rgb_888 ~r ~g ~b =
      204:     if r < 0 || g < 0 || b < 0 || r > 255 || g > 255 || b > 255 then
      205:       invalid_arg "Notty.A.rgb_888 %d %d %d: channel out of range" r g b
      206:     else 0x02000000 lor ((r lsl 16) lor (g lsl 8) lor b)
      207: 
      208:   let i x = x land 0xff
      209:   and r x = x lsr 16 land 0xff
      210:   and g x = x lsr 8 land 0xff
      211:   and b x = x land 0xff
      212: 
      213:   let bold      = 1
      214:   and italic    = 2
      215:   and underline = 4
      216:   and blink     = 8
      217:   and reverse   = 16
      218: 
      219:   let empty = { fg = 0; bg = 0; st = 0 }
      220: 
      221:  let (++) a1 a2 =
      222:    if a1 == empty then a2 else if a2 == empty then a1 else
      223:      { fg = (match a2.fg with 0 -> a1.fg | x -> x)
      224:      ; bg = (match a2.bg with 0 -> a1.bg | x -> x)
      225:      ; st = a1.st lor a2.st }
      226: 
      227:   let fg fg = { empty with fg }
      228:   let bg bg = { empty with bg }
      229:   let st st = { empty with st }
      230: end
      231: 
      232: module I = struct
      233: 
      234:   type dim = int * int
      235: 
      236:   type t =
      237:     | Empty
      238:     | Segment  of A.t * Text.t
      239:     | Hcompose of (t * t) * dim
      240:     | Vcompose of (t * t) * dim
      241:     | Zcompose of (t * t) * dim
      242:     | Hcrop    of (t * int * int) * dim
      243:     | Vcrop    of (t * int * int) * dim
      244:     | Void     of dim
      245: 
      246:   let width = function
      247:     | Empty -> 0
      248:     | Segment (_, text) -> Text.width text
      249:     | Hcompose (_, (w, _)) -> w
      250:     | Vcompose (_, (w, _)) -> w
      251:     | Zcompose (_, (w, _)) -> w
      252:     | Hcrop    (_, (w, _)) -> w
      253:     | Vcrop    (_, (w, _)) -> w
      254:     | Void         (w, _)  -> w [@@inline]
      255: 
      256:   let height = function
      257:     | Empty -> 0
      258:     | Segment _ -> 1
      259:     | Hcompose (_, (_, h)) -> h
      260:     | Vcompose (_, (_, h)) -> h
      261:     | Zcompose (_, (_, h)) -> h
      262:     | Hcrop    (_, (_, h)) -> h
      263:     | Vcrop    (_, (_, h)) -> h
      264:     | Void         (_, h)  -> h [@@inline]
      265: 
      266:   let equal t1 t2 =
      267:     let rec eq t1 t2 = match (t1, t2) with
      268:       | (Empty, Empty) -> true
      269:       | (Segment (a1, t1), Segment (a2, t2)) ->
      270:           A.equal a1 a2 && Text.equal t1 t2
      271:       | (Hcompose ((a, b), _), Hcompose ((c, d), _))
      272:       | (Vcompose ((a, b), _), Vcompose ((c, d), _))
      273:       | (Zcompose ((a, b), _), Zcompose ((c, d), _)) -> eq a c && eq b d
      274:       | (Hcrop ((a, i1, n1), _), Hcrop ((b, i2, n2), _))
      275:       | (Vcrop ((a, i1, n1), _), Vcrop ((b, i2, n2), _)) ->
      276:           i1 = i2 && n1 = n2 && eq a b
      277:       | (Void (a, b), Void (c, d)) -> a = c && b = d
      278:       | _ -> false in
      279:     width t1 = width t2 && height t1 = height t2 && eq t1 t2
      280: 
      281:   let empty = Empty
      282: 
      283:   let (<|>) t1 t2 = match (t1, t2) with
      284:     | (_, Empty) -> t1
      285:     | (Empty, _) -> t2
      286:     | _          ->
      287:         let w = width t1 + width t2
      288:         and h = max (height t1) (height t2) in
      289:         Hcompose ((t1, t2), (w, h))
      290: 
      291:   let (<->) t1 t2 = match (t1, t2) with
      292:     | (_, Empty) -> t1
      293:     | (Empty, _) -> t2
      294:     | _          ->
      295:         let w = max (width t1) (width t2)
      296:         and h = height t1 + height t2 in
      297:         Vcompose ((t1, t2), (w, h))
      298: 
      299:   let (</>) t1 t2 = match (t1, t2) with
      300:     | (_, Empty) -> t1
      301:     | (Empty, _) -> t2
      302:     | _          ->
      303:         let w = max (width t1) (width t2)
      304:         and h = max (height t1) (height t2) in
      305:         Zcompose ((t1, t2), (w, h))
      306: 
      307:   let void w h =
      308:     if w < 1 && h < 1 then Empty else Void (max 0 w, max 0 h)
      309: 
      310:   let lincropinv crop void (++) init fini img =
      311:     match (init >= 0, fini >= 0) with
      312:     | (true, true) -> crop init fini img
      313:     | (true, _   ) -> crop init 0 img ++ void (-fini)
      314:     | (_   , true) -> void (-init) ++ crop 0 fini img
      315:     | _            -> void (-init) ++ img ++ void (-fini)
      316: 
      317:   let hcrop =
      318:     let ctor left right img =
      319:       let h = height img and w = width img - left - right in
      320:       if w > 0 then Hcrop ((img, left, right), (w, h)) else void w h
      321:     in lincropinv ctor (fun w -> void w 0) (<|>)
      322: 
      323:   let vcrop =
      324:     let ctor top bottom img =
      325:       let w = width img and h = height img - top - bottom in
      326:       if h > 0 then Vcrop ((img, top, bottom), (w, h)) else void w h
      327:     in lincropinv ctor (void 0) (<->)
      328: 
      329:   let crop ?(l=0) ?(r=0) ?(t=0) ?(b=0) img =
      330:     let img = if l <> 0 || r <> 0 then hcrop l r img else img in
      331:     if t <> 0 || b <> 0 then vcrop t b img else img
      332: 
      333:   let hpad left right img = hcrop (-left) (-right) img
      334: 
      335:   let vpad top bottom img = vcrop (-top) (-bottom) img
      336: 
      337:   let pad ?(l=0) ?(r=0) ?(t=0) ?(b=0) img =
      338:     crop ~l:(-l) ~r:(-r) ~t:(-t) ~b:(-b) img
      339: 
      340:   let hcat = concatm empty (<|>)
      341: 
      342:   let vcat = concatm empty (<->)
      343: 
      344:   let zcat xs = List.fold_right (</>) xs empty
      345: 
      346:   let text attr tx =
      347:     if Text.is_empty tx then void 0 1 else Segment (attr, tx)
      348: 
      349:   let string attr s = text attr (Text.of_string s)
      350: 
      351:   let uchars attr a = text attr (Text.of_uchars a)
      352: 
      353:   let tabulate m n f =
      354:     let m = max m 0 and n = max n 0 in
      355:     linspcm empty (<->) 0 n (fun y -> linspcm empty (<|>) 0 m (fun x -> f x y))
      356: 
      357:   let chars ctor attr c w h =
      358:     if w < 1 || h < 1 then void w h else
      359:       let line = text attr (ctor w c) in tabulate 1 h (fun _ _ -> line)
      360: 
      361:   let char  = chars Text.replicatec
      362:   let uchar = chars Text.replicateu
      363: 
      364:   let hsnap ?(align=`Middle) w img =
      365:     let off = width img - w in match align with
      366:       | `Left   -> hcrop 0 off img
      367:       | `Right  -> hcrop off 0 img
      368:       | `Middle -> let w1 = off / 2 in hcrop w1 (off - w1) img
      369: 
      370:   let vsnap ?(align=`Middle) h img =
      371:     let off = height img - h in match align with
      372:       | `Top    -> vcrop 0 off img
      373:       | `Bottom -> vcrop off 0 img
      374:       | `Middle -> let h1 = off / 2 in vcrop h1 (off - h1) img
      375: 
      376:   module Fmt = struct
      377: 
      378:     open Format
      379: 
      380:     type stag += Attr of A.t
      381: 
      382:     let push r x = r := x :: !r
      383:     let pop r = r := (match !r with _::xs -> xs | _ -> [])
      384:     let top_a r = match !r with a::_ -> a | _ -> A.empty
      385: 
      386:     let create () =
      387:       let img, line, attr = ref empty, ref empty, ref [] in
      388:       let fmt = formatter_of_out_functions {
      389:           out_flush = (fun () ->
      390:             img := !img <-> !line; line := empty; attr := [])
      391:         ; out_newline = (fun () ->
      392:             img := !img <-> !line; line := void 0 1)
      393:         ; out_string = (fun s i n ->
      394:             line := !line <|> string (top_a attr) String.(sub0cp s i n))
      395:         (* Not entirely clear; either or both could be void: *)
      396:         ; out_spaces = (fun w -> line := !line <|> char (top_a attr) ' ' w 1)
      397:         ; out_indent = (fun w -> line := !line <|> char (top_a attr) ' ' w 1)
      398:       } in
      399:       pp_set_formatter_stag_functions fmt {
      400:         (pp_get_formatter_stag_functions fmt ()) with
      401:             mark_open_stag =
      402:               (function Attr a -> push attr A.(top_a attr ++ a); "" | _ -> "")
      403:           ; mark_close_stag = (fun _ -> pop attr; "") };
      404:       pp_set_mark_tags fmt true;
      405:       fmt, fun () -> let i = !img in img := empty; line := empty; attr := []; i
      406: 
      407:     let ppf, reset = create ()
      408: 
      409:     let kstrf ?(attr = A.empty) ?(w = 1000000) k format =
      410:       let m = ref 0 in
      411:       let f1 _ () =
      412:         m := pp_get_margin ppf ();
      413:         pp_set_margin ppf w;
      414:         pp_open_stag ppf (Attr attr)
      415:       and k _ =
      416:         pp_print_flush ppf ();
      417:         pp_set_margin ppf !m;
      418:         reset () |> k
      419:       in kfprintf k ppf ("%a" ^^ format) f1 ()
      420: 
      421:     let strf ?attr ?w format = kstrf ?attr ?w (fun i -> i) format
      422: 
      423:     let attr attr f fmt x =
      424:       pp_open_stag fmt (Attr attr); f fmt x; pp_close_stag fmt ()
      425:   end
      426: 
      427:   let kstrf, strf, pp_attr = Fmt.(kstrf, strf, attr)
      428: end
      429: 
      430: module Operation = struct
      431: 
      432:   type t =
      433:     End
      434:   | Skip of int * t
      435:   | Text of A.t * Text.t * t
      436: 
      437:   let skip n k = if n = 0 then k else match k with
      438:       End         -> End
      439:     | Skip (m, k) -> Skip (m + n, k)
      440:     | _           -> Skip (n, k) [@@inline]
      441: 
      442:   let rec scan x w row i k =
      443:     let open I in match i with
      444: 
      445:     | Empty | Void _ -> skip w k
      446: 
      447:     | Segment _ when row > 0 -> skip w k
      448:     | Segment (attr, text) ->
      449:         let t  = Text.sub text x w in
      450:         let w1 = Text.width t in
      451:         let p  = if w > w1 then skip (w - w1) k else k in
      452:         if w1 > 0 then Text (attr, t, p) else p
      453: 
      454:     | Hcompose ((i1, i2), _) ->
      455:         let w1 = width i1
      456:         and w2 = width i2 in
      457:         if x >= w1 + w2 then skip w k else
      458:         if x >= w1 then scan (x - w1) w row i2 k else
      459:         if x + w <= w1 then scan x w row i1 k else
      460:           scan x (w1 - x) row i1 @@ scan 0 (w - w1 + x) row i2 @@ k
      461: 
      462:     | Vcompose ((i1, i2), _) ->
      463:         let h1 = height i1
      464:         and h2 = height i2 in
      465:         if row >= h1 + h2 then skip w k else
      466:         if row >= h1 then scan x w (row - h1) i2 k else scan x w row i1 k
      467: 
      468:     | Zcompose ((i1, i2), _) ->
      469:         let rec stitch x w row i = function
      470:           | End -> scan x w row i End
      471:           | Text (a, t, ops) as opss ->
      472:               let w1 = Text.width t in
      473:               if w1 >= w then opss else
      474:                 Text (a, t, stitch (x + w1) (w - w1) row i ops)
      475:           | Skip (w1, ops) ->
      476:               scan x w1 row i @@
      477:                 if w1 >= w then ops else stitch (x + w1) (w - w1) row i ops
      478:         in stitch x w row i2 @@ scan x w row i1 @@ k
      479: 
      480:     | Hcrop ((i, left, _), (w1, _)) ->
      481:         if x >= w1 then skip w k else
      482:         if x + w <= w1 then scan (x + left) w row i k else
      483:           scan (x + left) (w1 - x) row i @@ skip (w - w1 + x) k
      484: 
      485:     | Vcrop ((i, top, _), (_, h1)) ->
      486:         if row < h1 then scan x w (top + row) i k else skip w k
      487: 
      488:   let of_image (x, y) (w, h) i =
      489:     List.init h (fun off -> scan x (x + w) (y + off) i End)
      490: end
      491: 
      492: module Cap = struct
      493: 
      494:   type op = Buffer.t -> unit
      495: 
      496:   let (&) op1 op2 buf = op1 buf; op2 buf
      497: 
      498:   type t = {
      499:     skip    : int -> op
      500:   ; sgr     : A.t -> op
      501:   ; newline : op
      502:   ; clreol  : op
      503:   ; cursvis : bool -> op
      504:   ; cursat  : int -> int -> op
      505:   ; cubcuf  : int -> op
      506:   ; cuucud  : int -> op
      507:   ; cr      : op
      508:   ; altscr  : bool -> op
      509:   ; mouse   : bool -> op
      510:   ; bpaste  : bool -> op
      511:   }
      512: 
      513:   let ((<|), (<.), (<!)) = Buffer.(add_string, add_char, add_decimal)
      514: 
      515:   let sts = [ ";1"; ";3"; ";4"; ";5"; ";7" ]
      516: 
      517:   let sgr { A.fg; bg; st } buf =
      518:     buf <| "\x1b[0";
      519:     let rgb888 buf x =
      520:       buf <! A.r x; buf <. ';'; buf <! A.g x; buf <. ';'; buf <! A.b x in
      521:     ( match A.tag fg with
      522:         0 -> ()
      523:       | 1 -> let c = A.i fg in
      524:              if c < 8  then ( buf <. ';'; buf <! (c + 30) )
      525:              else if c < 16 then ( buf <. ';'; buf <! (c + 82) )
      526:              else ( buf <| ";38;5;"; buf <! c )
      527:       | _ -> buf <| ";38;2;"; rgb888 buf fg );
      528:     ( match A.tag bg with
      529:         0 -> ()
      530:       | 1 -> let c = A.i bg in
      531:              if c < 8  then ( buf <. ';'; buf <! (c + 40) )
      532:              else if c < 16 then ( buf <. ';'; buf <! (c + 92) )
      533:              else ( buf <| ";48;5;"; buf <! c )
      534:       | _ -> buf <| ";48;2;"; rgb888 buf bg );
      535:     if st <> 0 then
      536:       ( let rec go f xs = match (f, xs) with
      537:           | (0, _) | (_, []) -> ()
      538:           | (_, x::xs) -> if f land 1 > 0 then buf <| x; go (f lsr 1) xs in
      539:         go st sts );
      540:     buf <. 'm'
      541: 
      542:   let ansi = {
      543:       skip    = (fun n b -> b <| "\x1b[0m"; Buffer.add_chars b ' ' n)
      544:     ; newline = (fun b -> b <| "\x1bE")
      545:     ; altscr  = (fun x b -> b <| if x then "\x1b[?1049h" else "\x1b[?1049l")
      546:     ; cursat  = (fun w h b -> b <| "\x1b["; b <! h; b <. ';'; b <! w; b <. 'H')
      547:     ; cubcuf  = (fun x b -> b <| "\x1b["; b <! abs x; b <. if x < 0 then 'D' else 'C')
      548:     ; cuucud  = (fun y b -> b <| "\x1b["; b <! abs y; b <. if y < 0 then 'A' else 'B')
      549:     ; cr      = (fun b -> b <| "\x1b[1G")
      550:     ; clreol  = (fun b -> b <| "\x1b[K")
      551:     ; cursvis = (fun x b -> b <| if x then "\x1b[34h\x1b[?25h" else "\x1b[?25l")
      552:     ; mouse   = (fun x b -> b <| if x then "\x1b[?1000;1002;1005;1015;1006h"
      553:                                       else "\x1b[?1000;1002;1005;1015;1006l")
      554:     ; bpaste  = (fun x b -> b <| if x then "\x1b[?2004h" else "\x1b[?2004l")
      555:     ; sgr }
      556: 
      557:   let no0 _     = ()
      558:   and no1 _ _   = ()
      559:   and no2 _ _ _ = ()
      560: 
      561:   let dumb = {
      562:       skip    = (fun n b -> Buffer.add_chars b ' ' n)
      563:     ; newline = (fun b -> b <| "\n")
      564:     ; altscr  = no1
      565:     ; cursat  = no2
      566:     ; cubcuf  = no1
      567:     ; cuucud  = no1
      568:     ; cr      = no0
      569:     ; clreol  = no0
      570:     ; cursvis = no1
      571:     ; sgr     = no1
      572:     ; mouse   = no1
      573:     ; bpaste  = no1
      574:     }
      575: 
      576:   let erase cap buf = cap.sgr A.empty buf; cap.clreol buf (* KEEP ETA-LONG. *)
      577:   let cursat0 cap w h = cap.cursat (max w 0 + 1) (max h 0 + 1)
      578: end
      579: 
      580: module Render = struct
      581: 
      582:   open Cap
      583:   open Operation
      584: 
      585:   let skip_op cap buf n = cap.skip n buf
      586:   let text_op cap buf a x = cap.sgr a buf; Text.to_buffer buf x
      587: 
      588:   let rec line cap buf = function
      589:     End              -> erase cap buf
      590:   | Skip (n,    End) -> erase cap buf; skip_op cap buf n
      591:   | Text (a, x, End) -> erase cap buf; text_op cap buf a x
      592:   | Skip (n,    ops) -> skip_op cap buf n; line cap buf ops
      593:   | Text (a, x, ops) -> text_op cap buf a x; line cap buf ops
      594: 
      595:   let rec lines cap buf = function
      596:     []      -> ()
      597:   | [ln]    -> line cap buf ln; cap.sgr A.empty buf
      598:   | ln::lns -> line cap buf ln; cap.newline buf; lines cap buf lns
      599: 
      600:   let to_buffer buf cap off dim img =
      601:     Operation.of_image off dim img |> lines cap buf
      602: 
      603:   let pp cap ppf img =
      604:     let open Format in
      605:     let buf = Buffer.create (I.width img * 2) in
      606:     let h, w = I.(height img, width img |> min (pp_get_margin ppf ())) in
      607:     let img = I.(img </> vpad (h - 1) 0 (char A.empty ' ' w 1)) in
      608:     pp_open_vbox ppf 0;
      609:     for y = 0 to h - 1 do
      610:       Buffer.clear buf; to_buffer buf cap (0, y) (w, 1) img;
      611:       pp_print_as ppf w (Buffer.contents buf);
      612:       if y < h - 1 then pp_print_cut ppf ()
      613:     done;
      614:     pp_close_box ppf ()
      615: 
      616:   let pp_image = pp Cap.ansi
      617:   let pp_attr ppf a =
      618:     let string_ = I.string A.empty in
      619:     pp_image ppf I.(string_ "<" <|> string a "ATTR" <|> string_ ">")
      620: end
      621: 
      622: module Unescape = struct
      623: 
      624:   type special = [
      625:     `Escape
      626:   | `Enter
      627:   | `Tab
      628:   | `Backspace
      629:   | `Insert
      630:   | `Delete
      631:   | `Home | `End
      632:   | `Arrow of [ `Up | `Down | `Left | `Right ]
      633:   | `Page of [ `Up | `Down ]
      634:   | `Function of int
      635:   ]
      636: 
      637:   type button = [ `Left | `Middle | `Right | `Scroll of [ `Up | `Down ] ]
      638: 
      639:   type mods = [ `Meta | `Ctrl | `Shift ] list
      640: 
      641:   type key = [ special | `Uchar of Uchar.t  | `ASCII of char ] * mods
      642: 
      643:   type mouse = [ `Press of button | `Drag | `Release ] * (int * int) * mods
      644: 
      645:   type paste = [ `Start | `End ]
      646: 
      647:   type event = [ `Key of key | `Mouse of mouse | `Paste of paste ]
      648: 
      649:   type esc =
      650:     C0    of char
      651:   | C1    of char
      652:   | SS2   of char
      653:   | CSI   of string * int list * char
      654:   | Esc_M of int * int * int
      655:   | Uchar of Uchar.t
      656: 
      657:   let uchar = function `Uchar u -> u | `ASCII c -> Uchar.of_char c
      658: 
      659:   let csi =
      660:     let open Option in
      661:     let rec priv acc = function
      662:       | x::xs when btw x 0x3c 0x3f -> priv (Char.unsafe_chr x::acc) xs
      663:       | xs                         -> param (String.of_chars_rev acc) None [] xs
      664:     and param prv p ps = function
      665:       | x::xs when btw x 0x30 0x39 -> param prv (Some (get 0 p * 10 + x - 0x30)) ps xs
      666:       | 0x3b::xs                   -> param prv None (get 0 p :: ps) xs
      667:       | xs                         -> code prv (List.rev (to_list p @ ps)) xs
      668:     and code prv ps = function (* Conflate two classes because urxvt... *)
      669:       | x::xs when btw x 0x20 0x2f || btw x 0x40 0x7e ->
      670:           Some (CSI (prv, ps, (Char.chr x)), xs)
      671:       | _ -> None in
      672:     priv []
      673: 
      674:   let rec demux =
      675:     let chr = Char.chr in function
      676:     | 0x1b::0x5b::0x4d::a::b::c::xs -> Esc_M (a, b, c) :: demux xs
      677:     | 0x1b::0x5b::xs | 0x9b::xs ->
      678:         let (r, xs) = csi xs |> Option.get (C1 '\x5b', xs) in r :: demux xs
      679:     | 0x1b::0x4f::x::xs | 0x8f::x::xs
      680:         when is_ascii x                 -> SS2 (chr x) :: demux xs
      681:     | 0x1b::x::xs when is_C1 (x + 0x40) -> C1 (chr x) :: demux xs
      682:     | x::xs when is_C1 x                -> C1 (chr (x - 0x40)) :: demux xs
      683:     | x::xs when is_C0 x                -> C0 (chr x) :: demux xs
      684:     | x::xs -> Uchar (Uchar.unsafe_of_int x) :: demux xs
      685:     | [] -> []
      686: 
      687:   let xtrm_mod_flags = function
      688:     | 2 -> Some [`Shift]
      689:     | 3 -> Some [`Meta]
      690:     | 4 -> Some [`Shift; `Meta]
      691:     | 5 -> Some [`Ctrl]
      692:     | 6 -> Some [`Shift; `Ctrl]
      693:     | 7 -> Some [`Meta; `Ctrl]
      694:     | 8 -> Some [`Shift; `Meta; `Ctrl]
      695:     | _ -> None
      696: 
      697:   let mods_xtrm = function
      698:     | [1;p] -> xtrm_mod_flags p
      699:     | []    -> Some []
      700:     | _     -> None
      701: 
      702:   let mods_rxvt = function
      703:     | '~' -> Some []
      704:     | '$' -> Some [`Shift]
      705:     | '^' -> Some [`Ctrl]
      706:     | '@' -> Some [`Ctrl; `Shift]
      707:     | _ -> None
      708: 
      709:   let mods_common ps code = match (ps, code) with
      710:     | ([], '~')  -> Some []
      711:     | ([], c)    -> mods_rxvt c
      712:     | ([p], '~') -> xtrm_mod_flags p
      713:     | _          -> None
      714: 
      715:   let mouse_p p =
      716:     let btn = match p land 3 with
      717:       | 0 when bit 6 p -> `Scroll `Up
      718:       | 0              -> `Left
      719:       | 1 when bit 6 p -> `Scroll `Down
      720:       | 1              -> `Middle
      721:       | 2 when bit 6 p -> `ALL (* `Scroll `Left *)
      722:       | 2              -> `Right
      723:       | 3 when bit 6 p -> `ALL (* `Scroll `Right *)
      724:       | _              -> `ALL
      725:     and drag = bit 5 p
      726:     and mods =
      727:       (if bit 3 p then [`Meta] else []) @
      728:       (if bit 4 p then [`Ctrl] else [])
      729:     in (btn, drag, mods)
      730: 
      731:   let key k mods = Some (`Key (k, mods))
      732: 
      733:   let event_of_control_code =
      734:     let open Option in function
      735:     | Uchar u when Uchar.to_int u |> is_ascii ->
      736:         Some (`Key (`ASCII (Uchar.unsafe_to_char u), []))
      737:     | Uchar u -> Some (`Key (`Uchar u, []))
      738: 
      739:     | C0 '\x1b'        -> key `Escape []
      740:     | C0 ('\b'|'\x7f') -> key `Backspace []
      741:     | C0 '\n'          -> key `Enter []
      742:     | C0 '\t'          -> key `Tab []
      743: 
      744:     | C0 x -> key (`ASCII Char.(code x + 0x40 |> unsafe_chr)) [`Ctrl]
      745:     | C1 x -> key (`ASCII x) [`Meta]
      746: 
      747:     | CSI ("",[],'Z') -> key `Tab [`Shift]
      748: 
      749:     | CSI ("",p,'A') -> mods_xtrm p >>= key (`Arrow `Up)
      750:     | CSI ("",p,'B') -> mods_xtrm p >>= key (`Arrow `Down)
      751:     | CSI ("",p,'C') -> mods_xtrm p >>= key (`Arrow `Right)
      752:     | CSI ("",p,'D') -> mods_xtrm p >>= key (`Arrow `Left)
      753: 
      754:     | CSI ("",[],'a') -> key (`Arrow `Up) [`Shift]
      755:     | CSI ("",[],'b') -> key (`Arrow `Down) [`Shift]
      756:     | CSI ("",[],'c') -> key (`Arrow `Right) [`Shift]
      757:     | CSI ("",[],'d') -> key (`Arrow `Left) [`Shift]
      758:     | SS2 ('A'|'a') -> key (`Arrow `Up) [`Ctrl]
      759:     | SS2 ('B'|'b') -> key (`Arrow `Down) [`Ctrl]
      760:     | SS2 ('C'|'c') -> key (`Arrow `Right) [`Ctrl]
      761:     | SS2 ('D'|'d') -> key (`Arrow `Left) [`Ctrl]
      762: 
      763:     | CSI ("",5::p,c) -> mods_common p c >>= key (`Page `Up)
      764:     | CSI ("",6::p,c) -> mods_common p c >>= key (`Page `Down)
      765: 
      766:     | CSI ("",2::p,c) -> mods_common p c >>= key `Insert
      767:     | CSI ("",3::p,c) -> mods_common p c >>= key `Delete
      768: 
      769:     | CSI ("",[4],'h') -> key `Insert []
      770:     | CSI ("",[],'L')  -> key `Insert [`Ctrl]
      771:     | CSI ("",[],'P')  -> key `Delete []
      772:     | CSI ("",[],'M')  -> key `Delete [`Ctrl]
      773: 
      774:     | CSI ("",p,'H')   -> mods_xtrm p >>= key `Home
      775:     | CSI ("",[7|1],c) -> mods_rxvt c >>= key `Home
      776: 
      777:     | CSI ("",p,'F')   -> mods_xtrm p >>= key `End
      778:     | CSI ("",[8|4],c) -> mods_rxvt c >>= key `End
      779:     | CSI ("",[],'J')  -> key `End [`Ctrl]
      780: 
      781:     | SS2 ('P'..'S' as c) -> key (`Function (Char.code c - 0x4f)) []
      782: 
      783:     | CSI ("",p,('P'..'S' as c)) ->
      784:         mods_xtrm p >>= key (`Function (Char.code c - 0x4f))
      785: 
      786:     | CSI ("",k::p,c) when btw k 11 15 || btw k 17 21 || btw k 23 26 ->
      787:         mods_common p c >>= key (`Function ((k - 10) - (k - 10) / 6))
      788: 
      789:     | CSI ("<",[p;x;y],('M'|'m' as c)) ->
      790:         let (btn, drag, mods) = mouse_p p in
      791:         ( match (c, btn, drag) with
      792:           | ('M', (#button as b), false) -> Some (`Press b)
      793:           | ('M', #button, true)         -> Some `Drag
      794:           | ('m', #button, false)        -> Some `Release
      795:           (* | ('M', `ALL   , true)         -> Some `Move *)
      796:           | _                            -> None
      797:         ) >>| fun e -> `Mouse (e, (x - 1, y - 1), mods)
      798: 
      799:     | CSI ("",[p;x;y],'M') | Esc_M (p,x,y) as evt ->
      800:         let (x, y) = match evt with Esc_M _ -> x - 32, y - 32 | _ -> x, y
      801:         and (btn, drag, mods) = mouse_p (p - 32) in
      802:         ( match (btn, drag) with
      803:           | (#button as b, false) -> Some (`Press b)
      804:           | (#button     , true ) -> Some `Drag
      805:           | (`ALL        , false) -> Some `Release
      806:           (* | (`ALL        , true)  -> Some `Move *)
      807:           | _                     -> None
      808:         ) >>| fun e -> `Mouse (e, (x - 1, y - 1), mods)
      809: 
      810:     | CSI ("",[200],'~') -> Some (`Paste `Start)
      811:     | CSI ("",[201],'~') -> Some (`Paste `End)
      812: 
      813:     | CSI _ | SS2 _ -> None
      814: 
      815:   let rec events = function
      816:     | C0 '\x1b' :: cc :: ccs ->
      817:       ( match event_of_control_code cc with
      818:         | Some (`Key (k, mods)) -> `Key (k, `Meta :: mods) :: events ccs
      819:         | Some _                -> `Key (`Escape, []) :: events (cc::ccs)
      820:         | None                  -> events ccs )
      821:     | cc::ccs -> (event_of_control_code cc |> Option.to_list) @ events ccs
      822:     | [] -> []
      823: 
      824:   let decode = events &. demux &. List.map Uchar.to_int
      825: 
      826:   type t = (event list * bool) ref
      827: 
      828:   let create () = ref ([], false)
      829: 
      830:   let next t = match !t with
      831:     | (#event as e::es, eof) -> t := (es, eof) ; e
      832:     | ([], false) -> `Await
      833:     | _           -> `End
      834: 
      835:   let list_of_utf8 buf i l =
      836:     let f cs _ = function `Uchar c -> c::cs | _ -> cs in
      837:     String.sub0cp (Bytes.unsafe_to_string buf) i l
      838:     |> Uutf.String.fold_utf_8 f [] |> List.rev
      839: 
      840:   let input t buf i l = t := match !t with
      841:     | (es, false) when l > 0 -> (es @ (list_of_utf8 buf i l |> decode), false)
      842:     | (es, _)                -> (es, true)
      843: 
      844:   let pending t = match !t with ([], false) -> false | _ -> true
      845: end
      846: 
      847: module Tmachine = struct
      848: 
      849:   open Cap
      850:   (* XXX This is sad. This should be a composable, stateless transducer. *)
      851: 
      852:   type t = {
      853:     cap           : Cap.t
      854:   ; mutable write : Buffer.t -> unit
      855:   ; mutable curs  : (int * int) option
      856:   ; mutable dim   : (int * int)
      857:   ; mutable image : I.t
      858:   ; mutable dead  : bool
      859:   }
      860: 
      861:   let emit t op =
      862:     if t.dead then
      863:       invalid_arg "Notty: use of released terminal"
      864:     else t.write <- t.write & op
      865: 
      866:   let cursor cap = function
      867:     | None        -> cap.cursvis false
      868:     | Some (w, h) -> cap.cursvis true & cursat0 cap w h
      869: 
      870:   let create ~mouse ~bpaste cap = {
      871:       cap
      872:     ; curs  = None
      873:     ; dim   = (0, 0)
      874:     ; image = I.empty
      875:     ; dead  = false
      876:     ; write =
      877:         cap.altscr true & cursor cap None & cap.mouse mouse & cap.bpaste bpaste
      878:     }
      879: 
      880:   let release t =
      881:     if t.dead then false else
      882:       ( emit t ( t.cap.altscr false & t.cap.cursvis true &
      883:                  t.cap.mouse false & t.cap.bpaste false );
      884:         t.dead <- true; true )
      885: 
      886:   let output t buf = t.write buf; t.write <- ignore
      887: 
      888:   let refresh ({ dim; image; _ } as t) =
      889:     emit t ( cursor t.cap None & cursat0 t.cap 0 0 &
      890:              (fun buf -> Render.to_buffer buf t.cap (0, 0) dim image) &
      891:              cursor t.cap t.curs )
      892: 
      893:   let set_size t dim = t.dim <- dim
      894:   let image t image = t.image <- image; refresh t
      895:   let cursor t curs = t.curs <- curs; emit t (cursor t.cap curs)
      896: 
      897:   let size t = t.dim
      898:   let dead t = t.dead
      899: end
      900: 
      901: module Direct = struct
      902:   let show_cursor buf cap x = cap.Cap.cursvis x buf
      903:   and move_cursor buf cap cmd = match cmd with
      904:     | `To (w, h) -> Cap.cursat0 cap w h buf
      905:     | `Home      -> cap.Cap.cr buf
      906:     | `By (x, y) ->
      907:         Cap.(if x <> 0 then cap.cubcuf x buf; if y <> 0 then cap.cuucud y buf)
      908: end
      909: 
      910: type attr  = A.t
      911: type image = I.t
      912: 
      913: module Infix = struct
      914:   let ((<->), (<|>), (</>)) = I.((<->), (<|>), (</>))
      915:   let (++) = A.(++)
      916: end
Added regular file ../notty/src/notty.mli:
        1: (* Copyright (c) 2016-2017 David Kaloper Meršinjak. All rights reserved.
        2:    See LICENSE.md. *)
        3: 
        4: (** Declaring terminals.
        5: 
        6:     Notty is a terminal library that revolves around construction and
        7:     composition of displayable images.
        8: 
        9:     This module provides the core {{!I}[image]} abstraction, standalone
       10:     {{!Render}rendering}, and escape sequence {{!Unescape}parsing}. It does not
       11:     depend on any platform code, and does not interact with the environment.
       12:     Input and output are provided by {!Notty_unix} and {!Notty_lwt}.
       13: 
       14:     Consult the {{!basics}basics}, {{!examples}examples} and
       15:     {{!limitations}limitations}.
       16: 
       17:     {e %%VERSION%% — {{:%%PKG_HOMEPAGE%% }homepage}} *)
       18: 
       19: (** {1 Interface} *)
       20: 
       21: type attr
       22: (** Visual characteristics of displayed text. *)
       23: 
       24: type image
       25: (** Rectangles of styled characters. *)
       26: 
       27: (** [A] is for attribute.
       28: 
       29:     Construction and composition of styling characteristics of text.
       30: 
       31:     Consult the {{!basics}basics} for an overview. *)
       32: module A : sig
       33: 
       34:   (** {1 Colors} *)
       35: 
       36:   type color
       37:   (** An ineffable quality of light.
       38: 
       39:       There are three kinds of colors:
       40:       {ul
       41:       {- {e Core 16 colors.}
       42: 
       43:          ANSI defines 8 color {e names}, with the actual display colors
       44:          considered an implementation detail. Historically, this palette was
       45:          extended with their light (sometimes {e bright} or {e high-intensity})
       46:          counterparts. Their presentation is undefined too, but typically
       47:          produces a brighter shade. These colors - often called the {e ANSI
       48:          colors} - tend to be unpredictable, but ubiquitously supported.
       49: 
       50:          }
       51:       {- {e Extended 256-color palette.}
       52: 
       53:          This common feature extends the palette by further 240 colors. They
       54:          come in two groups:
       55: 
       56:          {ul
       57:          {- The {e color cube}, a 6*6*6 approximation to the usual 24-bit RGB
       58:             color cube; and}
       59:          {- the {e grayscale ramp}, containing (merely) 24 shades of gray.}}
       60: 
       61:          XTerm was the first to support this extension. Many terminals have
       62:          since cloned it, so the support is wide, but not universal.
       63: 
       64:          As the extended colors are still palette-driven they do not have a
       65:          fixed presentation, and the presentation can be changed in some
       66:          terminals. Default palette tends to match {{:
       67:          https://upload.wikimedia.org/wikipedia/commons/1/15/Xterm_256color_chart.svg}
       68:          XTerm's}.
       69: 
       70:          }
       71:       {- {e True color}
       72: 
       73:          A recently established convention allows directly sending 24-bit colors
       74:          to the terminal. This has been adopted by a growing minority of
       75:          terminals. A reasonably up-to-date status document maintained by the
       76:          community can be found {{:https://gist.github.com/XVilka/8346728}here}.}}
       77: 
       78:       Some of the technical and historical background can be found in {{:
       79:       http://invisible-island.net/xterm/xterm.faq.html#problems_colors}
       80:       XTerm's FAQ}.
       81: 
       82:       {b Note} No attempt is made to remap colors depending on the terminal.
       83:       Terminals might ignore, remap, or completely misinterpret unsupported
       84:       colors. *)
       85: 
       86:   (** {2:corecolors Core 16 colors}
       87: 
       88:       The first 8 have their standard ANSI names. *)
       89:     val unsafe_color_of_int:int->color
       90: 
       91:   val black        : color
       92:   val red          : color
       93:   val green        : color
       94:   val yellow       : color
       95:   val blue         : color
       96:   val magenta      : color
       97:   val cyan         : color
       98:   val white        : color
       99:   val lightblack   : color
      100:   val lightred     : color
      101:   val lightgreen   : color
      102:   val lightyellow  : color
      103:   val lightblue    : color
      104:   val lightmagenta : color
      105:   val lightcyan    : color
      106:   val lightwhite   : color
      107: 
      108:   (** {2 Extended 256-color palette} *)
      109: 
      110:   val rgb : r:int -> g:int -> b:int -> color
      111:   (** [rgb ~r:red ~g:green ~b:blue] is an extended-palette color from the color cube.
      112: 
      113:       All three channels must be in the range [0 - 5]. XTerm default palette maps
      114:       this to [0x00], [0x5f], [0x87], [0xaf], [0xd7], and [0xff] independently
      115:       per channel.
      116: 
      117:       @raise Invalid_argument if a channel is outside the range. *)
      118: 
      119:   val gray : int -> color
      120:   (** [gray level] is an extended-palette color from the grayscale ramp.
      121: 
      122:       [level] must be in the range [0 - 23]. XTerm default palette maps this to
      123:       [8 + level * 10] on all three channels.
      124: 
      125:       @raise Invalid_argument if the [level] is outside the range. *)
      126: 
      127:   (** {2 True Color} *)
      128: 
      129:   val rgb_888 : r:int -> g:int -> b:int -> color
      130:   (** [rgb_888 ~r:red ~g:green ~b:blue] is a 24-bit color.
      131: 
      132:       All three channels must be in the range [0 - 255].
      133: 
      134:       @raise Invalid_argument if a channel is outside the range. *)
      135: 
      136:   (** {1 Text styles} *)
      137: 
      138:   type style
      139:   (** Additional text properties. *)
      140: 
      141:   val unsafe_style_of_int: int-> style
      142: 
      143:   val bold      : style
      144:   val italic    : style
      145:   val underline : style
      146:   val blink     : style
      147:   val reverse   : style
      148: 
      149:   (** {1 Attribute construction and composition} *)
      150: 
      151:   type t = attr
      152: 
      153:   val equal : t -> t -> bool
      154: 
      155:   val empty : attr
      156:   (** [empty] is the attribute with the default foreground and background color
      157:       and empty style set. *)
      158: 
      159:   val (++) : attr -> attr -> attr
      160:   (** [a1 ++ a2] is the concatenation of [a1] and [a2], the attribute that has
      161:       [a2]'s foreground (resp. background), unless {e unset}, in which case it
      162:       is [a1]'s, and the union of both style sets.
      163: 
      164:       [++] is left-associative, and forms a monoid with [empty]. *)
      165: 
      166:   val fg : color -> attr
      167:   (** [fg c] is [empty] with foreground [c]. *)
      168: 
      169:   val bg : color -> attr
      170:   (** [bg c] is [empty] with background [c]. *)
      171: 
      172:   val st : style -> attr
      173:   (** [st s] is [empty] with style [s]. *)
      174: end
      175: 
      176: (** [I] is for image.
      177: 
      178:     Construction and composition of images.
      179: 
      180:     Consult the {{!basics}basics} for an overview. *)
      181: module I : sig
      182: 
      183:   type t = image
      184: 
      185:   val height : image -> int
      186:   val width  : image -> int
      187: 
      188:   val equal : t -> t -> bool
      189:   (** [equal t1 t2] is [true] iff [t1] and [t2] are constructed by the same term.
      190: 
      191:       {b Note} This is a weak form of equality. Images that are not [equal]
      192:       could still render the same. *)
      193: 
      194:   (** {1:imgprims Primitives} *)
      195: 
      196:   val empty : image
      197:   (** [empty] is a zero-sized image. *)
      198: 
      199:   val string : attr -> string -> image
      200:   (** [string attr s] is an image containing text [s], styled with [attr].
      201: 
      202:       @raise Invalid_argument if [string] is not a valid UTF-8 sequence, or
      203:       contains {{!ctrls}control characters}. *)
      204: 
      205:   val uchars : attr -> Uchar.t array -> image
      206:   (** [uchars attr us] is an image containing text [us], styled with [attr].
      207: 
      208:       @raise Invalid_argument if [us] contains {{!ctrls}control characters}. *)
      209: 
      210:   val char : attr -> char -> int -> int -> image
      211:   (** [char attr c w h] is a [w * h] grid of [c].
      212: 
      213:       @raise Invalid_argument if [c] is a {{!ctrls}control character}. *)
      214: 
      215:   val uchar : attr -> Uchar.t -> int -> int -> image
      216:   (** [uchar attr u w h] is a [w * h] grid of [u].
      217: 
      218:       @raise Invalid_argument if [u] is a {{!ctrls}control character}. *)
      219: 
      220:   val void  : int -> int -> image
      221:   (** [void w h] is a [w * h] rectangle of transparent cells.
      222: 
      223:       [void] is magical: it has geometry, but no displayable content. This is
      224:       different, for example, from the space character [U+0020], which renders
      225:       as a cell filled with the background color. This means that [void]
      226:       interacts specially with {{!(</>)}overlays}.
      227: 
      228:       [void 0 0 = empty].
      229:       [void] with only one dimension [0] acts as a spacing element in the other
      230:       dimension. Negative size is treated as [0]. *)
      231: 
      232:   (** {1:imgcomp Image composition}
      233: 
      234:       Three basic composition modes allow construction of more complex images
      235:       from simpler ones.
      236: 
      237:       Composition operators are left-associative and form a monoid with [void].
      238:       *)
      239: 
      240:   val (<|>) : image -> image -> image
      241:   (**  [i1 <|> i2] is the horizontal combination of [i1] and [i2].
      242: 
      243:       [width (i1 <|> i2) = width i1 + width i2]
      244:       [height (i1 <|> i2) = max (height i1) (height i2)]
      245: 
      246:       Images are top-aligned. The missing region is implicitly filled with
      247:       {{!void}[void]}.
      248: 
      249: {v
      250: [x] <|> [y] = [xy]
      251:         [y]   [.y]
      252: v}
      253: 
      254:       where [.] denotes {{!void}[void]}. *)
      255: 
      256:   val (<->) : image -> image -> image
      257:   (** [i1 <-> i2] is the vertical combination of [i1] and [i2].
      258: 
      259:       [width (i1 <-> i2) = max (width i1) (width i2)]
      260:       [height (i1 <-> i2) = height i1 + height i2]
      261: 
      262:       Images are left-aligned. The missing region is implicitly filled with
      263:       {{!void}[void]}.
      264: 
      265: {v
      266: [xx] <-> [y] = [xx]
      267:                [y.]
      268: v}
      269:       *)
      270: 
      271:   val (</>) : image -> image -> image
      272:   (** [i1 </> i2] is [i1] overlaid over [i2].
      273: 
      274:       [width (i1 </> i2) = max (width i1) (width i2)]
      275:       [height (i1 </> i2) = max (height i1) (height i2)]
      276: 
      277:       Images are top-left-aligned. In the region of their overlap, only the
      278:       {{!void}[void]} cells of [i1] show fragments of [i2].
      279: 
      280: {v
      281: [x.x] </> [yyyy] = [xyxy]
      282: v}
      283:       *)
      284: 
      285:   (** {1:imgcrop Cropping and padding} *)
      286: 
      287:   val hcrop : int -> int -> image -> image
      288:   (** [hcrop left right i] is [i] with [left] leftmost, and [right]
      289:       rightmost columns missing. If [left + right >= width i] the result is
      290:       [empty].
      291: 
      292:       If either [left] or [right] is negative, instead of being cropped, the
      293:       image is padded on that side.
      294: 
      295:       For example:
      296:       {ul
      297:       {- [hcrop 0 1 [abc]] = [[ab]]}
      298:       {- [hcrop 1 1 [abc]] = [[b]]}
      299:       {- [hcrop (-1) 1 [abc]] = [void 1 1 <|> hcrop 0 1 [abc]] = [[.ab]]}
      300:       {- [hcrop 2 2 [abc]] = [empty]}} *)
      301: 
      302:   val vcrop : int -> int -> image -> image
      303:   (** [vcrop top bottom i] is the vertical analogue to {{!hcrop}[hcrop]}. *)
      304: 
      305:   val crop : ?l:int -> ?r:int -> ?t:int -> ?b:int -> image -> image
      306:   (** [crop ~l:left ~r:right ~t:top ~b:bottom i] is
      307:       [vcrop left right (hcrop top bottom) i].
      308: 
      309:       Missing arguments default to [0]. *)
      310: 
      311:   val hpad : int -> int -> image -> image
      312:   (** {{!hcrop}[hcrop]} with margins negated. *)
      313: 
      314:   val vpad : int -> int -> image -> image
      315:   (** {{!vcrop}[vcrop]} with margins negated. *)
      316: 
      317:   val pad : ?l:int -> ?r:int -> ?t:int -> ?b:int -> image -> image
      318:   (** {{!crop}[crop]} with margins negated. *)
      319: 
      320: 
      321:   (** {1 Additional combinators} *)
      322: 
      323:   val hcat : image list -> image
      324:   (** [hcat xs] horizontally concatenates [xs]. See {{!(<|>)}beside}. *)
      325: 
      326:   val vcat : image list -> image
      327:   (** [vcat xs] vertically concatenates [xs]. See {{!(<->)}above}. *)
      328: 
      329:   val zcat : image list -> image
      330:   (** [zcat xs] overlays [xs]. See {{!(</>)}over}. *)
      331: 
      332:   val tabulate : int -> int -> (int -> int -> image) -> image
      333:   (** [tabulate m n f] is the grid of values [f x y] with [x = 0..m-1]
      334:       and [y = 0..n-1], where [x] grows to the right, and [y] growns down.
      335: 
      336:       [f a y] is to the left of [f b y] if [a < b], and [f x a] is above [f x b]
      337:       if [a < b], but the exact alignment is unspecified if the various [f x y]
      338:       have different dimensions. *)
      339: 
      340:   val hsnap : ?align:[ `Left | `Middle | `Right ] -> int -> image -> image
      341:   (** [hsnap ~align w i] is an image of width strictly [w] obtained by either
      342:       horizontally padding or cropping [i] and positioning it according to
      343:       [~align].
      344: 
      345:       [~align] defaults to [`Middle]. *)
      346: 
      347:   val vsnap : ?align:[ `Top | `Middle | `Bottom ] -> int -> image -> image
      348:   (** [vsnap ~align h i] is an image of height strictly [h] obtained by either
      349:       vertically padding or cropping [i] and positioning it according to
      350:       [~align].
      351: 
      352:       [~align] defaults to [`Middle]. *)
      353: 
      354:   (** {1 [Format] interoperability} *)
      355: 
      356:   val strf : ?attr:attr -> ?w:int -> ('a, Format.formatter, unit, image) format4 -> 'a
      357:   (** [strf ?attr ?w:width format ...] pretty-prints like
      358:       [Format.asprintf format ...], but returns an [image].
      359: 
      360:       [attr] is the (outermost) attribute. Defaults to {!A.empty}.
      361: 
      362:       [width] is used to set the margin on the formatter. This is only a hint,
      363:       and does not guarantee the width of the result. Consult
      364:       {{: http://caml.inria.fr/pub/docs/manual-ocaml/libref/Format.html#VALset_margin}
      365:       [Format.set_margin]} for details. Defaults to an unspecified, large
      366:       number.
      367: 
      368:       @raise Invalid_argument if the printing process attempts to directly
      369:       output {{!ctrls}control characters}, by embedding them in [format] or a
      370:       string printed with the [%s] conversion, for example.
      371:       {{: http://caml.inria.fr/pub/docs/manual-ocaml/libref/Format.html#fpp}
      372:       Formatted printing} is allowed. *)
      373: 
      374:   val kstrf : ?attr:attr -> ?w:int -> (image -> 'a) -> ('b, Format.formatter, unit, 'a) format4 -> 'b
      375:   (** [kstrf ?attr ?w k format ...] is continuation-based [strf ?attr ?w format ...]. *)
      376: 
      377:   val pp_attr : attr -> (Format.formatter -> 'a -> unit) -> Format.formatter -> 'a -> unit
      378:   (** [pp_attr a f] is a pretty-printer like [f], except its output is styled
      379:       with [a]. This applies only outside of any styling [f] itself might embed. *)
      380: end
      381: 
      382: (** Operators, repeated. *)
      383: module Infix : sig
      384: 
      385:   (** {2 [I]}
      386: 
      387:       See {{!I}[I]}. *)
      388: 
      389:   val (<->) : image -> image -> image
      390:   val (<|>) : image -> image -> image
      391:   val (</>) : image -> image -> image
      392: 
      393:   (** {2 [A]}
      394: 
      395:       See {{!A}[A]}. *)
      396: 
      397:   val (++)  : attr -> attr -> attr
      398: end
      399: 
      400: (** {1 Low-level interface}
      401: 
      402:     You can ignore it, unless you are porting [Notty] to a new platform not
      403:     supported by the existing IO backends. *)
      404: 
      405: (** Terminal capabilities.
      406: 
      407:     This module describes how to output things so that a terminal understands
      408:     them. *)
      409: module Cap : sig
      410: 
      411:   type t
      412:   (** A set of capabilities that distinguish terminals from one another.
      413: 
      414:       A bundle of magic strings, really. *)
      415: 
      416:   val ansi : t
      417:   (** The usual ANSI terminal, with colors, text styles and cursor
      418:       positioning. *)
      419: 
      420:   val dumb : t
      421:   (** Pure text output. Text attributes are stripped and positioning is done
      422:       with the character [U+0020], SPACE. *)
      423: end
      424: 
      425: (** Dump images to string buffers. *)
      426: module Render : sig
      427: 
      428:   val to_buffer : Buffer.t -> Cap.t -> int * int -> int * int -> image -> unit
      429:   (** [to_buffer buf cap (x, y) (w, h) i] writes the string representation of
      430:       [i] to [buf], as interpreted by [cap].
      431: 
      432:       It renders the [w * h] rectangle of [i], offset by [(x, y)] from the top
      433:       left. *)
      434: 
      435:   val pp : Cap.t -> Format.formatter -> image -> unit
      436:   (** [pp cap ppf i] renders [i] to the pretty-printer [ppf].
      437: 
      438:       {b Note} [pp] is generally meant for development and debugging. It tries
      439:       to be reasonable, but dedicated IO modules handle the actual output
      440:       better. *)
      441: 
      442:   (**/**)
      443:   (* Toplevel. *)
      444:   val pp_image : Format.formatter -> image -> unit
      445:   val pp_attr : Format.formatter -> attr -> unit
      446:   (**/**)
      447: end
      448: 
      449: (** Parse and decode escape sequences in character streams. *)
      450: module Unescape : sig
      451: 
      452:   (** {1 Input events} *)
      453: 
      454:   type special = [
      455:     `Escape
      456:   | `Enter
      457:   | `Tab
      458:   | `Backspace
      459:   | `Insert
      460:   | `Delete
      461:   | `Home | `End
      462:   | `Arrow of [ `Up | `Down | `Left | `Right ]
      463:   | `Page of [ `Up | `Down ]
      464:   | `Function of int
      465:   ]
      466:   (** A selection of extra keys on the keyboard. *)
      467: 
      468:   type button = [ `Left | `Middle | `Right | `Scroll of [ `Up | `Down ] ]
      469:   (** Mouse buttons. *)
      470: 
      471:   type mods = [ `Meta | `Ctrl | `Shift ] list
      472:   (** Modifier state. *)
      473: 
      474:   type key = [ special | `Uchar of Uchar.t | `ASCII of char ] * mods
      475:   (** Keypress event. *)
      476: 
      477:   type mouse = [ `Press of button | `Drag | `Release ] * (int * int) * mods
      478:   (** Mouse event. *)
      479: 
      480:   type paste = [ `Start | `End ]
      481:   (** Paste event. *)
      482: 
      483:   type event = [ `Key of key | `Mouse of mouse | `Paste of paste ]
      484:   (** Things that terminals say to applications.
      485: 
      486:       {ul
      487:       {- [`Key (k, mods)] is keyboard input.
      488: 
      489:          [k] is a {{!key}key}, one of:
      490:          {ul
      491:          {- [`ASCII c] where [c] is a [char] in the
      492:             {{: https://tools.ietf.org/html/rfc20}ASCII} range;}
      493:          {- [`Uchar u] where [u] is any other {{!Uchar.t}unicode character}; or}
      494:          {- a {{!special}special key}.}}
      495: 
      496:          [`ASCII] and [`Uchar] together represent the textual part of the input.
      497:          These characters are guaranteed not to be {{!ctrls}control
      498:          characters}, and are safe to use when constructing images. ASCII is
      499:          separated from the rest of Unicode for convenient pattern-matching.
      500: 
      501:          [mods] are the extra {{!mods}modifier keys}.
      502: 
      503:          }
      504:       {- [`Mouse (event, (x, y), mods)] is mouse input.
      505: 
      506:          [event] is the actual mouse event: {{!button}[button]} press, release,
      507:          or motion of the mouse with buttons depressed.
      508: 
      509:          [(x, y)] are column and row position of the mouse. The origin is
      510:          [(0,0)], the upper-left corner.
      511: 
      512:          {b Note} Every [`Press (`Left|`Middle|`Right)] generates a corresponding
      513:          [`Release], but there is no portable way to detect which button was
      514:          released. [`Scroll (`Up|`Down)] presses are not followed by releases.
      515: 
      516:          }
      517:       {- [`Paste (`Start|`End)] are {e bracketed paste} events, signalling the
      518:          beginning and end of a sequence of events pasted into the terminal.
      519: 
      520:          {b Note} This mechanism is useful, but not reliable. The pasted text
      521:          could contain spurious start-of-paste or end-of-paste markers, or they
      522:          could be entered by hand. }}
      523: 
      524:       Terminal input protocols are historical cruft, and heavily overload the
      525:       ASCII range. For instance:
      526:       {ul
      527:       {- It is impossible to distinguish lower- and upper-case ASCII characters
      528:          if {b Ctrl} is pressed;}
      529:       {- several combinations of key-presses are aliased as special keys; and}
      530:       {- in a UTF-8 encoded stream, there is no representation for non-ASCII
      531:          characters with modifier keys.}}
      532: 
      533:       This means that many values that inhabit the [event] type are impossible,
      534:       while some reflect multiple different user actions. Limitations include:
      535: 
      536:       {ul
      537:       {- [`Shift] is reported only with special keys, and not all of them.}
      538:       {- [`Meta] and [`Control] are reported with mouse events, key events with
      539:          special keys, and key events with values in the ranges [0x40-0x5f]
      540:          ([@] to [_]) and [0x60-0x7e] ([`] to [~]). If {b Ctrl} is pressed, the higher
      541:          range is mapped into the lower range.}
      542:       {- Terminals will variously under-report modifier key state.}}
      543: 
      544:       Perform own experiments before relying on elaborate key combinations. *)
      545: 
      546:   val uchar : [< `Uchar of Uchar.t | `ASCII of char ] -> Uchar.t
      547:   (** [uchar x] is the {!Uchar.t} corresponding to [x]. This operations merges
      548:       the ASCII and Unicode variants of {{!key}key}. *)
      549: 
      550:   (** {1 Decoding filter}
      551: 
      552:       Simple IO-less terminal input processor. It can be used for building
      553:       custom terminal input abstractions. *)
      554: 
      555:   type t
      556:   (** Input decoding filter.
      557: 
      558:       The filter should be {{!input}fed} strings, which it first decodes from
      559:       UTF-8, and then extracts the input events.
      560: 
      561:       Malformed UTF-8 input bytes and unrecognized escape sequences are silently
      562:       discarded. *)
      563: 
      564:   val create : unit -> t
      565:   (** [create ()] is a new, empty filter. *)
      566: 
      567:   val input : t -> bytes -> int -> int -> unit
      568:   (** [input t buffer i len] feeds [len] bytes of [string] into [t], starting
      569:       from position [len].
      570: 
      571:       [len = 0] signals the end of input.
      572: 
      573:       [buffer] is immediately processed and can be reused after the call
      574:       returns. *)
      575: 
      576:   val next : t -> [ event | `Await | `End ]
      577:   (** [next t] is the next event in the filter's input stream:
      578: 
      579:       {ul
      580:       {- [#event], an input {{!event}[event]}.}
      581:       {- [`Await] if the filter needs more {{!input}input}.}
      582:       {- [`End] if the input had ended.}} *)
      583: 
      584:   val pending : t -> bool
      585:   (** [pending t] is [true] if a call to [next], without any intervening input,
      586:       would {e not} return [`Await]. *)
      587: 
      588:   (** {1 Low-level parsing}
      589: 
      590:       {b Warning} The parsing interface is subject to change.
      591: 
      592:       Implementation of small parts of
      593:       {{: http://www.ecma-international.org/publications/standards/Ecma-035.htm}ECMA-35}
      594:       and
      595:       {{: http://www.ecma-international.org/publications/standards/Ecma-048.htm}ECMA-48},
      596:       as needed by terminal emulators in common use. *)
      597: 
      598:   val decode : Uchar.t list -> event list
      599:   (** [decode us] are the events encoded by [us].
      600: 
      601:       [us] are assumed to have been generated in a burst, and the end of the
      602:       list is taken to mean a pause.
      603:       Therefore, [decode us1 @ decode us2 <> decode (us1 @ us2)] if [us1] ends
      604:       with a partial escape sequence, including a lone [\x1b].
      605: 
      606:       Unsupported escape sequences are silently discarded. *)
      607: end
      608: 
      609: (**/**)
      610: (** {1 Private}
      611: 
      612:     These are private interfaces, prone to breakage. Don't use them. *)
      613: 
      614: module Operation : sig
      615:   type t
      616:   val of_image : (int * int) -> int * int -> image -> t list
      617: end
      618: 
      619: module Tmachine : sig
      620: 
      621:   type t
      622: 
      623:   val create  : mouse:bool -> bpaste:bool -> Cap.t -> t
      624:   val release : t -> bool
      625:   val output  : t -> Buffer.t -> unit
      626: 
      627:   val refresh  : t -> unit
      628:   val cursor   : t -> (int * int) option -> unit
      629:   val image    : t -> image -> unit
      630: 
      631:   val set_size : t -> int * int -> unit
      632: 
      633:   val size : t -> int * int
      634:   val dead : t -> bool
      635: end
      636: 
      637: module Direct : sig
      638:   val move_cursor : Buffer.t -> Cap.t -> [ `Home | `By of int * int | `To of int * int ] -> unit
      639:   val show_cursor : Buffer.t -> Cap.t -> bool -> unit
      640: end
      641: (**/**)
      642: 
      643: (** {1:basics Basics}
      644: 
      645:     Print a red-on-black ["Wow!"] above its right-shifted copy:
      646: {[
      647: let wow = I.string A.(fg red ++ bg black) "Wow!" in
      648: I.(wow <-> (void 2 0 <|> wow)) |> Notty_unix.output_image
      649: ]}
      650: 
      651:     {2:meaning The meaning of images}
      652: 
      653:     An {{!image}[image]} value is a rectangle of styled character cells. It has a
      654:     width and height, but is not anchored to an origin. A single character with
      655:     associated display attributes, or a short fragment of text, are simple
      656:     examples of images.
      657: 
      658:     Images are created by combining text fragments with {{!attributes}display
      659:     attributes}, and composed by placing them {{!I.(<|>)}beside} each other,
      660:     {{!I.(<->)}above} each other, and {{!I.(</>)}over} each other.
      661: 
      662:     Once constructed, an image can be rendered, and only at that point it obtains
      663:     absolute placement.
      664: 
      665:     Consult {{!I}[I]} for more details.
      666: 
      667:     {2:attributes Display attributes}
      668: 
      669:     {{!attr}[attr]} values describe the styling characteristics of fragments of
      670:     text.
      671: 
      672:     They combine a foreground and a background {{!A.color}[color]} with a
      673:     set of {{!A.style}[styles]}. Either color can be {e unset}, which corresponds to
      674:     the terminal's default foreground (resp. background) color.
      675: 
      676:     Attributes are used to construct primitive images.
      677: 
      678:     Consult {{!A}[A]} for more details.
      679: 
      680:     {2:ctrls Control characters}
      681: 
      682:     These are taken to be characters in the ranges [0x00-0x1f] ({b C0}), [0x7f]
      683:     (BACKSPACE), [0x80-0x9f] ({b C1}). This is the
      684:     {{: http://unicode.org/reports/tr44/#General_Category_Values}Unicode
      685:     general category} {b Cc}.
      686: 
      687:     As control characters directly influence the cursor positioning, they
      688:     cannot be used to create images.
      689: 
      690:     This, in particular, means that images cannot contain [U+000a] (NEWLINE).
      691: 
      692:     {1:limitations Limitations}
      693: 
      694:     [Notty] does not use Terminfo. If your terminal is particularly
      695:     idiosyncratic, things might fail to work. Get in touch with the author to
      696:     expand support.
      697: 
      698:     [Notty] assumes that the terminal is using UTF-8 for input and output.
      699:     Things might break arbitrarily if this is not the case.
      700: 
      701:     For performance considerations, consult the {{!perf}performance model}.
      702: 
      703:     {2:cwidth Unicode vs. Text geometry}
      704: 
      705:     [Notty] uses [Uucp.Break.tty_width_hint] to guess the width of text
      706:     fragments when computing geometry, and it suffers from the same
      707:     shortcomings:
      708: 
      709:     {ul
      710:     {- Geometry in general works for alphabets and east Asian scripts, mostly
      711:         works for abjad scripts, and is a matter of luck for abugidas.}
      712:     {- East Asian scripts work better when in
      713:         {{:http://unicode.org/glossary/#normalization_form_c}NFC}.}
      714:     {- For proper emoji display, [Uucp] and the terminal have to agree on the
      715:        Unicode version.}}
      716: 
      717:     When in doubt, see
      718:     {{: http://erratique.ch/software/uucp/doc/Uucp.Break.html#VALtty_width_hint}
      719:     [Uucp.Break.tty_width_hint]}.
      720: 
      721:     Unicode has special interaction with {{!I.hcrop}horizontal cropping}:
      722:     {ul
      723:     {- Strings within images are cropped at {{:
      724:         http://unicode.org/reports/tr29/#Grapheme_Cluster_Boundaries}grapheme
      725:         cluster} boundaries. This means that scalar value sequences that are
      726:         rendered combined, or overlaid, stay unbroken.}
      727:     {- When a crop splits a wide character in two, the remaining half is
      728:         replaced by [U+0020] (SPACE). Hence, character-cell-accurate cropping is
      729:         possible even in the presence of characters that horizontally occupy
      730:         more than one cell.}}
      731: 
      732:     {1:examples Examples}
      733: 
      734:     We assume a toplevel with [Notty] support ([#require "notty.top"]).
      735: 
      736:     {2 Hello}
      737: 
      738:     ["Rad!"] with default foreground and background:
      739: 
      740:     {[I.string A.empty "Rad!"]}
      741: 
      742:     Everything has to start somewhere.
      743: 
      744:     {2 Colors}
      745: 
      746:     ["Rad!"] in rad letters:
      747: 
      748:     {[I.string A.(fg lightred) "Rad!"]}
      749: 
      750:     {2 Padding and spacing}
      751: 
      752: {[
      753: let a1 = A.(fg lightwhite ++ bg red)
      754: and a2 = A.(fg red)
      755: ]}
      756: 
      757:     ["Rad"] and [" stuff!"] in different colors:
      758: 
      759:     {[I.(string a1 "Rad" <|> string a2 " stuff!")]}
      760: 
      761:     The second word hanging on a line below:
      762: 
      763:     {[I.(string a1 "Rad" <|> (string a2 "stuff!" |> vpad 1 0))]}
      764: 
      765:     {2 More geometry}
      766: 
      767:     Sierpinski triangle:
      768: 
      769: {[
      770: let square = "\xe2\x96\xaa"
      771: 
      772: let rec sierp n =
      773:   if n > 1 then
      774:     let ss = sierp (pred n) in I.(ss <-> (ss <|> ss))
      775:   else I.(string A.(fg magenta) square |> hpad 1 0)
      776: ]}
      777: 
      778:     {[sierp 8]}
      779: 
      780:     A triangle overlaid over its shifted copy:
      781: 
      782:     {[let s = sierp 6 in I.(s </> vpad 1 0 s)]}
      783: 
      784:     Blinkenlights:
      785: 
      786: {[
      787: let rad n color =
      788:   let a1 = A.fg color in
      789:   let a2 = A.(st blink ++ a1) in
      790:   I.((string a2 "Rad" |> hpad n 0) <->
      791:      (string a1 "(⌐■_■)" |> hpad (n + 7) 0))
      792: 
      793: let colors = A.[red; green; yellow; blue; magenta; cyan]
      794: ]}
      795: 
      796: {[
      797: colors |> List.mapi I.(fun i c -> rad i c |> pad ~t:i ~l:(2 * i))
      798:        |> I.zcat
      799: ]}
      800: 
      801:     {b Note} Usage of {{!A.blink}[blink]} might be regulated by law in some
      802:     jurisdictions.
      803: 
      804:     {2 Pretty-printing}
      805: 
      806:     Images can be pretty-printed into:
      807: 
      808:     {[I.strf "(%d)" 42]}
      809: 
      810:     Attributes can be applied to the entire format string, or by decorating
      811:     {e user-defined printers} that are supplied with [%a] conversions:
      812: 
      813:     {[let pp = Format.pp_print_int]}
      814: 
      815:     {[I.strf ~attr:A.(fg lightwhite) "(%a)" (I.pp_attr A.(fg green) pp) 42]}
      816: 
      817:     {2 Now with output}
      818: 
      819:     The core module has no real IO. Examples above are simple [image]-valued
      820:     expressions, displayed by the pretty-printer that is installed by the
      821:     toplevel support. Self-contained programs need a separate IO module:
      822: 
      823:     {[#require "notty.unix"]}
      824: 
      825:     {[sierp 8 |> Notty_unix.output_image]}
      826: 
      827:     (Note the difference in cropping behavior.)
      828: 
      829:     Computations can be adapted to the current terminal size. A line can stretch
      830:     end-to-end:
      831: 
      832: {[
      833: Notty_unix.output_image_size @@ fun (w, _) ->
      834:   let i1 = I.string A.(fg green) "very"
      835:   and i2 = I.string A.(fg yellow) "melon" in
      836:   I.(i1 <|> void (w - width i1 - width i2) 1 <|> i2)
      837: ]}
      838: 
      839:     The largest triangle that horizontally fits into the terminal:
      840: 
      841: {[
      842: Notty_unix.output_image_size @@ fun (w, _) ->
      843:   let steps = int_of_float ((log (float w)) /. log 2.) in
      844:   sierp steps |> I.vpad 0 1
      845: ]}
      846: 
      847:     {2 Simple interaction}
      848: 
      849:     Interactive Sierpinski:
      850: 
      851:     {[open Notty_unix]}
      852: 
      853: {[
      854: let img (double, n) =
      855:   let s = sierp n in
      856:   if double then I.(s </> vpad 1 0 s) else s
      857: in
      858: let rec update t state = Term.image t (img state); loop t state
      859: and loop t (double, n as state) =
      860:   match Term.event t with
      861:   | `Key (`Enter,_)        -> ()
      862:   | `Key (`Arrow `Left,_)  -> update t (double, max 1 (n - 1))
      863:   | `Key (`Arrow `Right,_) -> update t (double, min 8 (n + 1))
      864:   | `Key (`ASCII ' ', _)   -> update t (not double, n)
      865:   | `Resize _              -> update t state
      866:   | _                      -> loop t state
      867: in
      868: let t = Term.create ()
      869: in
      870: update t (false, 1); Term.release t
      871: ]}
      872: 
      873:     The program uses a fullscreen {{!Notty_unix.Term}terminal} and loops reading
      874:     the {{!Notty_unix.Term.event}input}. LEFT and RIGHT control the iteration
      875:     count, and SPACE toggles double-drawing. Resizing the window causes a
      876:     redraw. When the loop exits on ENTER, the terminal is
      877:     {{!Notty_unix.Term.release}cleaned up}.
      878: 
      879:     {1:perf Performance model}
      880: 
      881:     This section is only relevant if using [Notty] becomes your bottleneck.
      882: 
      883:     {b TL;DR} Shared sub-expressions do not share work, so operators stick with
      884:     you.
      885: 
      886:     The main performance parameter is {e image complexity}. This roughly
      887:     corresponds to the number of image {{!I.imgcomp}composition} and
      888:     {{!I.imgcrop}cropping} operators in the fully expanded [image] term,
      889:     {b ignoring all sharing}.
      890: 
      891:     Outline numbers:
      892: 
      893:     {ul
      894:     {- Highly complex images can be rendered and pushed out to a full-screen
      895:        terminal more than 1000 times per second.}
      896:     {- With more realistic images, this number is closer to 30,000.}
      897:     {- Input processing is somewhere around 50MB/s.}}
      898: 
      899: 
      900:     Image complexity [cplx] of an image [i] is:
      901:     {ul
      902:     {- For a {{!I.imgprims}primitive} [i], [cplx i = 1].}
      903:     {- For a {{!I.imgcomp}composition} operator [op],
      904:        [cplx (op i1 i2) = 1 + cplx i1 + cplx i2].}
      905:     {- For a {{!I.imgcomp}crop} [cr],
      906:        [cplx (cr i1) = 1 + cplx i1 - k], where [k] is the combined complexity of
      907:        all the {e maximal} sub-terms that do not contribute to the output.}}
      908: 
      909:     For example (assuming an image [i]):
      910: 
      911: {[
      912:   let img1 = I.((i <|> i) <-> (i <|> i))
      913:   let img2 = I.(let x = i <|> i in x <-> x)
      914:   let img3 = I.(((i <|> i) <|> i) <|> i)
      915: ]}
      916: 
      917:     Complexity of each of these is [4 * cplx i + 3]. This might be surprising
      918:     for [img2].
      919: 
      920:     If [width i = 1], [cplx (hcrop 1 0 img1) = 3 + 2 * cplx i], and
      921:     [cplx (hcrop 2 0 img3) = 2 + 2 * cplx i].
      922: 
      923:     While [Notty] strives to be accommodating to all usage scenarios, these are
      924:     the things to keep in mind if the rendering becomes slow:
      925: 
      926:     {ol
      927:     {- Image composition is cheap.
      928: 
      929:        Combining images performs a negligible amount of computation.
      930: 
      931:        Constructing primitive images that contain scalar values outside of the
      932:        ASCII range does a little more work upfront and is worth holding onto.
      933: 
      934:        }
      935:     {- {{!Render}Rendering} depends on image complexity.
      936: 
      937:        As a consequence, this real-world example of wrapping renders in time
      938:        O(n{^ 2}) in the number of lines:
      939: 
      940: {[
      941: let wrap1 width img =
      942:   let rec go img = img ::
      943:     if I.width img > width then go (I.hcrop width 0 img) else []
      944:   in go img |> I.vcat |> I.hsnap ~align:`Left width
      945: ]}
      946: 
      947:        Although [crop] is applied only [lines] times, the image complexity of
      948:        each line depends on the number of preceding lines.
      949: 
      950:        An O(n) version does not iterate [crop]:
      951: 
      952: {[
      953: let wrap2 width img =
      954:   let rec go off = I.hcrop off 0 img ::
      955:     if I.width img - off > width then go (off + width) else []
      956:   in go 0 |> I.vcat |> I.hsnap ~align:`Left width
      957: ]}
      958:        }
      959:     {- Rendering depends on the {e output} dimensions, but not on the {e image}
      960:        dimensions.
      961: 
      962:        Rendering an image to [w * h] implicitly crops it to its leftmost [w]
      963:        columns and topmost [h] rows. While [w] and [h] will have an impact on
      964:        the rendering performance, the complexity of the (cropped) image tends to
      965:        be more important.}}
      966: 
      967: *)
Added regular file ../notty/src/notty_top.ml:
        1: (* Copyright (c) 2017 David Kaloper Meršinjak. All rights reserved.
        2:    See LICENSE.md. *)
        3: 
        4: (* Force linking with Notty for e.g. Omod. *)
        5: let _ = Sys.opaque_identity Notty.I.empty
        6: 
        7: #if OCAML_VERSION >= (4,14,0)
        8: let _ = Toploop.use_silently Format.err_formatter (Toploop.File "notty_top_init.ml")
        9: #else
       10: let _ = Toploop.use_silently Format.err_formatter "notty_top_init.ml"
       11: #endif
Added regular file ../notty/src/notty_top_init.ml:
        1: (* Copyright (c) 2017 David Kaloper Meršinjak. All rights reserved.
        2:    See LICENSE.md. *)
        3: 
        4: open Notty;;
        5: 
        6: #install_printer Notty.Render.pp_image;;
        7: #install_printer Notty.Render.pp_attr;;
Added regular file ../notty/src-lwt/dune:
        1: (library
        2:   (public_name notty.lwt)
        3:   (synopsis "Notty Lwt+Unix IO")
        4:   (name notty_lwt)
        5:   (wrapped false)
        6:   (optional)
        7:   (libraries notty notty.unix lwt lwt.unix))
Added regular file ../notty/src-lwt/notty_lwt.ml:
        1: (* Copyright (c) 2016-2017 David Kaloper Meršinjak. All rights reserved.
        2:    See LICENSE.md. *)
        3: 
        4: open Lwt.Infix
        5: 
        6: open Notty
        7: open Notty_unix
        8: open Private
        9: 
       10: 
       11: type ('a, 'b) either = Left of 'a | Right of 'b
       12: let left  x = Left x
       13: let right y = Right y
       14: 
       15: let (</>) a b = Lwt.pick [(a >|= left); (b >|= right)]
       16: let (<??>) a b = (a >|= left) <?> (b >|= right)
       17: 
       18: let whenopt f = function Some x -> f x | None -> ()
       19: 
       20: let rec write fd buf off = function
       21:   | 0 -> Lwt.return_unit
       22:   | n -> Lwt_unix.write fd buf off n >>= fun w -> write fd buf (off + w) (n - w)
       23: 
       24: module Lwt_condition = struct
       25: 
       26:   include Lwt_condition
       27: 
       28:   let map f c =
       29:     let d = create () in
       30:     let rec go () = wait c >>= fun x -> broadcast d (f x); go ()
       31:     in (Lwt.async go; d)
       32: 
       33:   let unburst ~t c =
       34:     let d = create () in
       35:     let rec delay x = Lwt_unix.sleep t </> wait c >>= function
       36:       | Left () -> broadcast d x; start ()
       37:       | Right x -> delay x
       38:     and start () = wait c >>= delay in
       39:     Lwt.async start; d
       40: end
       41: 
       42: module Term = struct
       43: 
       44:   let winches = lazy (
       45:     let c = Lwt_condition.create () in
       46:     let `Revert _ = set_winch_handler (Lwt_condition.broadcast c) in
       47:     c
       48:   )
       49: 
       50:   let winch () = Lazy.force winches |> Lwt_condition.wait
       51: 
       52:   let bsize = 1024
       53: 
       54:   let input_stream ~nosig fd stop =
       55:     let `Revert f = setup_tcattr ~nosig (Lwt_unix.unix_file_descr fd) in
       56:     let stream =
       57:       let flt  = Unescape.create ()
       58:       and ibuf = Bytes.create bsize in
       59:       let rec next () =
       60:         match Unescape.next flt with
       61:         | #Unescape.event as r -> Lwt.return_some r
       62:         | `End   -> Lwt.return_none
       63:         | `Await ->
       64:             (Lwt_unix.read fd ibuf 0 bsize <??> stop) >>= function
       65:               | Left n  -> Unescape.input flt ibuf 0 n; next ()
       66:               | Right _ -> Lwt.return_none
       67:       in Lwt_stream.from next in
       68:     Lwt.async (fun () -> Lwt_stream.closed stream >|= f);
       69:     stream
       70: 
       71:   type t = {
       72:     ochan  : Lwt_io.output_channel
       73:   ; trm    : Tmachine.t
       74:   ; buf    : Buffer.t
       75:   ; fds    : Lwt_unix.file_descr * Lwt_unix.file_descr
       76:   ; events : [ Unescape.event | `Resize of (int * int) ] Lwt_stream.t
       77:   ; stop   : (unit -> unit)
       78:   }
       79: 
       80:   let write t =
       81:     Tmachine.output t.trm t.buf;
       82:     let out = Buffer.contents t.buf in (* XXX There goes 0copy. :/ *)
       83:     Buffer.clear t.buf; Lwt_io.write t.ochan out
       84: 
       85:   let refresh t      = Tmachine.refresh t.trm; write t
       86:   let image t image  = Tmachine.image t.trm image; write t
       87:   let cursor t curs  = Tmachine.cursor t.trm curs; write t
       88:   let set_size t dim = Tmachine.set_size t.trm dim
       89:   let size t         = Tmachine.size t.trm
       90: 
       91:   let release t =
       92:     if Tmachine.release t.trm then
       93:       ( t.stop (); write t >>= fun () -> Lwt_io.flush t.ochan )
       94:     else Lwt.return_unit
       95: 
       96:   let resizef fd stop on_resize =
       97:     if Unix.isatty fd then
       98:       let rcond = Lwt_condition.(
       99:         Lazy.force winches |> unburst ~t:0.1 |> map (fun () -> winsize fd)) in
      100:       let rec monitor () =
      101:         (Lwt_condition.wait rcond <?> stop) >>= function
      102:           | Some dim -> on_resize dim; monitor ()
      103:           | None     -> Lwt.return_unit in
      104:       Lwt.async monitor;
      105:       Lwt_stream.from (fun () -> Lwt_condition.wait rcond <?> stop)
      106:         |> Lwt_stream.map (fun dim -> `Resize dim)
      107:     else Lwt_stream.of_list []
      108: 
      109:   let create ?(dispose=true) ?(nosig=true) ?(mouse=true) ?(bpaste=true)
      110:              ?(input=Lwt_unix.stdin) ?(output=Lwt_unix.stdout) () =
      111:     let fd = Lwt_unix.unix_file_descr output in
      112:     let (stop, stopw) = Lwt.wait () in
      113:     let rec t = lazy {
      114:         trm    = Tmachine.create ~mouse ~bpaste (cap_for_fd fd)
      115:       ; ochan  = Lwt_io.(of_fd ~mode:output) output
      116:       ; buf    = Buffer.create 4096
      117:       ; fds    = (input, output)
      118:       ; stop   = (fun () -> Lwt.wakeup stopw None)
      119:       ; events = Lwt_stream.choose
      120:           [ input_stream ~nosig input stop
      121:           ; resizef fd stop @@ fun dim ->
      122:               let t = Lazy.force t in Buffer.reset t.buf; set_size t dim ]
      123:       } in
      124:     let t = Lazy.force t in
      125:     winsize fd |> whenopt (set_size t);
      126:     Lwt.async (fun () -> write t); (* XXX async? *)
      127:     if dispose then Lwt_main.at_exit (fun () -> release t);
      128:     t
      129: 
      130:   let events t = t.events
      131:   let fds    t = t.fds
      132: end
      133: 
      134: let winsize fd = winsize (Lwt_unix.unix_file_descr fd)
      135: 
      136: include Gen_output (struct
      137:   type fd = Lwt_unix.file_descr and k = unit Lwt.t
      138:   let (def, to_fd) = Lwt_unix.(stdout, unix_file_descr)
      139:   and write fd buf = Buffer.(write fd (to_bytes buf) 0 (length buf))
      140: end)
Added regular file ../notty/src-lwt/notty_lwt.mli:
        1: (* Copyright (c) 2016-2017 David Kaloper Meršinjak. All rights reserved.
        2:    See LICENSE.md. *)
        3: 
        4: (** [Notty] IO [Lwt] on [Unix].
        5: 
        6:     This is an IO module for {!Notty}.
        7: 
        8:     It mirrors {!Notty_unix} and the corresponding operations behave
        9:     analogously. Consult its documentation for more info.
       10: 
       11:     {e %%VERSION%% — {{:%%PKG_HOMEPAGE%% }homepage}} *)
       12: 
       13: open Notty
       14: 
       15: (** {1:fullscreen Fullscreen input and output}. *)
       16: 
       17: (** Terminal IO with concurrency.
       18: 
       19:     For more info, see {!Notty_unix.Term}. *)
       20: module Term : sig
       21: 
       22:   type t
       23: 
       24:   (** {1 Construction and destruction} *)
       25: 
       26:   val create : ?dispose:bool ->
       27:                ?nosig:bool ->
       28:                ?mouse:bool ->
       29:                ?bpaste:bool ->
       30:                ?input:Lwt_unix.file_descr ->
       31:                ?output:Lwt_unix.file_descr ->
       32:                unit -> t
       33:   (** [create ~dispose ~nosig ~mouse ~input ~output ()] creates a new
       34:       {{!t}terminal}.
       35: 
       36:       {b Note} [~dispose] arranges for the terminal to be disposed of at the end
       37:       of the [Lwt] main loop, and not at process exit.
       38: 
       39:       See {!Notty_unix.Term.create}. *)
       40: 
       41:   val release : t -> unit Lwt.t
       42: 
       43:   (** {1 Commands} *)
       44: 
       45:   val image   : t -> image -> unit Lwt.t
       46:   val refresh : t -> unit Lwt.t
       47:   val cursor  : t -> (int * int) option -> unit Lwt.t
       48: 
       49:   (** {1 Events} *)
       50: 
       51:   val events : t -> [ Unescape.event | `Resize of (int * int) ] Lwt_stream.t
       52:   (** [events t] is the stream of incoming events.
       53: 
       54:       Invoking {{!release}release} will terminate this stream.
       55: 
       56:       Events are:
       57:       {ul
       58:       {- [#Unescape.event], an {{!Notty.Unescape.event}event} from the input
       59:          fd; or}
       60:       {- [`Resize (cols, rows)] whenever the terminal size changes.}}
       61: 
       62:       {b Note} This stream is unique; for the same [t], [events t] always
       63:       returns the same stream. *)
       64: 
       65:   (** {1 Properties} *)
       66: 
       67:   val size : t -> int * int
       68: 
       69:   val fds : t -> Lwt_unix.file_descr * Lwt_unix.file_descr
       70: 
       71:   (** {1 Window size change notifications}
       72: 
       73:       {{!create}Creating} a terminal will install a [SIGWINCH] handler.
       74:       The handler should not be replaced directly. This API allows the user to
       75:       monitor deliveries of the signal.
       76: 
       77:       See {!Notty_unix.Term.Winch}. *)
       78: 
       79:   val winch : unit -> unit Lwt.t
       80:   (** [winch ()] is a thread completing after the next [SIGWINCH]. A single
       81:       signal delivery will cause the completion of all waiting [winch] threads. *)
       82: end
       83: 
       84: (** {1:inline Inline output} *)
       85: 
       86: val winsize : Lwt_unix.file_descr -> (int * int) option
       87: 
       88: val eol : image -> image
       89: 
       90: val output_image :
       91:   ?cap:Cap.t -> ?fd:Lwt_unix.file_descr -> image -> unit Lwt.t
       92: 
       93: val output_image_size :
       94:   ?cap:Cap.t -> ?fd:Lwt_unix.file_descr -> (int * int -> image) -> unit Lwt.t
       95: 
       96: val show_cursor : ?cap:Cap.t -> ?fd:Lwt_unix.file_descr -> bool -> unit Lwt.t
       97: 
       98: val move_cursor :
       99:   ?cap:Cap.t -> ?fd:Lwt_unix.file_descr ->
      100:     [ `Home | `By of int * int | `To of int * int ] -> unit Lwt.t
Added regular file ../notty/src-unix/dune:
        1: (library
        2:   (public_name notty.unix)
        3:   (synopsis "Notty Unix IO")
        4:   (name notty_unix)
        5:   (wrapped false)
        6:   (c_names winsize)
        7:   (c_flags (-Wall -Wextra -O3))
        8:   (optional)
        9:   (libraries notty unix))
       10: 
       11: (include_subdirs unqualified)
Added regular file ../notty/src-unix/native/winsize.c:
        1: #include <sys/ioctl.h>
        2: #include <signal.h>
        3: #include <caml/mlvalues.h>
        4: 
        5: CAMLprim value caml_notty_winsize (value vfd) {
        6:   int fd = Int_val (vfd);
        7:   struct winsize w;
        8:   if (ioctl (fd, TIOCGWINSZ, &w) >= 0)
        9:     return Val_int ((w.ws_col << 16) + ((w.ws_row & 0x7fff) << 1));
       10:   return Val_int (0);
       11: }
       12: 
       13: #define __unit() value unit __attribute__((unused))
       14: 
       15: CAMLprim value caml_notty_winch_number (__unit()) {
       16:   return Val_int (SIGWINCH);
       17: }
Added regular file ../notty/src-unix/notty_unix.ml:
        1: (* Copyright (c) 2016-2017 David Kaloper Meršinjak. All rights reserved.
        2:    See LICENSE.md. *)
        3: 
        4: open Notty
        5: 
        6: external c_winsize : Unix.file_descr -> int = "caml_notty_winsize" [@@noalloc]
        7: external winch_number : unit -> int = "caml_notty_winch_number" [@@noalloc]
        8: 
        9: let iter f = function Some x -> f x | _ -> ()
       10: let value x = function Some a -> a | _ -> x
       11: 
       12: let winsize fd = match c_winsize fd with
       13:   | 0  -> None
       14:   | wh -> Some (wh lsr 16, wh lsr 1 land 0x7fff)
       15: 
       16: module Private = struct
       17: 
       18:   let once f = let v = lazy (f ()) in fun () -> Lazy.force v
       19: 
       20:   let cap_for_fd =
       21:     let open Cap in
       22:     match Sys.getenv "TERM" with
       23:     | exception Not_found -> fun _ -> dumb
       24:     | (""|"dumb")         -> fun _ -> dumb
       25:     | _                   -> fun fd -> if Unix.isatty fd then ansi else dumb
       26: 
       27:   let setup_tcattr ~nosig fd =
       28:     let open Unix in try
       29:       let tc = tcgetattr fd in
       30:       let tc1 = { tc with c_icanon = false; c_echo = false } in
       31:       tcsetattr fd TCSANOW
       32:         ( if nosig then { tc1 with c_isig = false; c_ixon = false } else tc1 );
       33:       `Revert (once @@ fun _ -> tcsetattr fd TCSANOW tc)
       34:     with Unix_error (ENOTTY, _, _) -> `Revert ignore
       35: 
       36:   let set_winch_handler f =
       37:     let signum = winch_number () in
       38:     let old_hdl = Sys.(signal signum (Signal_handle (fun _ -> f ()))) in
       39:     `Revert (once @@ fun () -> Sys.set_signal signum old_hdl)
       40: 
       41:   module Gen_output (O : sig
       42:     type fd
       43:     type k
       44:     val def   : fd
       45:     val to_fd : fd -> Unix.file_descr
       46:     val write : fd -> Buffer.t -> k
       47:   end) = struct
       48: 
       49:     let scratch = lazy (Buffer.create 4096)
       50: 
       51:     let output ?cap ?(fd = O.def) f =
       52:       let cap = cap |> value (cap_for_fd (O.to_fd fd)) in
       53:       let buf = Lazy.force scratch in
       54:       Buffer.reset buf; f buf cap fd; O.write fd buf
       55: 
       56:     let output_image_size ?cap ?fd f =
       57:       output ?cap ?fd @@ fun buf cap fd ->
       58:         let size = winsize (O.to_fd fd) in
       59:         let i = f (value (80, 24) size) in
       60:         let dim = match size with
       61:           | Some (w, _) -> I.(w, height i)
       62:           | None        -> I.(width i, height i) in
       63:         Render.to_buffer buf cap (0, 0) dim i
       64: 
       65:     let show_cursor ?cap ?fd x =
       66:       output ?cap ?fd @@ fun buf cap _ -> Direct.show_cursor buf cap x
       67: 
       68:     let move_cursor ?cap ?fd x =
       69:       output ?cap ?fd @@ fun buf cap _ -> Direct.move_cursor buf cap x
       70: 
       71:     let output_image ?cap ?fd i = output_image_size ?cap ?fd (fun _ -> i)
       72: 
       73:     let eol i = I.(i <-> void 0 1)
       74:   end
       75: end
       76: 
       77: open Private
       78: 
       79: module Term = struct
       80: 
       81:   module Winch = struct
       82: 
       83:     let h  = Hashtbl.create 3
       84:     and id = ref 0
       85: 
       86:     let add fd f =
       87:       let n = !id in
       88:       set_winch_handler (fun () -> Hashtbl.iter (fun _ f -> f ()) h) |> ignore;
       89:       Hashtbl.add h n (fun () -> winsize fd |> iter f); incr id;
       90:       `Revert (fun () -> Hashtbl.remove h n)
       91:   end
       92: 
       93:   module Input = struct
       94: 
       95:     type t = {
       96:       fd      : Unix.file_descr
       97:     ; flt     : Unescape.t
       98:     ; ibuf    : bytes
       99:     ; cleanup : unit -> unit
      100:     }
      101: 
      102:     let bsize = 1024
      103: 
      104:     let create ~nosig fd =
      105:       let flt  = Unescape.create ()
      106:       and ibuf = Bytes.create bsize
      107:       and `Revert cleanup = setup_tcattr ~nosig fd in
      108:       { fd; flt; ibuf; cleanup }
      109: 
      110:     let rec event t =
      111:       match Unescape.next t.flt with
      112:       | #Unescape.event | `End as r -> r
      113:       | `Await ->
      114:           let n = Unix.read t.fd t.ibuf 0 bsize in
      115:           Unescape.input t.flt t.ibuf 0 n; event t
      116:   end
      117: 
      118:   type t = {
      119:     output   : out_channel
      120:   ; trm      : Tmachine.t
      121:   ; buf      : Buffer.t
      122:   ; input    : Input.t
      123:   ; fds      : Unix.file_descr * Unix.file_descr
      124:   ; unwinch  : (unit -> unit) Lazy.t
      125:   ; mutable winched : bool
      126:   }
      127: 
      128:   let write t =
      129:     Buffer.clear t.buf;
      130:     Tmachine.output t.trm t.buf;
      131:     Buffer.output_buffer t.output t.buf; flush t.output
      132: 
      133:   let set_size t dim = Tmachine.set_size t.trm dim
      134:   let refresh t      = Tmachine.refresh t.trm; write t
      135:   let image t image  = Tmachine.image t.trm image; write t
      136:   let cursor t curs  = Tmachine.cursor t.trm curs; write t
      137:   let size t         = Tmachine.size t.trm
      138: 
      139:   let release t =
      140:     if Tmachine.release t.trm then
      141:       ( Lazy.force t.unwinch ();
      142:         t.input.Input.cleanup ();
      143:         write t )
      144: 
      145:   let create ?(dispose=true) ?(nosig=true) ?(mouse=true) ?(bpaste=true)
      146:              ?(input=Unix.stdin) ?(output=Unix.stdout) () =
      147:     let rec t = {
      148:         output  = Unix.out_channel_of_descr output
      149:       ; trm     = Tmachine.create ~mouse ~bpaste (cap_for_fd input)
      150:       ; buf     = Buffer.create 4096
      151:       ; input   = Input.create ~nosig input
      152:       ; fds     = (input, output)
      153:       ; winched = false
      154:       ; unwinch = lazy (
      155:           let `Revert f = Winch.add output @@ fun dim ->
      156:             Buffer.reset t.buf; t.winched <- true; set_size t dim in f)
      157:     } in
      158:     winsize output |> iter (set_size t);
      159:     (Lazy.force t.unwinch |> ignore) [@ocaml.warning "-5"];
      160:     if dispose then at_exit (fun () -> release t);
      161:     write t;
      162:     t
      163: 
      164:   let rec event = function
      165:     | t when Tmachine.dead t.trm -> `End
      166:     | t when t.winched -> t.winched <- false; `Resize (size t)
      167:     | t -> Unix.(try Input.event t.input with Unix_error (EINTR, _, _) -> event t)
      168: 
      169:   let pending t =
      170:     not (Tmachine.dead t.trm) &&
      171:     (t.winched || Unescape.pending t.input.Input.flt)
      172: 
      173:   let fds t = t.fds
      174: end
      175: 
      176: include Gen_output (struct
      177:   type fd = out_channel and k = unit
      178:   let def   = stdout
      179:   and to_fd = Unix.descr_of_out_channel
      180:   and write = Buffer.output_buffer
      181: end)
Added regular file ../notty/src-unix/notty_unix.mli:
        1: (* Copyright (c) 2016-2017 David Kaloper Meršinjak. All rights reserved.
        2:    See LICENSE.md. *)
        3: 
        4: (** [Notty] IO for pure [Unix].
        5: 
        6:     This is an IO module for {!Notty}.
        7: 
        8:     {e %%VERSION%% — {{:%%PKG_HOMEPAGE%% }homepage}} *)
        9: 
       10: open Notty
       11: 
       12: (** {1:fullscreen Fullscreen input and output}. *)
       13: 
       14: (** Terminal IO abstraction for fullscreen, interactive applications.
       15: 
       16:     This module provides both input and output. It assumes exclusive ownership of
       17:     the IO streams between {{!create}initialization} and {{!release}shutdown}. *)
       18: module Term : sig
       19: 
       20:   type t
       21:   (** Representation of the terminal, giving structured access to IO. *)
       22: 
       23:   (** {1 Construction and destruction} *)
       24: 
       25:   val create : ?dispose:bool ->
       26:                ?nosig:bool ->
       27:                ?mouse:bool ->
       28:                ?bpaste:bool ->
       29:                ?input:Unix.file_descr ->
       30:                ?output:Unix.file_descr ->
       31:                unit -> t
       32:   (** [create ~dispose ~nosig ~mouse ~input ~output ()] creates a fresh
       33:       {{!t}terminal}. It has the following side effects:
       34:       {ul
       35:       {- [Unix.tcsetattr] is applied to [input] to disable {e echo} and
       36:          {e canonical mode}.}
       37:       {- [output] is set to {e alternate screen mode}, and the cursor is
       38:          hidden. Mouse and {e bracketed paste} reporting are (optionally)
       39:          enabled.}
       40:       {- [SIGWINCH] signal, normally ignored, is handled.}}
       41: 
       42:       [~dispose] arranges for automatic {{!release}cleanup} of the terminal
       43:       before the process terminates. The downside is that a reference to this
       44:       terminal is retained until the program exits. Defaults to [true].
       45: 
       46:       [~nosig] additionally turns off signal delivery and flow control
       47:       ({e isig} and {e ixon}) on input. Inhibits automatic handling of
       48:       {e CTRL-\{C,Z,\,S,Q\}}. Defaults to [true].
       49: 
       50:       [~mouse] activates mouse reporting. Defaults to [true].
       51: 
       52:       [~bpaste] activates bracketed paste reporting. Defaults to [true].
       53: 
       54:       [~input] is the input file descriptor. Defaults to [stdin].
       55: 
       56:       [~output] is the output file descriptor. Defaults to [stdout]. *)
       57: 
       58:   val release : t -> unit
       59:   (** Dispose of this terminal. Original behavior of input fd is reinstated,
       60:       cursor is restored, mouse reporting disabled, and alternate mode is
       61:       terminated.
       62: 
       63:       It is an error to use the {{!cmds}commands} on a released terminal, and
       64:       will raise [Invalid_argument], while [release] itself is idempotent. *)
       65: 
       66:   (** {1:cmds Commands} *)
       67: 
       68:   val image : t -> image -> unit
       69:   (** [image t i] sets [i] as [t]'s current image and redraws the terminal. *)
       70: 
       71:   val refresh : t -> unit
       72:   (** [refresh t] redraws the terminal using the current image.
       73: 
       74:       Useful if the output might have become garbled. *)
       75: 
       76:   val cursor : t -> (int * int) option -> unit
       77:   (** [cursor t pos] sets and redraws the cursor.
       78: 
       79:       [None] hides it. [Some (x, y)] places it at column [x] and row [y], with
       80:       the origin at [(0, 0)], mapping to the upper-left corner. *)
       81: 
       82:   (** {1 Events} *)
       83: 
       84:   val event : t -> [ Unescape.event | `Resize of (int * int) | `End ]
       85:   (** Wait for a new event. [event t] can be:
       86:       {ul
       87:       {- [#Unescape.event], an {{!Notty.Unescape.event}[event]} from the input fd;}
       88:       {- [`End] if the input fd is closed, or the terminal was released; or}
       89:       {- [`Resize (cols, rows)] giving the current size of the output tty, if a
       90:          [SIGWINCH] was delivered before or during this call to [event].}}
       91: 
       92:       {b Note} [event] is buffered. Calls can either block or immediately
       93:       return. Use {{!pending}[pending]} to detect when the next call would not
       94:       block. *)
       95: 
       96:   val pending : t -> bool
       97:   (** [pending t] is [true] if the next call to {{!event}[event]} would not
       98:       block and the terminal has not yet been released. *)
       99: 
      100:   (** {1 Properties} *)
      101: 
      102:   val size : t -> int * int
      103:   (** [size t] is the current size of the terminal's output tty. *)
      104: 
      105:   val fds : t -> Unix.file_descr * Unix.file_descr
      106:   (** [fds t] are [t]'s input and output file descriptors. *)
      107: 
      108:   (** {1 Window size change notifications} *)
      109: 
      110:   (** Manual [SIGWINCH] handling.
      111: 
      112:       Unix delivers notifications about tty size changes through the [SIGWINCH]
      113:       signal. A handler for this signal is installed as soon as a new terminal
      114:       is {{!create}created}. Replacing the global [SIGWINCH] handler using
      115:       the [Sys] module will cause this module to malfunction, as the size change
      116:       notifications will no longer be delivered.
      117: 
      118:       You might still want to ignore resizes reported by {{!event}[event]} and
      119:       directly listen to [SIGWINCH]. This module allows installing such
      120:       listeners without conflicting with the rest of the machinery. *)
      121:   module Winch : sig
      122: 
      123:     val add : Unix.file_descr -> ((int * int) -> unit) -> [`Revert of unit -> unit]
      124:     (** [add fd f] registers a [SIGWINCH] handler. Every time the signal is
      125:         delivered, [f] is called with the current size of the tty backing [fd].
      126:         If [fd] is not a tty, [f] is never called.
      127: 
      128:         Return value is a function that removes the handler [f].
      129: 
      130:         Handlers are called in an unspecified order. *)
      131: 
      132:   end
      133: end
      134: 
      135: (** {1:inline Inline output}
      136: 
      137:     These operations do not assume exclusive access to the output. This means
      138:     that they can be combined with other means of producing output. At the same
      139:     time, it means that they are affected by the current terminal state, and
      140:     that this state is not tracked. *)
      141: 
      142: val winsize : Unix.file_descr -> (int * int) option
      143: (** [winsize fd] is [Some (columns, rows)], the current dimensions of [fd]'s
      144:     backing tty, or [None], when [fd] is not backed by a tty. *)
      145: 
      146: val eol : image -> image
      147: (** [eol image] is [image], producing an extra newline when printed. *)
      148: 
      149: val output_image :
      150:   ?cap:Cap.t -> ?fd:out_channel -> image -> unit
      151: (** [output_image ?cap ?fd image] writes [image] to [fd].
      152: 
      153:     The image is displayed in its full height. If the output is a tty, image
      154:     width is clipped to the output width. Otherwise, full width is used.
      155: 
      156:     [~cap] is the {{!caps}optional} terminal capability set.
      157: 
      158:     [~fd] defaults to [stdout]. *)
      159: 
      160: val output_image_size : ?cap:Cap.t -> ?fd:out_channel -> (int * int -> image) -> unit
      161: (** [output_image_size ?cap ?fd f] is
      162:     [output_image ?cap ?fd (f size)] where [size] are [fd]'s current
      163:     {{!winsize}output dimensions}.
      164: 
      165:     If [fd] is not backed by a tty, as a matter of convenience, [f] is applied
      166:     to [(80, 24)]. Use {!Unix.isatty} or {{!winsize}[winsize]} to detect whether
      167:     the output has a well-defined size. *)
      168: 
      169: val show_cursor : ?cap:Cap.t -> ?fd:out_channel -> bool -> unit
      170: (** [show_cursor ?cap ?fd visible] toggles the cursor visibility on [fd]. *)
      171: 
      172: val move_cursor :
      173:   ?cap:Cap.t -> ?fd:out_channel ->
      174:     [ `Home | `By of int * int | `To of int * int ] -> unit
      175: (** [move_cursor ?cap ?fd motion] moves the cursor on [fd].
      176: 
      177:     [motion] is one of:
      178:     {ul
      179:     {- [`To (column, line)], positioning the cursor to [(column, line)]. Origin
      180:        is [(0, 0)], the upper-left corner of the screen.}
      181:     {- [`Home], moving the cursor the beginning of line.}
      182:     {- [`By (columns, lines)], moving the cursor [columns] to the right (left if
      183:        negative) and [lines] down (up if negative).
      184: 
      185:        {b Note} Behavior is terminal dependent if the movement overshoots the
      186:        output size.}} *)
      187: 
      188: (** {1:caps Capability detection}
      189: 
      190:     All [image] output requires {{!Notty.Cap.t}terminal capabilities}.
      191: 
      192:     When not provided, capabilities are auto-detected, by checking that the
      193:     output is a tty, that the environment variable [$TERM] is set, and that it
      194:     is not set to either [""] or ["dumb"]. If these conditions hold,
      195:     {{!Notty.Cap.ansi}ANSI} escapes are used. Otherwise, {{!Notty.Cap.dumb}no}
      196:     escapes are used. *)
      197: 
      198: (**/**)
      199: (** {1 Private}
      200: 
      201:     These are private interfaces, prone to breakage. Don't use them. *)
      202: module Private : sig
      203: 
      204:   val cap_for_fd        : Unix.file_descr -> Cap.t
      205:   val setup_tcattr      : nosig:bool -> Unix.file_descr -> [ `Revert of (unit -> unit) ]
      206:   val set_winch_handler : (unit -> unit) -> [ `Revert of (unit -> unit) ]
      207: 
      208:   module Gen_output (O : sig
      209:     type fd
      210:     type k
      211:     val def   : fd
      212:     val to_fd : fd -> Unix.file_descr
      213:     val write : fd -> Buffer.t -> k
      214:   end ) : sig
      215:     val output_image : ?cap:Cap.t -> ?fd:O.fd -> image -> O.k
      216:     val output_image_size : ?cap:Cap.t -> ?fd:O.fd -> (int * int -> image) -> O.k
      217:     val show_cursor : ?cap:Cap.t -> ?fd:O.fd -> bool -> O.k
      218:     val move_cursor : ?cap:Cap.t -> ?fd:O.fd -> [ `Home | `By of int * int | `To of int * int ] -> O.k
      219:     val eol : image -> image
      220:   end
      221: end
      222: (**/**)
Added executable file ../notty/support/gen_unicode_props.ml:
        1: #!/usr/bin/env ocaml
        2: (* Copyright (c) 2020 David Kaloper Meršinjak. All rights reserved.
        3:    See LICENSE.md. *)
        4: 
        5: #use "topfind"
        6: #require "uucp"
        7: 
        8: let filter p seq i = seq (fun x -> if p x then i x)
        9: let map f seq i = seq (fun x -> i (f x))
       10: let uchars it =
       11:   let rec go it u = it u; go it (Uchar.succ u) in
       12:   try go it Uchar.min with Invalid_argument _ -> ()
       13: let to_list seq =
       14:   let xs = ref [] in
       15:   seq (fun x -> xs := x :: !xs);
       16:   List.rev !xs
       17: 
       18: let intervals_kv seq i =
       19:   let s = ref None in
       20:   let f (x, v) = match !s with
       21:   | None -> s := Some (x, x, v)
       22:   | Some (a, b, v0) when v = v0 && x = Uchar.succ b -> s := Some (a, x, v0)
       23:   | Some e -> i e; s := Some (x, x, v) in
       24:   seq f;
       25:   match !s with Some e -> i e | _ -> ()
       26: 
       27: let intervals_p seq =
       28:   map (fun x -> x, ()) seq |> intervals_kv |> map (fun (a, b, _) -> a, b)
       29: 
       30: (* Condenses code points into continuous range. *)
       31: let pack_u u = let i = Uchar.to_int u in if i > 0xd7ff then i - 0x800 else i
       32: let unpack_u i = Uchar.of_int (if i < 0xd800 then i else i + 0x800)
       33: 
       34: (* 12-6-6-bit (0xfff-0x3f-0x3f) trie, 3 levels, array-array-string.
       35:    Root is variable; lower levels are either empty or complete.
       36: 
       37:    At the moment, packed Uchar.max is 0x10f7ff; this can map up to 0xffffff
       38:    distinct code points.  *)
       39: let trie ~default f =
       40:   let xs = List.init ((pack_u Uchar.max lsr 12) + 1) @@ fun b0 ->
       41:     let mask = b0 lsl 12 in
       42:     let arr = Array.init 0x40 @@ fun b1 ->
       43:       let mask = mask lor (b1 lsl 6) in
       44:       let v b2 = match unpack_u (mask lor b2) with
       45:       | x -> f x
       46:       | exception Invalid_argument _ -> default in
       47:       match (for b2 = 0 to 0x3f do if v b2 <> default then raise Exit done) with
       48:       | exception Exit -> String.init 0x40 (fun b2 -> Char.chr (v b2))
       49:       | () -> ""
       50:     in
       51:     if Array.for_all ((=) "") arr then [||] else arr
       52:   in
       53:   let rec trim = function [||]::xs -> trim xs | xs -> xs in
       54:   List.rev (trim (List.rev xs)) |> Array.of_list
       55: 
       56: let pf = Format.fprintf
       57: let strf = Format.sprintf
       58: let pp_iter ?(sep = fun _ _ -> ()) iter pp ppf x =
       59:   let fst = ref true in
       60:   let f x = (if !fst then fst := false else sep ppf ()); pp ppf x in
       61:   iter f x
       62: let pp_u ppf u = pf ppf "0x%04x" (Uchar.to_int u)
       63: let pp_as_array iter pp ppf x =
       64:   let sep ppf () = pf ppf ";@ " in
       65:   pf ppf "@[<2>[|%a|]@]" (pp_iter ~sep iter pp) x
       66: 
       67: let intern ppf_ml iter =
       68:   let t = Hashtbl.create 16 in
       69:   let n = ref 0 in
       70:   iter (fun s -> if not (Hashtbl.mem t s) then begin
       71:     let name = strf "s%03d" !n in
       72:     Hashtbl.add t s name; incr n;
       73:     pf ppf_ml "let %s = %S@." name s
       74:   end);
       75:   pf ppf_ml "@.";
       76:   (fun ppf s -> match Hashtbl.find_opt t s with
       77:    | Some name -> pf ppf "%s" name
       78:    | None -> pf ppf "%S" s)
       79: 
       80: let dump_interval_map (ppf_mli, ppf_ml) ~name ~desc seq =
       81:   pf ppf_mli "(* %s *)@.val %s: int array * int array * int array@.@." desc name;
       82:   let xs = to_list (intervals_kv seq) in
       83:   let aa = List.map (fun (a, _, _) -> a) xs
       84:   and bb = List.map (fun (_, b, _) -> b) xs
       85:   and cc = List.map (fun (_, _, c) -> c) xs in
       86:   let pp_arr pp = pp_as_array List.iter pp in
       87:   let pp_arr_u = pp_arr pp_u and pp_arr_i = pp_arr Format.pp_print_int in
       88:   pf ppf_ml "@[<2>let %s =@ @[<1>(%a,@ %a,@ %a)@]@]@.@."
       89:      name pp_arr_u aa pp_arr_u bb pp_arr_i cc
       90: 
       91: let dump_trie_map (ppf_mli, ppf_ml) ~name ~desc ~default f =
       92:   pf ppf_mli "(* %s *)@.val %s: string array array@.@." desc name;
       93:   let xs = trie ~default f in
       94:   let pp_s = intern ppf_ml Array.(fun i -> i ""; iter (iter i) xs) in
       95:   pf ppf_ml "@[<2>let %s =@ %a@]" name
       96:     Array.(pp_as_array iter (pp_as_array iter pp_s)) xs
       97: 
       98: let pp_header ppf = Format.fprintf ppf
       99: "(* Do not edit.
      100:  *
      101:  * This module contains select unicode properties extracted from Uucp,
      102:  * using `%s`.
      103:  *
      104:  * Unicode version %s.
      105:  *)
      106: 
      107: " Sys.argv.(0) Uucp.unicode_version
      108: 
      109: let extract (ppmli, ppml as ppfs) =
      110: 
      111:   pp_header ppmli; pp_header ppml;
      112: 
      113:   dump_interval_map ppfs
      114:     ~name:"tty_width_hint"
      115:     ~desc:"Uucp.Break.tty_width_hint"
      116:     (* w = -1 is easy to detect.
      117:        w = 1 covers the most intervals, so we default it. *)
      118:     (uchars |> map (fun u -> u, Uucp.Break.tty_width_hint u)
      119:             |> filter (fun (_, w) -> w <> -1 && w <> 1));
      120: 
      121:   (* dump_interval_map ppfs *)
      122:   (*   ~name:"grapheme_cluster_boundary" *)
      123:   (*   ~desc:"Uucp.Break.Low.grapheme_cluster." *)
      124:   (*   (1* No single value dominates the histogram. *1) *)
      125:   (*   (uchars |> map (fun u -> u, Uucp.Break.Low.grapheme_cluster u)); *)
      126: 
      127:   dump_trie_map ppfs
      128:     ~name:"grapheme_cluster_boundary"
      129:     ~desc:"Uucp.Break.Low.grapheme_cluster."
      130:     ~default:16 (* 16 - `XX - is by far the most prevalent value *)
      131:     Uucp.Break.Low.grapheme_cluster;
      132: 
      133:   ()
      134: 
      135: let file = "src/no-uucp/notty_uucp_data"
      136: 
      137: let with_new name f =
      138:   let o = open_out_gen [Open_trunc; Open_creat; Open_wronly] 0o664 name in
      139:   let ppf = Format.formatter_of_out_channel o in
      140:   f ppf; Format.pp_print_flush ppf (); close_out o
      141: 
      142: let () =
      143:   Format.printf "Dumping Unicode v%s data to %s.@." Uucp.unicode_version file;
      144:   with_new (file ^ ".mli") @@ fun ppmli ->
      145:     with_new (file ^ ".ml") @@ fun ppml ->
      146:       extract (ppmli, ppml)
Removed regular file ../test/dune:
   1     : (test
   2     :  (name jj_tui))
Removed regular file ../test/jj_tui.ml:
    (empty)
